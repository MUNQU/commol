{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EpiModel","text":"<p>A high-performance mathematical epidemiology library for modeling infectious disease spread using difference equations. EpiModel provides a clean Python API backed by a fast Rust engine for numerical computations.</p> <p>Alpha Stage - API Unstable</p> <p>EpiModel is currently in alpha development. The API is not yet stable and may change between versions without backward compatibility guarantees.</p> <pre><code>- Breaking changes may occur in any release\n- Not recommended for production use yet\n- API will stabilize in version 1.0.0\n\nWe welcome feedback and contributions as we work toward a stable release!\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Intuitive Model Building: Fluent API for constructing epidemiological models</li> <li>Mathematical Expressions: Support for complex mathematical formulas in transition rates</li> <li>High Performance: Rust-powered simulation engine for fast computations</li> <li>Flexible Architecture: Support for stratified populations and conditional transitions</li> <li>Type Safety: Comprehensive validation using Pydantic models</li> <li>Multiple Output Formats: Get results as dictionaries or lists for easy analysis</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from epimodel import ModelBuilder, Simulation\nfrom epimodel.constants import ModelTypes\n\n# Build a simple SIR model\nmodel = (\n    ModelBuilder(name=\"Basic SIR\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"N\", value=1000.0)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run simulation\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide - Install EpiModel</li> <li>Quick Start - Build your first model</li> <li>Core Concepts - Understand the fundamentals</li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#user-guide","title":"User Guide","text":"<p>Learn how to build and run epidemiological models:</p> <ul> <li>Core Concepts - Disease states, stratifications, parameters</li> <li>Building Models - Using the ModelBuilder API</li> <li>Mathematical Expressions - Advanced rate formulas</li> <li>Running Simulations - Execute models and analyze results</li> <li>Examples - Complete model examples (SIR, SEIR, stratified)</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<p>Complete API documentation for all public interfaces:</p> <ul> <li>Model Builder - ModelBuilder class documentation</li> <li>Simulation - Simulation runner</li> <li>Constants - Model types and enumerations</li> </ul>"},{"location":"#development","title":"Development","text":"<p>Contributing to EpiModel:</p> <ul> <li>Development Workflow - Setup, branching, CI/CD</li> <li>Contributing Guidelines - How to contribute</li> <li>Release Process - Version management and releases</li> </ul>"},{"location":"#license","title":"License","text":"<p>EpiModel is licensed under the MIT License. See License for details.</p>"},{"location":"#authors","title":"Authors","text":"<p>MUNQU Team</p> <ul> <li>Rafael J. Villanueva Mic\u00f3</li> <li>Carlos Andreu Vilarroig</li> <li>David Mart\u00ednez Rodr\u00edguez</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to EpiModel will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>GitHub Actions CI/CD pipelines for code quality, building, and PyPI releases</li> <li>MkDocs Material documentation site</li> <li>Comprehensive development workflow documentation</li> <li>Contributing guidelines and release process documentation</li> </ul>"},{"location":"about/changelog/#001-2025","title":"[0.0.1] - 2025","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of EpiModel</li> <li>ModelBuilder fluent API for constructing epidemiological models</li> <li>Support for difference equations models</li> <li>Disease states and stratifications</li> <li>Mathematical expression support in transition rates</li> <li>Rust-powered simulation engine</li> <li>Python API with Pydantic validation</li> <li>Basic SIR, SEIR model support</li> <li>Initial conditions and parameter management</li> <li>Simulation runner with multiple output formats</li> </ul>"},{"location":"about/changelog/#security","title":"Security","text":"<ul> <li>Expression validation to prevent code injection</li> <li>Input sanitization for mathematical formulas</li> </ul>"},{"location":"about/changelog/#version-history","title":"Version History","text":"<ul> <li>0.0.1 - Initial release with core functionality</li> <li>Unreleased - Current development version</li> </ul> <p>For detailed information about each release, see the GitHub Releases page.</p>"},{"location":"about/license/","title":"License","text":"<p>EpiModel is licensed under the MIT License.</p>"},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2025 MUNQU Team</p> <ul> <li>Rafael J. Villanueva Mic\u00f3</li> <li>Carlos Andreu Vilarroig</li> <li>David Mart\u00ednez Rodr\u00edguez</li> </ul> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>EpiModel uses the following open-source libraries:</p>"},{"location":"about/license/#python-dependencies","title":"Python Dependencies","text":"<ul> <li>Pydantic - MIT License</li> <li>cffi - MIT License</li> </ul>"},{"location":"about/license/#rust-dependencies","title":"Rust Dependencies","text":"<ul> <li>pyo3 - Apache-2.0 OR MIT License</li> <li>serde - Apache-2.0 OR MIT License</li> </ul> <p>For a complete list of dependencies and their licenses, see the project's <code>Cargo.toml</code> and <code>pyproject.toml</code> files.</p>"},{"location":"advanced/model-structure/","title":"Model Structure (Advanced)","text":"<p>For Advanced Users</p> <p>This section documents the internal structure of the <code>Model</code> class and its components.</p> <pre><code>**Most users don't need this** - use `ModelBuilder` instead to create models.\n\nThis is useful for:\n- Understanding the internal model representation\n- Working with `ModelLoader.from_json()`\n- Contributing to the library\n- Debugging complex models\n</code></pre>"},{"location":"advanced/model-structure/#model","title":"Model","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#epimodel.context.model.Model","title":"Model","text":"<p>               Bases: <code>BaseModel</code></p> <p>Root class of epidemiological model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A unique name that identifies the model.</p> <code>description</code> <code>str | None</code> <p>A human-readable description of the model's purpose and function.</p> <code>version</code> <code>str | None</code> <p>The version number of the model.</p> <code>population</code> <code>Population</code> <p>Population details, subpopulations, stratifications and initial conditions.</p> <code>parameters</code> <code>list[Parameter]</code> <p>A list of global model parameters.</p> <code>dynamics</code> <code>Dynamics</code> <p>The rules that govern system evolution.</p> Source code in <code>epimodel/context/model.py</code> <pre><code>class Model(BaseModel):\n    \"\"\"\n    Root class of epidemiological model.\n\n    Attributes\n    ----------\n    name : str\n        A unique name that identifies the model.\n    description : str | None\n        A human-readable description of the model's purpose and function.\n    version : str | None\n        The version number of the model.\n    population : Population\n        Population details, subpopulations, stratifications and initial conditions.\n    parameters : list[Parameter]\n        A list of global model parameters.\n    dynamics : Dynamics\n        The rules that govern system evolution.\n    \"\"\"\n\n    name: str = Field(..., description=\"Name which identifies the model.\")\n    description: str | None = Field(\n        None, \n        description=\"Human-readable description of the model's purpose and function.\"\n    )\n    version: str | None = Field(None, description=\"Version number of the model.\")\n\n    population: Population\n    parameters: list[Parameter]\n    dynamics: Dynamics\n\n    @model_validator(mode=\"after\")\n    def validate_transition_ids(self) -&gt; Self:\n        \"\"\"\n        Validates that transition ids (source/target) are consistent in type \n        and match the defined DiseaseState IDs or Stratification Categories \n        in the Population instance.\n        \"\"\"\n\n        disease_state_ids = {state.id for state in self.population.disease_states}\n        categories_ids = {\n            cat for strat in self.population.stratifications for cat in strat.categories\n        }\n        disease_state_and_categories_ids = disease_state_ids.union(categories_ids)\n\n        for transition in self.dynamics.transitions:\n            source = set(transition.source)\n            target = set(transition.target)\n            transition_ids = source.union(target)\n\n            if not transition_ids.issubset(disease_state_and_categories_ids):\n                invalid_ids = transition_ids - disease_state_and_categories_ids\n                raise ValueError((\n                    f\"Transition '{transition.id}' contains invalid ids: \"\n                    f\"{invalid_ids}. Ids must be defined in DiseaseState ids \"\n                    f\"or Stratification Categories.\"\n                ))\n\n            is_disease_state_flow = transition_ids.issubset(disease_state_ids)\n            is_stratification_flow = transition_ids.issubset(categories_ids)\n\n            if (not is_disease_state_flow) and (not is_stratification_flow):\n                disease_state_elements = transition_ids.intersection(disease_state_ids)\n                categories_elements = transition_ids.intersection(categories_ids)\n                raise ValueError((\n                    f\"Transition '{transition.id}' mixes id types. \"\n                    f\"Found DiseaseState ids ({disease_state_elements}) and \"\n                    f\"Stratification Categories ids ({categories_elements}). \"\n                    \"Transitions must be purely Disease State flow or purely \"\n                    f\"Stratification flow.\"\n                ))\n\n            if is_stratification_flow:\n                category_to_stratification_map = {\n                    cat: strat.id \n                    for strat in self.population.stratifications \n                    for cat in strat.categories\n                }\n                parent_stratification_ids = {\n                    category_to_stratification_map[cat_id]\n                    for cat_id in transition_ids\n                }\n                if len(parent_stratification_ids) &gt; 1:\n                    mixed_strats = \", \".join(parent_stratification_ids)\n                    raise ValueError((\n                        f\"Transition '{transition.id}' is a Stratification flow but \"\n                        f\"involves categories from multiple stratifications: \"\n                        f\"{mixed_strats}. A single transition must only move between \"\n                        \"categories belonging to the same parent stratification.\"\n                    ))\n\n        return self\n</code></pre>"},{"location":"advanced/model-structure/#epimodel.context.model.Model-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#epimodel.context.model.Model.validate_transition_ids","title":"validate_transition_ids","text":"<pre><code>validate_transition_ids() -&gt; Self\n</code></pre> <p>Validates that transition ids (source/target) are consistent in type  and match the defined DiseaseState IDs or Stratification Categories  in the Population instance.</p> Source code in <code>epimodel/context/model.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_transition_ids(self) -&gt; Self:\n    \"\"\"\n    Validates that transition ids (source/target) are consistent in type \n    and match the defined DiseaseState IDs or Stratification Categories \n    in the Population instance.\n    \"\"\"\n\n    disease_state_ids = {state.id for state in self.population.disease_states}\n    categories_ids = {\n        cat for strat in self.population.stratifications for cat in strat.categories\n    }\n    disease_state_and_categories_ids = disease_state_ids.union(categories_ids)\n\n    for transition in self.dynamics.transitions:\n        source = set(transition.source)\n        target = set(transition.target)\n        transition_ids = source.union(target)\n\n        if not transition_ids.issubset(disease_state_and_categories_ids):\n            invalid_ids = transition_ids - disease_state_and_categories_ids\n            raise ValueError((\n                f\"Transition '{transition.id}' contains invalid ids: \"\n                f\"{invalid_ids}. Ids must be defined in DiseaseState ids \"\n                f\"or Stratification Categories.\"\n            ))\n\n        is_disease_state_flow = transition_ids.issubset(disease_state_ids)\n        is_stratification_flow = transition_ids.issubset(categories_ids)\n\n        if (not is_disease_state_flow) and (not is_stratification_flow):\n            disease_state_elements = transition_ids.intersection(disease_state_ids)\n            categories_elements = transition_ids.intersection(categories_ids)\n            raise ValueError((\n                f\"Transition '{transition.id}' mixes id types. \"\n                f\"Found DiseaseState ids ({disease_state_elements}) and \"\n                f\"Stratification Categories ids ({categories_elements}). \"\n                \"Transitions must be purely Disease State flow or purely \"\n                f\"Stratification flow.\"\n            ))\n\n        if is_stratification_flow:\n            category_to_stratification_map = {\n                cat: strat.id \n                for strat in self.population.stratifications \n                for cat in strat.categories\n            }\n            parent_stratification_ids = {\n                category_to_stratification_map[cat_id]\n                for cat_id in transition_ids\n            }\n            if len(parent_stratification_ids) &gt; 1:\n                mixed_strats = \", \".join(parent_stratification_ids)\n                raise ValueError((\n                    f\"Transition '{transition.id}' is a Stratification flow but \"\n                    f\"involves categories from multiple stratifications: \"\n                    f\"{mixed_strats}. A single transition must only move between \"\n                    \"categories belonging to the same parent stratification.\"\n                ))\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#population","title":"Population","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#epimodel.context.population.Population","title":"Population","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the compartments, stratifications, and initial conditions of the population.</p> <p>Attributes:</p> Name Type Description <code>disease_states</code> <code>list[DiseaseState]</code> <p>A list of compartments or states that make up the model.</p> <code>stratifications</code> <code>list[Stratification]</code> <p>A list of categorical subdivisions of the population.</p> <code>initial_conditions</code> <code>Initialization</code> <p>Initial state of the subpopulations and stratifications.</p> Source code in <code>epimodel/context/population.py</code> <pre><code>class Population(BaseModel):\n    \"\"\"\n    Defines the compartments, stratifications, and initial conditions of the population.\n\n    Attributes\n    ----------\n    disease_states : list[DiseaseState]\n        A list of compartments or states that make up the model.\n    stratifications : list[Stratification]\n        A list of categorical subdivisions of the population.\n    initial_conditions: Initialization\n        Initial state of the subpopulations and stratifications.\n    \"\"\"\n    disease_states: list[DiseaseState]\n    stratifications: list[Stratification]\n    transitions: list[Transition]\n    initial_conditions: InitialConditions\n\n    @model_validator(mode=\"after\")\n    def validate_disease_state_initial_conditions(self) -&gt; Self:\n        \"\"\"\n        Validates initial conditions against the defined model Subpopulation.\n        \"\"\"\n        initial_conditions = self.initial_conditions\n\n        disease_states_map = {state.id: state for state in self.disease_states}\n\n        actual_state = set(initial_conditions.disease_state_fraction.keys())\n        expected_state = set(disease_states_map.keys())\n\n        if actual_state != expected_state:\n            missing = expected_state - actual_state\n            extra = actual_state - expected_state\n            raise ValueError((\n                f\"Initial disease state fractions keys must exactly match \"\n                f\"disease state ids. Missing ids: {missing}, Extra ids: {extra}.\"\n            ))\n\n        states_sum_fractions = sum(initial_conditions.disease_state_fraction.values())\n        if not math.isclose(states_sum_fractions, 1.0, abs_tol=1e-6):\n            raise ValueError((\n                f\"Disease state fractions must sum to 1.0, \"\n                f\"but got {states_sum_fractions:.7f}.\"\n            ))\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_stratification_initial_conditions(self) -&gt; Self:\n        \"\"\"\n        Validates initial conditions against the defined model Stratification.\n        \"\"\"\n        initial_conditions = self.initial_conditions\n\n        strat_map = {strat.id: strat for strat in self.stratifications}\n\n        actual_strat = set(initial_conditions.stratification_fractions.keys())\n        expected_strat = set(strat_map.keys())\n\n        if actual_strat != expected_strat:\n            missing = expected_strat - actual_strat\n            extra = actual_strat - expected_strat\n            raise ValueError((\n                f\"Initial stratification fractions keys must exactly match \"\n                f\"stratification ids. Missing ids: {missing}, Extra ids: {extra}.\"\n            ))\n\n        for (strat_id, fractions) in (\n            initial_conditions.stratification_fractions.items()\n        ):\n            strat_instance = strat_map[strat_id]\n\n            categories_expected = set(strat_instance.categories)\n            categories_actual = set(fractions.keys())\n\n            if categories_actual != categories_expected:\n                missing = categories_expected - categories_actual\n                extra = categories_actual - categories_expected\n                raise ValueError((\n                    f\"Categories for stratification '{strat_id}' must exactly match \"\n                    f\"defined categories in instance '{strat_instance.id}'. Missing \"\n                    f\"categories: {missing}, Extra categories: {extra}.\"\n                ))\n\n            strat_sum_fractions = sum(fractions.values())\n            if not math.isclose(strat_sum_fractions, 1.0, abs_tol=1e-6):\n                raise ValueError((\n                    f\"Stratification fractions for '{strat_id}' must sum to 1.0, \"\n                    f\"but got {strat_sum_fractions:.7}.\"\n                ))\n\n        return self\n</code></pre>"},{"location":"advanced/model-structure/#epimodel.context.population.Population-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#epimodel.context.population.Population.validate_disease_state_initial_conditions","title":"validate_disease_state_initial_conditions","text":"<pre><code>validate_disease_state_initial_conditions() -&gt; Self\n</code></pre> <p>Validates initial conditions against the defined model Subpopulation.</p> Source code in <code>epimodel/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_disease_state_initial_conditions(self) -&gt; Self:\n    \"\"\"\n    Validates initial conditions against the defined model Subpopulation.\n    \"\"\"\n    initial_conditions = self.initial_conditions\n\n    disease_states_map = {state.id: state for state in self.disease_states}\n\n    actual_state = set(initial_conditions.disease_state_fraction.keys())\n    expected_state = set(disease_states_map.keys())\n\n    if actual_state != expected_state:\n        missing = expected_state - actual_state\n        extra = actual_state - expected_state\n        raise ValueError((\n            f\"Initial disease state fractions keys must exactly match \"\n            f\"disease state ids. Missing ids: {missing}, Extra ids: {extra}.\"\n        ))\n\n    states_sum_fractions = sum(initial_conditions.disease_state_fraction.values())\n    if not math.isclose(states_sum_fractions, 1.0, abs_tol=1e-6):\n        raise ValueError((\n            f\"Disease state fractions must sum to 1.0, \"\n            f\"but got {states_sum_fractions:.7f}.\"\n        ))\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#epimodel.context.population.Population.validate_stratification_initial_conditions","title":"validate_stratification_initial_conditions","text":"<pre><code>validate_stratification_initial_conditions() -&gt; Self\n</code></pre> <p>Validates initial conditions against the defined model Stratification.</p> Source code in <code>epimodel/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_stratification_initial_conditions(self) -&gt; Self:\n    \"\"\"\n    Validates initial conditions against the defined model Stratification.\n    \"\"\"\n    initial_conditions = self.initial_conditions\n\n    strat_map = {strat.id: strat for strat in self.stratifications}\n\n    actual_strat = set(initial_conditions.stratification_fractions.keys())\n    expected_strat = set(strat_map.keys())\n\n    if actual_strat != expected_strat:\n        missing = expected_strat - actual_strat\n        extra = actual_strat - expected_strat\n        raise ValueError((\n            f\"Initial stratification fractions keys must exactly match \"\n            f\"stratification ids. Missing ids: {missing}, Extra ids: {extra}.\"\n        ))\n\n    for (strat_id, fractions) in (\n        initial_conditions.stratification_fractions.items()\n    ):\n        strat_instance = strat_map[strat_id]\n\n        categories_expected = set(strat_instance.categories)\n        categories_actual = set(fractions.keys())\n\n        if categories_actual != categories_expected:\n            missing = categories_expected - categories_actual\n            extra = categories_actual - categories_expected\n            raise ValueError((\n                f\"Categories for stratification '{strat_id}' must exactly match \"\n                f\"defined categories in instance '{strat_instance.id}'. Missing \"\n                f\"categories: {missing}, Extra categories: {extra}.\"\n            ))\n\n        strat_sum_fractions = sum(fractions.values())\n        if not math.isclose(strat_sum_fractions, 1.0, abs_tol=1e-6):\n            raise ValueError((\n                f\"Stratification fractions for '{strat_id}' must sum to 1.0, \"\n                f\"but got {strat_sum_fractions:.7}.\"\n            ))\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#disease-states","title":"Disease States","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#epimodel.context.disease_state.DiseaseState","title":"DiseaseState","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a single disease state of a person regarding the disease.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Identifier of the disease state.</p> <code>name</code> <code>str</code> <p>A descriptive, human-readable name for the disease state.</p> Source code in <code>epimodel/context/disease_state.py</code> <pre><code>class DiseaseState(BaseModel):\n    \"\"\"\n    Defines a single disease state of a person regarding the disease.\n\n    Attributes\n    ----------\n    id : str\n        Identifier of the disease state.\n    name : str\n        A descriptive, human-readable name for the disease state.\n    \"\"\"\n    id: str = Field(\n        ...,\n        description=\"Identifier of the disease state.\"\n    )\n    name: str = Field(\n        ...,\n        description=\"Descriptive, human-readable name for the disease state.\"\n    )\n\n    @override \n    def __hash__(self):\n            return hash(self.id)\n\n    @override \n    def __eq__(self, other: object):\n        return isinstance(other, DiseaseState) and self.id == other.id\n</code></pre>"},{"location":"advanced/model-structure/#stratifications","title":"Stratifications","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#epimodel.context.stratification.Stratification","title":"Stratification","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a categorical subdivision of the population.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Identifier of the stratification.</p> <code>categories</code> <code>list[str]</code> <p>List of the different stratification groups identifiers.</p> Source code in <code>epimodel/context/stratification.py</code> <pre><code>class Stratification(BaseModel):\n    \"\"\"\n    Defines a categorical subdivision of the population.\n\n    Attributes\n    ----------\n    id : str\n        Identifier of the stratification.\n    categories : list[str]\n        List of the different stratification groups identifiers.\n    \"\"\"\n    id: str = Field(\n        ..., \n        description=\"Identifier of the stratification.\"\n    )\n    categories: list[str] = Field(\n        ...,\n        description=\"List of the different stratification groups identifiers.\"\n    )\n\n    @override \n    def __hash__(self):\n            return hash(self.id)\n\n    @override \n    def __eq__(self, other: object):\n        return isinstance(other, Stratification) and self.id == other.id\n\n    @model_validator(mode=\"after\")\n    def validate_categories_length(self) -&gt; Self:\n        \"\"\"\n        Enforces that categories are not empty.\n        \"\"\"\n        if not self.categories:\n            raise ValueError((\n                f\"Stratification '{self.id}' must have at least one category.\"\n            ))\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_categories_uniqueness(self) -&gt; Self:\n        \"\"\"\n        Enforces that categories are not repeated.\n        \"\"\"\n        categories_set = set(self.categories)\n\n        if len(categories_set) != len(self.categories):\n            duplicates = [\n                item for item in categories_set \n                if self.categories.count(item) &gt; 1\n            ]\n            raise ValueError((\n                f\"Categories for stratification '{self.id}' must not be repeated. \"\n                f\"Found duplicates: {list(set(duplicates))}.\"\n            ))\n\n        return self\n</code></pre>"},{"location":"advanced/model-structure/#epimodel.context.stratification.Stratification-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#epimodel.context.stratification.Stratification.validate_categories_length","title":"validate_categories_length","text":"<pre><code>validate_categories_length() -&gt; Self\n</code></pre> <p>Enforces that categories are not empty.</p> Source code in <code>epimodel/context/stratification.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_categories_length(self) -&gt; Self:\n    \"\"\"\n    Enforces that categories are not empty.\n    \"\"\"\n    if not self.categories:\n        raise ValueError((\n            f\"Stratification '{self.id}' must have at least one category.\"\n        ))\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#epimodel.context.stratification.Stratification.validate_categories_uniqueness","title":"validate_categories_uniqueness","text":"<pre><code>validate_categories_uniqueness() -&gt; Self\n</code></pre> <p>Enforces that categories are not repeated.</p> Source code in <code>epimodel/context/stratification.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_categories_uniqueness(self) -&gt; Self:\n    \"\"\"\n    Enforces that categories are not repeated.\n    \"\"\"\n    categories_set = set(self.categories)\n\n    if len(categories_set) != len(self.categories):\n        duplicates = [\n            item for item in categories_set \n            if self.categories.count(item) &gt; 1\n        ]\n        raise ValueError((\n            f\"Categories for stratification '{self.id}' must not be repeated. \"\n            f\"Found duplicates: {list(set(duplicates))}.\"\n        ))\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#parameters","title":"Parameters","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#epimodel.context.parameter.Parameter","title":"Parameter","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a global model parameter.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The identifier of the parameter.</p> <code>value</code> <code>float</code> <p>Numerical value of the parameter.</p> <code>description</code> <code>str | None</code> <p>A human-readable description of the parameter.</p> Source code in <code>epimodel/context/parameter.py</code> <pre><code>class Parameter(BaseModel):\n    \"\"\"\n    Defines a global model parameter.\n\n    Attributes\n    ----------\n    id : str\n        The identifier of the parameter.\n    value : float\n        Numerical value of the parameter.\n    description : str | None\n        A human-readable description of the parameter.\n    \"\"\"\n    id: str = Field(..., description=\"Identifier of the parameter.\")\n    value: float = Field(\n        ..., \n        description=\"Numerical value of the parameter.\"\n    )\n    description: str | None = Field(\n        None, \n        description=\"Human-readable description of the parameter.\"\n    )\n</code></pre>"},{"location":"advanced/model-structure/#transitions","title":"Transitions","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#epimodel.context.transition.Transition","title":"Transition","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a rule for system evolution.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Id of the transition.</p> <code>source</code> <code>list[str]</code> <p>The origin compartments.</p> <code>target</code> <code>list[str]</code> <p>The destination compartments.</p> <code>rate</code> <code>str | None</code> <p>Mathematical formula, parameter name, or constant value for the flow between compartments. Numeric values are automatically converted to strings during validation.</p> <p>Operators: +, -, *, /, % (modulo), ^ or ** (power) Functions: sin, cos, tan, exp, ln, sqrt, abs, min, max, if, etc. Constants: pi, e</p> <p>Note: Both ^ and ** are supported for exponentiation (** is converted to ^).</p> <p>Examples: - \"beta\" (parameter reference) - \"0.5\" (constant, can also be passed as float 0.5) - \"beta * S * I / N\" (mathematical formula) - \"0.3 * sin(2 * pi * t / 365)\" (time-dependent formula) - \"2^10\" or \"2**10\" (power: both syntaxes work)</p> <code>condition</code> <code>Condition | None</code> <p>Logical restrictions for the transition.</p> Source code in <code>epimodel/context/transition.py</code> <pre><code>class Transition(BaseModel):\n    \"\"\"\n    Defines a rule for system evolution.\n\n    Attributes\n    ----------\n    id : str\n        Id of the transition.\n    source : list[str]\n        The origin compartments.\n    target : list[str]\n        The destination compartments.\n    rate : str | None\n        Mathematical formula, parameter name, or constant value for the flow between\n        compartments. Numeric values are automatically converted to strings during\n        validation.\n\n        Operators: +, -, *, /, % (modulo), ^ or ** (power)\n        Functions: sin, cos, tan, exp, ln, sqrt, abs, min, max, if, etc.\n        Constants: pi, e\n\n        Note: Both ^ and ** are supported for exponentiation (** is converted to ^).\n\n        Examples:\n        - \"beta\" (parameter reference)\n        - \"0.5\" (constant, can also be passed as float 0.5)\n        - \"beta * S * I / N\" (mathematical formula)\n        - \"0.3 * sin(2 * pi * t / 365)\" (time-dependent formula)\n        - \"2^10\" or \"2**10\" (power: both syntaxes work)\n    condition : Condition | None\n        Logical restrictions for the transition.\n    \"\"\"\n\n    id: str = Field(..., description=\"Id of the transition.\")\n    source: list[str] = Field(..., description=\"Origin compartments.\")\n    target: list[str] = Field(..., description=\"Destination compartments.\")\n\n    rate: str | None = Field(\n        None,\n        description=(\n            \"Mathematical formula, parameter name, or constant value for the flow. \"\n            \"Can be a parameter reference (e.g., 'beta'), a constant (e.g., '0.5'), \"\n            \"or a mathematical expression (e.g., 'beta * S * I / N'). \"\n            \"Numeric values are automatically converted to strings during validation.\"\n        ),\n    )\n\n    condition: Condition | None = Field(\n        None, description=\"Logical restrictions for the transition.\"\n    )\n\n    @field_validator(\"rate\", mode=\"before\")\n    @classmethod\n    def validate_rate(cls, value: str | None) -&gt; str | None:\n        \"\"\"Convert numeric rates to strings and perform security validation.\"\"\"\n        if value is None:\n            return value\n        try:\n            validate_expression_security(value)\n        except ValueError as e:\n            raise ValueError(f\"Security validation failed for rate '{value}': {e}\")\n        return value\n</code></pre>"},{"location":"advanced/model-structure/#epimodel.context.transition.Transition-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#epimodel.context.transition.Transition.validate_rate","title":"validate_rate  <code>classmethod</code>","text":"<pre><code>validate_rate(value: str | None) -&gt; str | None\n</code></pre> <p>Convert numeric rates to strings and perform security validation.</p> Source code in <code>epimodel/context/transition.py</code> <pre><code>@field_validator(\"rate\", mode=\"before\")\n@classmethod\ndef validate_rate(cls, value: str | None) -&gt; str | None:\n    \"\"\"Convert numeric rates to strings and perform security validation.\"\"\"\n    if value is None:\n        return value\n    try:\n        validate_expression_security(value)\n    except ValueError as e:\n        raise ValueError(f\"Security validation failed for rate '{value}': {e}\")\n    return value\n</code></pre>"},{"location":"advanced/model-structure/#initial-conditions","title":"Initial Conditions","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#epimodel.context.initial_conditions.InitialConditions","title":"InitialConditions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Initial conditions for a simulation.</p> <p>Attributes:</p> Name Type Description <code>population_size</code> <code>int</code> <p>Population size.</p> <code>disease_state_fraction</code> <code>DistributionFractions</code> <p>Fractions for disease states. Keys are disease state ids and values are their  initial fractional size.</p> <code>stratification_fractions</code> <code>(dict[str, DistributionFractions], optional)</code> <p>Fractions for stratifications. Keys are stratification ids. Values are  dictionaries whose keys are the stratification categories and whose values are  their initial fractional size.</p> Source code in <code>epimodel/context/initial_conditions.py</code> <pre><code>class InitialConditions(BaseModel):\n    \"\"\"\n    Initial conditions for a simulation.\n\n    Attributes\n    ----------\n    population_size : int\n        Population size.\n    disease_state_fraction : DistributionFractions\n        Fractions for disease states. Keys are disease state ids and values are their \n        initial fractional size.\n    stratification_fractions : dict[str, DistributionFractions], optional\n        Fractions for stratifications. Keys are stratification ids. Values are \n        dictionaries whose keys are the stratification categories and whose values are \n        their initial fractional size.\n    \"\"\"\n    population_size: int = Field(..., description=\"Population size.\")  \n    disease_state_fraction: DistributionFractions = Field(\n        ..., \n        description=(\n            \"Fractions for disease states. Keys are disease state ids and values are \"\n            \"their initial fractional size.\"\n        )\n    )\n    stratification_fractions: dict[str, DistributionFractions] = Field(\n        default_factory=dict, \n        description=(\n            \"Fractions for stratifications. Keys are stratification ids. Values are \"\n            \"dictionaries whose keys are the stratification categories and whose \"\n            \"values are their initial fractional size.\"\n        )\n    )\n</code></pre>"},{"location":"advanced/model-structure/#dynamics","title":"Dynamics","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#epimodel.context.dynamics.Dynamics","title":"Dynamics","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines how the system evolves.</p> <p>Attributes:</p> Name Type Description <code>typology</code> <code>Literal['DifferenceEquations']</code> <p>The type of model.</p> <code>transitions</code> <code>List[Transition]</code> <p>A list of rules for state changes.</p> Source code in <code>epimodel/context/dynamics.py</code> <pre><code>class Dynamics(BaseModel):\n    \"\"\"\n    Defines how the system evolves.\n\n    Attributes\n    ----------\n    typology : Literal[\"DifferenceEquations\"]\n        The type of model.\n    transitions : List[Transition]\n        A list of rules for state changes.\n    \"\"\"\n\n    typology: Literal[ModelTypes.DIFFERENCE_EQUATIONS]\n    transitions: list[Transition]\n</code></pre>"},{"location":"api/constants/","title":"Constants","text":""},{"location":"api/constants/#epimodel.constants","title":"constants","text":""},{"location":"api/model-builder/","title":"ModelBuilder API","text":""},{"location":"api/model-builder/#epimodel.ModelBuilder","title":"ModelBuilder","text":"<p>A programmatic interface for building epidemiological models.</p> <p>This class provides a fluent API for constructing Model instances by progressively adding disease states, stratifications, transitions, parameters, and initial conditions. It includes validation methods to ensure model consistency before building.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>class ModelBuilder:\n    \"\"\"\n    A programmatic interface for building epidemiological models.\n\n    This class provides a fluent API for constructing Model instances by progressively\n    adding disease states, stratifications, transitions, parameters, and\n    initial conditions. It includes validation methods to ensure model consistency\n    before building.\n\n    Attributes\n    ----------\n    _name : str\n        The model name.\n    _description : str | None\n        The model description.\n    _version : str | None\n        The model version.\n    _disease_states : list[DiseaseState]\n        List of disease states in the model.\n    _stratifications : list[Stratification]\n        List of population stratifications.\n    _transitions : list[Transition]\n        List of transitions between states.\n    _parameters : list[Parameter]\n        List of model parameters.\n    _initial_conditions : InitialConditions | None\n        Initial population conditions.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str | None = None,\n        version: str | None = None,\n    ):\n        \"\"\"\n        Initialize the ModelBuilder.\n\n        Parameters\n        ----------\n        name : str\n            The unique name that identifies the model.\n        description : str | None, default=None\n            A human-readable description of the model's purpose and function.\n        version : str | None, default=None\n            The version number of the model.\n        \"\"\"\n        self._name: str = name\n        self._description: str | None = description\n        self._version: str | None = version\n\n        self._disease_states: list[DiseaseState] = []\n        self._stratifications: list[Stratification] = []\n        self._transitions: list[Transition] = []\n        self._parameters: list[Parameter] = []\n        self._initial_conditions: InitialConditions | None = None\n\n        logging.info(\n            (\n                f\"Initialized ModelBuilder: name='{self._name}', \"\n                f\"version='{self._version or 'N/A'}'\"\n            )\n        )\n\n    def add_disease_state(self, id: str, name: str) -&gt; Self:\n        \"\"\"\n        Add a disease state to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the disease state.\n        name : str\n            Human-readable name for the disease state.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n\n        Raises\n        ------\n        ValueError\n            If a disease state with the same id already exists.\n        \"\"\"\n        if any(state.id == id for state in self._disease_states):\n            raise ValueError(f\"Disease state with id '{id}' already exists\")\n\n        self._disease_states.append(DiseaseState(id=id, name=name))\n        logging.info(f\"Added disease state: id='{id}', name='{name}'\")\n        return self\n\n    def add_stratification(self, id: str, categories: list[str]) -&gt; Self:\n        \"\"\"\n        Add a population stratification to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the stratification.\n        categories : list[str]\n            list of category identifiers within this stratification.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n\n        Raises\n        ------\n        ValueError\n            If a stratification with the same id already exists or if categories are\n            empty.\n        \"\"\"\n        if any(strat.id == id for strat in self._stratifications):\n            raise ValueError(f\"Stratification with id '{id}' already exists\")\n\n        if not categories:\n            raise ValueError(\"Categories cannot be empty\")\n\n        self._stratifications.append(Stratification(id=id, categories=categories))\n        logging.info(f\"Added stratification: id='{id}', categories={categories}\")\n        return self\n\n    def add_parameter(\n        self,\n        id: str,\n        value: float,\n        description: str | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Add a global parameter to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the parameter.\n        value : float\n            Numerical value of the parameter.\n        description : str | None, default=None\n            Human-readable description of the parameter.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n\n        Raises\n        ------\n        ValueError\n            If a parameter with the same id already exists.\n        \"\"\"\n        if any(param.id == id for param in self._parameters):\n            raise ValueError(f\"Parameter with id '{id}' already exists\")\n\n        self._parameters.append(Parameter(id=id, value=value, description=description))\n        logging.info(f\"Added parameter: id='{id}', value={value}\")\n        return self\n\n    def add_transition(\n        self,\n        id: str,\n        source: list[str],\n        target: list[str],\n        rate: str | float | None = None,\n        condition: Condition | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Add a transition between states to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the transition.\n        source : list[str]\n            List of source state/category identifiers.\n        target : list[str]\n            List of target state/category identifiers.\n        rate : str | float | None, default=None\n            Mathematical formula, parameter reference, or constant value for the\n            transition rate.\n            Can be:\n            - A parameter reference (e.g., \"beta\")\n            - A constant value (e.g., \"0.5\" or 0.5)\n            - A mathematical formula (e.g., \"beta * S * I / N\")\n\n            Special variables available in formulas:\n            - N: Total population (automatically calculated)\n            - step or t: Current simulation step (both are equivalent)\n            - pi, e: Mathematical constants\n\n            Examples:\n            - \"beta * S * I / N\" (frequency-dependent transmission)\n            - \"gamma\" (simple parameter reference)\n            - \"0.1 * sin(t / 365.0)\" (seasonal variation using t)\n            - \"0.1 * sin(step / 365.0)\" (seasonal variation using step)\n        condition : Condition| None, default=None\n            Logical conditions that must be met for the transition.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n\n        Raises\n        ------\n        ValueError\n            If a transition with the same id already exists or if security/syntax\n            validation fails.\n        SyntaxError\n            If the rate formula has invalid syntax.\n        \"\"\"\n        if any(trans.id == id for trans in self._transitions):\n            raise ValueError(f\"Transition with id '{id}' already exists\")\n\n        # Validate rate security and syntax if it's a string formula\n        if isinstance(rate, str) and rate.strip():\n            # Validate formula syntax using Rust MathExpression\n            try:\n                from epimodel.epimodel_rs.epimodel_rs import core\n\n                expr = core.MathExpression(rate)\n                expr.py_validate()\n\n                # Extract and validate variables used in the expression\n                variables = expr.py_get_variables()\n                self._validate_formula_variables(rate, variables)\n            except SyntaxError:\n                raise\n            except ValueError:\n                raise\n            except Exception as e:\n                error_msg = str(e).lower()\n                # Convert Rust evalexpr errors to Python exceptions\n                if any(\n                    keyword in error_msg\n                    for keyword in [\n                        \"unexpected\",\n                        \"expected\",\n                        \"syntax\",\n                        \"token\",\n                        \"incomplete\",\n                    ]\n                ):\n                    raise SyntaxError(f\"Invalid mathematical expression '{rate}': {e}\")\n                else:\n                    raise ValueError(f\"Invalid formula '{rate}': {e}\")\n        elif isinstance(rate, int) or isinstance(rate, float):\n            rate = str(rate)\n\n        self._transitions.append(\n            Transition(\n                id=id, source=source, target=target, rate=rate, condition=condition\n            )\n        )\n        logging.info(\n            (\n                f\"Added transition: id='{id}', source={source}, target={target}, \"\n                f\"rate='{rate}'\"\n            )\n        )\n        return self\n\n    def create_condition(\n        self,\n        logic: Literal[LogicOperators.AND, LogicOperators.OR],\n        rules: list[RuleDict],\n    ) -&gt; Condition:\n        \"\"\"\n        Create a condition object for use in transitions.\n\n        Parameters\n        ----------\n        logic : Literal[\"and\", \"or\"]\n            How to combine the rules.\n        rules : List[RuleDict]\n            List of rule dictionaries with 'variable', 'operator', and 'value' keys.\n            Each dictionary must have:\n            - 'variable': str (format '&lt;prefix&gt;:&lt;variable_id&gt;')\n            - 'operator': Literal[\"eq\", \"neq\", \"gt\", \"get\", \"lt\", \"let\"]\n            - 'value': str | int | float | bool\n\n        Returns\n        -------\n        Condition\n            The created condition object.\n\n        Examples\n        --------\n        &gt;&gt;&gt; condition = builder.create_condition(\n        ...     \"and\",\n        ...     [\n        ...         {\"variable\": \"states:I\", \"operator\": \"gt\", \"value\": 0},\n        ...         {\"variable\": \"strati:age\", \"operator\": \"eq\", \"value\": \"adult\"},\n        ...     ],\n        ... )\n        \"\"\"\n        rule_objects: list[Rule] = []\n        for rule_dict in rules:\n            rule_objects.append(\n                Rule(\n                    variable=rule_dict[\"variable\"],\n                    operator=rule_dict[\"operator\"],\n                    value=rule_dict[\"value\"],\n                )\n            )\n\n        return Condition(logic=logic, rules=rule_objects)\n\n    def set_initial_conditions(\n        self,\n        population_size: int,\n        disease_state_fractions: dict[str, float],\n        stratification_fractions: dict[str, dict[str, float]] | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Set the initial conditions for the model.\n\n        Parameters\n        ----------\n        population_size : int\n            Total population size.\n        disease_state_fractions : dict[str, float]\n            Fractions of population in each disease state. Keys are state ids,\n            values are fractions.\n        stratification_fractions : dict[str, dict[str, float]] | None, default=None\n            Fractions for each stratification category. Outer keys are stratification\n            ids, inner keys are category ids, values are fractions.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n\n        Raises\n        ------\n        ValueError\n            If initial conditions have already been set.\n        \"\"\"\n        if self._initial_conditions is not None:\n            raise ValueError(\"Initial conditions have already been set\")\n\n        self._initial_conditions = InitialConditions(\n            population_size=population_size,\n            disease_state_fraction=disease_state_fractions,\n            stratification_fractions=stratification_fractions or {},\n        )\n        logging.info(\n            (\n                f\"Set initial conditions: population_size={population_size}, \"\n                f\"states={list(disease_state_fractions.keys())}\"\n            )\n        )\n        return self\n\n    def _validate_formula_variables(self, formula: str, variables: list[str]) -&gt; None:\n        \"\"\"\n        Validate that all variables in a formula are defined.\n\n        Parameters\n        ----------\n        formula : str\n            The formula being validated (for error messages).\n        variables : list[str]\n            List of variable identifiers found in the formula.\n\n        Raises\n        ------\n        ValueError\n            If any variable is not defined as a parameter or disease state.\n        \"\"\"\n        # Special variables that are always available in rate formulas\n        special_vars = {\"N\", \"step\", \"pi\", \"e\", \"t\"}\n\n        param_ids = {param.id for param in self._parameters}\n        state_ids = {state.id for state in self._disease_states}\n        strat_ids: set[str] = set()\n        for strat in self._stratifications:\n            strat_ids.update(strat.categories)\n\n        valid_identifiers = param_ids | state_ids | strat_ids | special_vars\n\n        undefined_vars: list[str] = []\n        for var in variables:\n            if var not in valid_identifiers:\n                undefined_vars.append(var)\n\n        if undefined_vars:\n            raise ValueError(\n                (\n                    f\"Undefined variables in formula '{formula}': \"\n                    f\"{', '.join(undefined_vars)}. \"\n                    f\"Available parameters: \"\n                    f\"{', '.join(sorted(param_ids)) if param_ids else 'none'}. \"\n                    f\"Available disease states: \"\n                    f\"{', '.join(sorted(state_ids)) if state_ids else 'none'}.\"\n                )\n            )\n\n    def validate_completeness(self) -&gt; None:\n        \"\"\"\n        Validate that all required components have been added to the model.\n\n        Raises\n        ------\n        ValueError\n            If any required components are missing.\n        \"\"\"\n        logging.info(\"Starting model completeness validation...\")\n        if not self._disease_states:\n            raise ValueError(\"At least one disease state must be defined\")\n        if not self._transitions:\n            raise ValueError(\"At least one transition must be defined\")\n        if self._initial_conditions is None:\n            raise ValueError(\"Initial conditions must be set\")\n        logging.info(\"Model completeness validation successful.\")\n\n    def get_summary(self) -&gt; dict[str, str | int | list[str] | None]:\n        \"\"\"\n        Get a summary of the current model builder state.\n\n        Returns\n        -------\n        dict[str, dict[str, str | int | list[str] | None]]\n            Dictionary containing summary information about the model being built.\n        \"\"\"\n        return {\n            \"name\": self._name,\n            \"description\": self._description,\n            \"version\": self._version,\n            \"disease_states_count\": len(self._disease_states),\n            \"disease_state_ids\": [state.id for state in self._disease_states],\n            \"stratifications_count\": len(self._stratifications),\n            \"stratification_ids\": [strat.id for strat in self._stratifications],\n            \"transitions_count\": len(self._transitions),\n            \"transition_ids\": [trans.id for trans in self._transitions],\n            \"parameters_count\": len(self._parameters),\n            \"parameter_ids\": [param.id for param in self._parameters],\n            \"has_initial_conditions\": self._initial_conditions is not None,\n        }\n\n    def clone(self) -&gt; Self:\n        \"\"\"\n        Create a deep copy of this ModelBuilder.\n\n        Returns\n        -------\n        ModelBuilder\n            A new ModelBuilder instance with the same configuration.\n        \"\"\"\n\n        new_builder = type(self)(self._name, self._description, self._version)\n\n        new_builder._disease_states = copy.deepcopy(self._disease_states)\n        new_builder._stratifications = copy.deepcopy(self._stratifications)\n        new_builder._transitions = copy.deepcopy(self._transitions)\n        new_builder._parameters = copy.deepcopy(self._parameters)\n        new_builder._initial_conditions = copy.deepcopy(self._initial_conditions)\n\n        return new_builder\n\n    def reset(self) -&gt; Self:\n        \"\"\"\n        Reset the builder to empty state while keeping name, description, and version.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        self._disease_states.clear()\n        self._stratifications.clear()\n        self._transitions.clear()\n        self._parameters.clear()\n        self._initial_conditions = None\n        return self\n\n    def build(\n        self, typology: Literal[ModelTypes.DIFFERENCE_EQUATIONS], validate: bool = True\n    ) -&gt; Model:\n        \"\"\"\n        Build and return the final Model instance.\n\n        Parameters\n        ----------\n        typology : Literal[\"DifferenceEquations\"]\n            Type of the model.\n        validate : bool, default=True\n            Whether to perform validation before building the model.\n\n        Returns\n        -------\n        Model\n            The constructed epidemiological model.\n\n        Raises\n        ------\n        ValueError\n            If validation fails or required components are missing.\n        \"\"\"\n        if validate:\n            self.validate_completeness()\n\n        assert self._initial_conditions is not None, (\n            \"Internal error: Initial conditions should have been validated.\"\n        )\n\n        population = Population(\n            disease_states=self._disease_states,\n            stratifications=self._stratifications,\n            transitions=self._transitions,\n            initial_conditions=self._initial_conditions,\n        )\n\n        dynamics = Dynamics(typology=typology, transitions=self._transitions)\n\n        model = Model(\n            name=self._name,\n            description=self._description,\n            version=self._version,\n            population=population,\n            parameters=self._parameters,\n            dynamics=dynamics,\n        )\n\n        logging.info(\n            f\"Model '{self._name}' successfully built with typology '{typology}'.\"\n        )\n\n        return model\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder-functions","title":"Functions","text":""},{"location":"api/model-builder/#epimodel.ModelBuilder.__init__","title":"__init__","text":"<pre><code>__init__(name: str, description: str | None = None, version: str | None = None)\n</code></pre> <p>Initialize the ModelBuilder.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name that identifies the model.</p> required <code>description</code> <code>str | None</code> <p>A human-readable description of the model's purpose and function.</p> <code>None</code> <code>version</code> <code>str | None</code> <p>The version number of the model.</p> <code>None</code> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    description: str | None = None,\n    version: str | None = None,\n):\n    \"\"\"\n    Initialize the ModelBuilder.\n\n    Parameters\n    ----------\n    name : str\n        The unique name that identifies the model.\n    description : str | None, default=None\n        A human-readable description of the model's purpose and function.\n    version : str | None, default=None\n        The version number of the model.\n    \"\"\"\n    self._name: str = name\n    self._description: str | None = description\n    self._version: str | None = version\n\n    self._disease_states: list[DiseaseState] = []\n    self._stratifications: list[Stratification] = []\n    self._transitions: list[Transition] = []\n    self._parameters: list[Parameter] = []\n    self._initial_conditions: InitialConditions | None = None\n\n    logging.info(\n        (\n            f\"Initialized ModelBuilder: name='{self._name}', \"\n            f\"version='{self._version or 'N/A'}'\"\n        )\n    )\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.add_disease_state","title":"add_disease_state","text":"<pre><code>add_disease_state(id: str, name: str) -&gt; Self\n</code></pre> <p>Add a disease state to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the disease state.</p> required <code>name</code> <code>str</code> <p>Human-readable name for the disease state.</p> required <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a disease state with the same id already exists.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def add_disease_state(self, id: str, name: str) -&gt; Self:\n    \"\"\"\n    Add a disease state to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the disease state.\n    name : str\n        Human-readable name for the disease state.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n\n    Raises\n    ------\n    ValueError\n        If a disease state with the same id already exists.\n    \"\"\"\n    if any(state.id == id for state in self._disease_states):\n        raise ValueError(f\"Disease state with id '{id}' already exists\")\n\n    self._disease_states.append(DiseaseState(id=id, name=name))\n    logging.info(f\"Added disease state: id='{id}', name='{name}'\")\n    return self\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.add_stratification","title":"add_stratification","text":"<pre><code>add_stratification(id: str, categories: list[str]) -&gt; Self\n</code></pre> <p>Add a population stratification to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the stratification.</p> required <code>categories</code> <code>list[str]</code> <p>list of category identifiers within this stratification.</p> required <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a stratification with the same id already exists or if categories are empty.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def add_stratification(self, id: str, categories: list[str]) -&gt; Self:\n    \"\"\"\n    Add a population stratification to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the stratification.\n    categories : list[str]\n        list of category identifiers within this stratification.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n\n    Raises\n    ------\n    ValueError\n        If a stratification with the same id already exists or if categories are\n        empty.\n    \"\"\"\n    if any(strat.id == id for strat in self._stratifications):\n        raise ValueError(f\"Stratification with id '{id}' already exists\")\n\n    if not categories:\n        raise ValueError(\"Categories cannot be empty\")\n\n    self._stratifications.append(Stratification(id=id, categories=categories))\n    logging.info(f\"Added stratification: id='{id}', categories={categories}\")\n    return self\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.add_parameter","title":"add_parameter","text":"<pre><code>add_parameter(id: str, value: float, description: str | None = None) -&gt; Self\n</code></pre> <p>Add a global parameter to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the parameter.</p> required <code>value</code> <code>float</code> <p>Numerical value of the parameter.</p> required <code>description</code> <code>str | None</code> <p>Human-readable description of the parameter.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a parameter with the same id already exists.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def add_parameter(\n    self,\n    id: str,\n    value: float,\n    description: str | None = None,\n) -&gt; Self:\n    \"\"\"\n    Add a global parameter to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the parameter.\n    value : float\n        Numerical value of the parameter.\n    description : str | None, default=None\n        Human-readable description of the parameter.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n\n    Raises\n    ------\n    ValueError\n        If a parameter with the same id already exists.\n    \"\"\"\n    if any(param.id == id for param in self._parameters):\n        raise ValueError(f\"Parameter with id '{id}' already exists\")\n\n    self._parameters.append(Parameter(id=id, value=value, description=description))\n    logging.info(f\"Added parameter: id='{id}', value={value}\")\n    return self\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.add_transition","title":"add_transition","text":"<pre><code>add_transition(id: str, source: list[str], target: list[str], rate: str | float | None = None, condition: Condition | None = None) -&gt; Self\n</code></pre> <p>Add a transition between states to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the transition.</p> required <code>source</code> <code>list[str]</code> <p>List of source state/category identifiers.</p> required <code>target</code> <code>list[str]</code> <p>List of target state/category identifiers.</p> required <code>rate</code> <code>str | float | None</code> <p>Mathematical formula, parameter reference, or constant value for the transition rate. Can be: - A parameter reference (e.g., \"beta\") - A constant value (e.g., \"0.5\" or 0.5) - A mathematical formula (e.g., \"beta * S * I / N\")</p> <p>Special variables available in formulas: - N: Total population (automatically calculated) - step or t: Current simulation step (both are equivalent) - pi, e: Mathematical constants</p> <p>Examples: - \"beta * S * I / N\" (frequency-dependent transmission) - \"gamma\" (simple parameter reference) - \"0.1 * sin(t / 365.0)\" (seasonal variation using t) - \"0.1 * sin(step / 365.0)\" (seasonal variation using step)</p> <code>None</code> <code>condition</code> <code>Condition | None</code> <p>Logical conditions that must be met for the transition.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a transition with the same id already exists or if security/syntax validation fails.</p> <code>SyntaxError</code> <p>If the rate formula has invalid syntax.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def add_transition(\n    self,\n    id: str,\n    source: list[str],\n    target: list[str],\n    rate: str | float | None = None,\n    condition: Condition | None = None,\n) -&gt; Self:\n    \"\"\"\n    Add a transition between states to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the transition.\n    source : list[str]\n        List of source state/category identifiers.\n    target : list[str]\n        List of target state/category identifiers.\n    rate : str | float | None, default=None\n        Mathematical formula, parameter reference, or constant value for the\n        transition rate.\n        Can be:\n        - A parameter reference (e.g., \"beta\")\n        - A constant value (e.g., \"0.5\" or 0.5)\n        - A mathematical formula (e.g., \"beta * S * I / N\")\n\n        Special variables available in formulas:\n        - N: Total population (automatically calculated)\n        - step or t: Current simulation step (both are equivalent)\n        - pi, e: Mathematical constants\n\n        Examples:\n        - \"beta * S * I / N\" (frequency-dependent transmission)\n        - \"gamma\" (simple parameter reference)\n        - \"0.1 * sin(t / 365.0)\" (seasonal variation using t)\n        - \"0.1 * sin(step / 365.0)\" (seasonal variation using step)\n    condition : Condition| None, default=None\n        Logical conditions that must be met for the transition.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n\n    Raises\n    ------\n    ValueError\n        If a transition with the same id already exists or if security/syntax\n        validation fails.\n    SyntaxError\n        If the rate formula has invalid syntax.\n    \"\"\"\n    if any(trans.id == id for trans in self._transitions):\n        raise ValueError(f\"Transition with id '{id}' already exists\")\n\n    # Validate rate security and syntax if it's a string formula\n    if isinstance(rate, str) and rate.strip():\n        # Validate formula syntax using Rust MathExpression\n        try:\n            from epimodel.epimodel_rs.epimodel_rs import core\n\n            expr = core.MathExpression(rate)\n            expr.py_validate()\n\n            # Extract and validate variables used in the expression\n            variables = expr.py_get_variables()\n            self._validate_formula_variables(rate, variables)\n        except SyntaxError:\n            raise\n        except ValueError:\n            raise\n        except Exception as e:\n            error_msg = str(e).lower()\n            # Convert Rust evalexpr errors to Python exceptions\n            if any(\n                keyword in error_msg\n                for keyword in [\n                    \"unexpected\",\n                    \"expected\",\n                    \"syntax\",\n                    \"token\",\n                    \"incomplete\",\n                ]\n            ):\n                raise SyntaxError(f\"Invalid mathematical expression '{rate}': {e}\")\n            else:\n                raise ValueError(f\"Invalid formula '{rate}': {e}\")\n    elif isinstance(rate, int) or isinstance(rate, float):\n        rate = str(rate)\n\n    self._transitions.append(\n        Transition(\n            id=id, source=source, target=target, rate=rate, condition=condition\n        )\n    )\n    logging.info(\n        (\n            f\"Added transition: id='{id}', source={source}, target={target}, \"\n            f\"rate='{rate}'\"\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.create_condition","title":"create_condition","text":"<pre><code>create_condition(logic: Literal[AND, OR], rules: list[RuleDict]) -&gt; Condition\n</code></pre> <p>Create a condition object for use in transitions.</p> <p>Parameters:</p> Name Type Description Default <code>logic</code> <code>Literal['and', 'or']</code> <p>How to combine the rules.</p> required <code>rules</code> <code>List[RuleDict]</code> <p>List of rule dictionaries with 'variable', 'operator', and 'value' keys. Each dictionary must have: - 'variable': str (format ':') - 'operator': Literal[\"eq\", \"neq\", \"gt\", \"get\", \"lt\", \"let\"] - 'value': str | int | float | bool required <p>Returns:</p> Type Description <code>Condition</code> <p>The created condition object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; condition = builder.create_condition(\n...     \"and\",\n...     [\n...         {\"variable\": \"states:I\", \"operator\": \"gt\", \"value\": 0},\n...         {\"variable\": \"strati:age\", \"operator\": \"eq\", \"value\": \"adult\"},\n...     ],\n... )\n</code></pre> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def create_condition(\n    self,\n    logic: Literal[LogicOperators.AND, LogicOperators.OR],\n    rules: list[RuleDict],\n) -&gt; Condition:\n    \"\"\"\n    Create a condition object for use in transitions.\n\n    Parameters\n    ----------\n    logic : Literal[\"and\", \"or\"]\n        How to combine the rules.\n    rules : List[RuleDict]\n        List of rule dictionaries with 'variable', 'operator', and 'value' keys.\n        Each dictionary must have:\n        - 'variable': str (format '&lt;prefix&gt;:&lt;variable_id&gt;')\n        - 'operator': Literal[\"eq\", \"neq\", \"gt\", \"get\", \"lt\", \"let\"]\n        - 'value': str | int | float | bool\n\n    Returns\n    -------\n    Condition\n        The created condition object.\n\n    Examples\n    --------\n    &gt;&gt;&gt; condition = builder.create_condition(\n    ...     \"and\",\n    ...     [\n    ...         {\"variable\": \"states:I\", \"operator\": \"gt\", \"value\": 0},\n    ...         {\"variable\": \"strati:age\", \"operator\": \"eq\", \"value\": \"adult\"},\n    ...     ],\n    ... )\n    \"\"\"\n    rule_objects: list[Rule] = []\n    for rule_dict in rules:\n        rule_objects.append(\n            Rule(\n                variable=rule_dict[\"variable\"],\n                operator=rule_dict[\"operator\"],\n                value=rule_dict[\"value\"],\n            )\n        )\n\n    return Condition(logic=logic, rules=rule_objects)\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.set_initial_conditions","title":"set_initial_conditions","text":"<pre><code>set_initial_conditions(population_size: int, disease_state_fractions: dict[str, float], stratification_fractions: dict[str, dict[str, float]] | None = None) -&gt; Self\n</code></pre> <p>Set the initial conditions for the model.</p> <p>Parameters:</p> Name Type Description Default <code>population_size</code> <code>int</code> <p>Total population size.</p> required <code>disease_state_fractions</code> <code>dict[str, float]</code> <p>Fractions of population in each disease state. Keys are state ids, values are fractions.</p> required <code>stratification_fractions</code> <code>dict[str, dict[str, float]] | None</code> <p>Fractions for each stratification category. Outer keys are stratification ids, inner keys are category ids, values are fractions.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If initial conditions have already been set.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def set_initial_conditions(\n    self,\n    population_size: int,\n    disease_state_fractions: dict[str, float],\n    stratification_fractions: dict[str, dict[str, float]] | None = None,\n) -&gt; Self:\n    \"\"\"\n    Set the initial conditions for the model.\n\n    Parameters\n    ----------\n    population_size : int\n        Total population size.\n    disease_state_fractions : dict[str, float]\n        Fractions of population in each disease state. Keys are state ids,\n        values are fractions.\n    stratification_fractions : dict[str, dict[str, float]] | None, default=None\n        Fractions for each stratification category. Outer keys are stratification\n        ids, inner keys are category ids, values are fractions.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n\n    Raises\n    ------\n    ValueError\n        If initial conditions have already been set.\n    \"\"\"\n    if self._initial_conditions is not None:\n        raise ValueError(\"Initial conditions have already been set\")\n\n    self._initial_conditions = InitialConditions(\n        population_size=population_size,\n        disease_state_fraction=disease_state_fractions,\n        stratification_fractions=stratification_fractions or {},\n    )\n    logging.info(\n        (\n            f\"Set initial conditions: population_size={population_size}, \"\n            f\"states={list(disease_state_fractions.keys())}\"\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.validate_completeness","title":"validate_completeness","text":"<pre><code>validate_completeness() -&gt; None\n</code></pre> <p>Validate that all required components have been added to the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any required components are missing.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def validate_completeness(self) -&gt; None:\n    \"\"\"\n    Validate that all required components have been added to the model.\n\n    Raises\n    ------\n    ValueError\n        If any required components are missing.\n    \"\"\"\n    logging.info(\"Starting model completeness validation...\")\n    if not self._disease_states:\n        raise ValueError(\"At least one disease state must be defined\")\n    if not self._transitions:\n        raise ValueError(\"At least one transition must be defined\")\n    if self._initial_conditions is None:\n        raise ValueError(\"Initial conditions must be set\")\n    logging.info(\"Model completeness validation successful.\")\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.get_summary","title":"get_summary","text":"<pre><code>get_summary() -&gt; dict[str, str | int | list[str] | None]\n</code></pre> <p>Get a summary of the current model builder state.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, str | int | list[str] | None]]</code> <p>Dictionary containing summary information about the model being built.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def get_summary(self) -&gt; dict[str, str | int | list[str] | None]:\n    \"\"\"\n    Get a summary of the current model builder state.\n\n    Returns\n    -------\n    dict[str, dict[str, str | int | list[str] | None]]\n        Dictionary containing summary information about the model being built.\n    \"\"\"\n    return {\n        \"name\": self._name,\n        \"description\": self._description,\n        \"version\": self._version,\n        \"disease_states_count\": len(self._disease_states),\n        \"disease_state_ids\": [state.id for state in self._disease_states],\n        \"stratifications_count\": len(self._stratifications),\n        \"stratification_ids\": [strat.id for strat in self._stratifications],\n        \"transitions_count\": len(self._transitions),\n        \"transition_ids\": [trans.id for trans in self._transitions],\n        \"parameters_count\": len(self._parameters),\n        \"parameter_ids\": [param.id for param in self._parameters],\n        \"has_initial_conditions\": self._initial_conditions is not None,\n    }\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.clone","title":"clone","text":"<pre><code>clone() -&gt; Self\n</code></pre> <p>Create a deep copy of this ModelBuilder.</p> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>A new ModelBuilder instance with the same configuration.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def clone(self) -&gt; Self:\n    \"\"\"\n    Create a deep copy of this ModelBuilder.\n\n    Returns\n    -------\n    ModelBuilder\n        A new ModelBuilder instance with the same configuration.\n    \"\"\"\n\n    new_builder = type(self)(self._name, self._description, self._version)\n\n    new_builder._disease_states = copy.deepcopy(self._disease_states)\n    new_builder._stratifications = copy.deepcopy(self._stratifications)\n    new_builder._transitions = copy.deepcopy(self._transitions)\n    new_builder._parameters = copy.deepcopy(self._parameters)\n    new_builder._initial_conditions = copy.deepcopy(self._initial_conditions)\n\n    return new_builder\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.reset","title":"reset","text":"<pre><code>reset() -&gt; Self\n</code></pre> <p>Reset the builder to empty state while keeping name, description, and version.</p> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def reset(self) -&gt; Self:\n    \"\"\"\n    Reset the builder to empty state while keeping name, description, and version.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    self._disease_states.clear()\n    self._stratifications.clear()\n    self._transitions.clear()\n    self._parameters.clear()\n    self._initial_conditions = None\n    return self\n</code></pre>"},{"location":"api/model-builder/#epimodel.ModelBuilder.build","title":"build","text":"<pre><code>build(typology: Literal[DIFFERENCE_EQUATIONS], validate: bool = True) -&gt; Model\n</code></pre> <p>Build and return the final Model instance.</p> <p>Parameters:</p> Name Type Description Default <code>typology</code> <code>Literal['DifferenceEquations']</code> <p>Type of the model.</p> required <code>validate</code> <code>bool</code> <p>Whether to perform validation before building the model.</p> <code>True</code> <p>Returns:</p> Type Description <code>Model</code> <p>The constructed epidemiological model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails or required components are missing.</p> Source code in <code>epimodel/api/model_builder.py</code> <pre><code>def build(\n    self, typology: Literal[ModelTypes.DIFFERENCE_EQUATIONS], validate: bool = True\n) -&gt; Model:\n    \"\"\"\n    Build and return the final Model instance.\n\n    Parameters\n    ----------\n    typology : Literal[\"DifferenceEquations\"]\n        Type of the model.\n    validate : bool, default=True\n        Whether to perform validation before building the model.\n\n    Returns\n    -------\n    Model\n        The constructed epidemiological model.\n\n    Raises\n    ------\n    ValueError\n        If validation fails or required components are missing.\n    \"\"\"\n    if validate:\n        self.validate_completeness()\n\n    assert self._initial_conditions is not None, (\n        \"Internal error: Initial conditions should have been validated.\"\n    )\n\n    population = Population(\n        disease_states=self._disease_states,\n        stratifications=self._stratifications,\n        transitions=self._transitions,\n        initial_conditions=self._initial_conditions,\n    )\n\n    dynamics = Dynamics(typology=typology, transitions=self._transitions)\n\n    model = Model(\n        name=self._name,\n        description=self._description,\n        version=self._version,\n        population=population,\n        parameters=self._parameters,\n        dynamics=dynamics,\n    )\n\n    logging.info(\n        f\"Model '{self._name}' successfully built with typology '{typology}'.\"\n    )\n\n    return model\n</code></pre>"},{"location":"api/simulation/","title":"Simulation API","text":""},{"location":"api/simulation/#epimodel.Simulation","title":"Simulation","text":"<p>A Facade for running a simulation from a defined Model.</p> <p>This class hides the complexity of initializing the Rust engine and provides high-level methods to run simulations and retrieve results in convenient formats.</p> Source code in <code>epimodel/api/simulation.py</code> <pre><code>class Simulation:\n    \"\"\"\n    A Facade for running a simulation from a defined Model.\n\n    This class hides the complexity of initializing the Rust engine and provides\n    high-level methods to run simulations and retrieve results in convenient formats.\n    \"\"\"\n\n    def __init__(self, model: Model):\n        \"\"\"\n        Initializes the simulation engine from a Pydantic Model definition.\n\n        Parameters\n        ----------\n        model : Model\n            A fully constructed and validated model object.\n        \"\"\"\n        logging.info(f\"Initializing Simulation with model: '{model.name}'\")\n        self.model_definition: Model = model\n        self._engine: \"DifferenceEquationsProtocol\" = self._initialize_engine()\n\n        self._compartments: list[str] = self._engine.compartments\n        logging.info(\n            f\"Simulation engine ready. Total compartments: {len(self._compartments)}\"\n        )\n\n    def _initialize_engine(self) -&gt; \"DifferenceEquationsProtocol\":\n        \"\"\"Internal method to set up the Rust backend.\"\"\"\n        logging.info(\"Preparing model definition for Rust serialization...\")\n        model_json = self.model_definition.model_dump_json()\n\n        try:\n            from epimodel.epimodel_rs.epimodel_rs import core, difference\n        except ImportError as e:\n            raise ImportError(\n                \"Rust extension not available. Please compile the project.\"\n            ) from e\n\n        rust_model_instance: \"RustModelProtocol\" = core.Model.from_json(model_json)\n        logging.info(\"Rust model instance created from JSON.\")\n\n        # This could be extended if you have more engine types\n        if self.model_definition.dynamics.typology == ModelTypes.DIFFERENCE_EQUATIONS:\n            logging.info(\"Initializing DifferenceEquations engine.\")\n            return difference.DifferenceEquations(rust_model_instance)\n\n        raise NotImplementedError(\n            (\n                f\"Engine for typology '{self.model_definition.dynamics.typology}' \"\n                f\"not implemented.\"\n            )\n        )\n\n    def _run_raw(self, num_steps: int) -&gt; list[list[float]]:\n        \"\"\"\n        Runs the simulation and returns the raw, high-performance output.\n        This is the fastest method, returning a list of lists of floats.\n        \"\"\"\n        logging.info(f\"Running raw simulation for {num_steps} steps.\")\n        start = time.time()\n        results = self._engine.run(num_steps)\n        end = time.time()\n        logging.info(f\"Raw simulation complete. It tool {end - start} seconds.\")\n        return results\n\n    @overload\n    def run(\n        self, num_steps: int, output_format: Literal[\"list_of_lists\"]\n    ) -&gt; list[list[float]]: ...\n    @overload\n    def run(\n        self, num_steps: int, output_format: Literal[\"dict_of_lists\"]\n    ) -&gt; dict[str, list[float]]: ...\n    @overload\n    def run(self, num_steps: int) -&gt; dict[str, list[float]]: ...\n    def run(\n        self,\n        num_steps: int,\n        output_format: Literal[\"dict_of_lists\", \"list_of_lists\"] = \"dict_of_lists\",\n    ) -&gt; dict[str, list[float]] | list[list[float]]:\n        \"\"\"\n        Runs the simulation and returns the output in the specified format.\n\n        Parameters\n        ----------\n        num_steps : int\n            The number of steps for the simulation.\n        output_format : {'dict_of_lists', 'list_of_lists'}, default 'dict_of_lists'\n            - 'dict_of_lists': Returns a dictionary of lists, with compartment names\n                as keys.\n            - 'list_of_lists': Returns a list of lists of floats, where the first level\n                is the step and the second level the comptarment.\n\n        Returns\n        -------\n        dict[str, list[float]] | list[list[float]]\n            The simulation results in the specified format.\n        \"\"\"\n        raw_results = self._run_raw(num_steps)\n        if output_format == \"list_of_lists\":\n            logging.info(\"Returning results in 'list_of_lists' format.\")\n            return raw_results\n\n        elif output_format == \"dict_of_lists\":\n            logging.info(\"Transposing raw results to 'dict_of_lists' format.\")\n            if not raw_results:\n                return {c: [] for c in self._compartments}\n            transposed_results = zip(*raw_results)\n            return {\n                compartment: list(values)\n                for compartment, values in zip(self._compartments, transposed_results)\n            }\n\n        else:\n            assert_never(output_format)\n</code></pre>"},{"location":"api/simulation/#epimodel.Simulation-functions","title":"Functions","text":""},{"location":"api/simulation/#epimodel.Simulation.__init__","title":"__init__","text":"<pre><code>__init__(model: Model)\n</code></pre> <p>Initializes the simulation engine from a Pydantic Model definition.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>A fully constructed and validated model object.</p> required Source code in <code>epimodel/api/simulation.py</code> <pre><code>def __init__(self, model: Model):\n    \"\"\"\n    Initializes the simulation engine from a Pydantic Model definition.\n\n    Parameters\n    ----------\n    model : Model\n        A fully constructed and validated model object.\n    \"\"\"\n    logging.info(f\"Initializing Simulation with model: '{model.name}'\")\n    self.model_definition: Model = model\n    self._engine: \"DifferenceEquationsProtocol\" = self._initialize_engine()\n\n    self._compartments: list[str] = self._engine.compartments\n    logging.info(\n        f\"Simulation engine ready. Total compartments: {len(self._compartments)}\"\n    )\n</code></pre>"},{"location":"api/simulation/#epimodel.Simulation.run","title":"run","text":"<pre><code>run(num_steps: int, output_format: Literal['list_of_lists']) -&gt; list[list[float]]\n</code></pre><pre><code>run(num_steps: int, output_format: Literal['dict_of_lists']) -&gt; dict[str, list[float]]\n</code></pre><pre><code>run(num_steps: int) -&gt; dict[str, list[float]]\n</code></pre> <pre><code>run(num_steps: int, output_format: Literal['dict_of_lists', 'list_of_lists'] = 'dict_of_lists') -&gt; dict[str, list[float]] | list[list[float]]\n</code></pre> <p>Runs the simulation and returns the output in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>The number of steps for the simulation.</p> required <code>output_format</code> <code>(dict_of_lists, list_of_lists)</code> <ul> <li>'dict_of_lists': Returns a dictionary of lists, with compartment names     as keys.</li> <li>'list_of_lists': Returns a list of lists of floats, where the first level     is the step and the second level the comptarment.</li> </ul> <code>'dict_of_lists'</code> <p>Returns:</p> Type Description <code>dict[str, list[float]] | list[list[float]]</code> <p>The simulation results in the specified format.</p> Source code in <code>epimodel/api/simulation.py</code> <pre><code>def run(\n    self,\n    num_steps: int,\n    output_format: Literal[\"dict_of_lists\", \"list_of_lists\"] = \"dict_of_lists\",\n) -&gt; dict[str, list[float]] | list[list[float]]:\n    \"\"\"\n    Runs the simulation and returns the output in the specified format.\n\n    Parameters\n    ----------\n    num_steps : int\n        The number of steps for the simulation.\n    output_format : {'dict_of_lists', 'list_of_lists'}, default 'dict_of_lists'\n        - 'dict_of_lists': Returns a dictionary of lists, with compartment names\n            as keys.\n        - 'list_of_lists': Returns a list of lists of floats, where the first level\n            is the step and the second level the comptarment.\n\n    Returns\n    -------\n    dict[str, list[float]] | list[list[float]]\n        The simulation results in the specified format.\n    \"\"\"\n    raw_results = self._run_raw(num_steps)\n    if output_format == \"list_of_lists\":\n        logging.info(\"Returning results in 'list_of_lists' format.\")\n        return raw_results\n\n    elif output_format == \"dict_of_lists\":\n        logging.info(\"Transposing raw results to 'dict_of_lists' format.\")\n        if not raw_results:\n            return {c: [] for c in self._compartments}\n        transposed_results = zip(*raw_results)\n        return {\n            compartment: list(values)\n            for compartment, values in zip(self._compartments, transposed_results)\n        }\n\n    else:\n        assert_never(output_format)\n</code></pre>"},{"location":"development/contributing/","title":"Contributing Guidelines","text":"<p>Thank you for considering contributing to EpiModel! This document provides guidelines for contributing to the project.</p>"},{"location":"development/contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"development/contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>Before creating a bug report:</p> <ul> <li>Check the issue tracker for existing reports</li> <li>Verify the bug exists in the latest version</li> </ul> <p>When creating a bug report, include:</p> <ul> <li>Clear title and description</li> <li>Steps to reproduce the issue</li> <li>Expected vs actual behavior</li> <li>Environment details (OS, Python version, EpiModel version)</li> <li>Code samples or test cases that demonstrate the problem</li> </ul>"},{"location":"development/contributing/#suggesting-features","title":"Suggesting Features","text":"<p>Feature suggestions are welcome! Please:</p> <ul> <li>Check if the feature has already been requested</li> <li>Provide a clear use case and rationale</li> <li>Describe the desired API or interface</li> <li>Consider implementation complexity vs benefit</li> </ul>"},{"location":"development/contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Keep PRs focused: One feature/fix per PR</li> <li>Write tests: All new code should have tests</li> <li>Update docs: Update README or documentation as needed</li> <li>Follow conventions: Use the project's code style</li> <li>Be descriptive: Write clear commit messages and PR descriptions</li> </ol>"},{"location":"development/contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"development/contributing/#code-style","title":"Code Style","text":""},{"location":"development/contributing/#python","title":"Python","text":"<ul> <li>Follow PEP 8</li> <li>Use type hints for all functions</li> <li>Maximum line length: 88 characters</li> <li>Use Ruff for linting and formatting</li> </ul> <pre><code>cd py-epimodel\npoetry run ruff check .\npoetry run ruff format .\npoetry run mypy epimodel\n</code></pre>"},{"location":"development/contributing/#rust","title":"Rust","text":"<ul> <li>Follow Rust API Guidelines</li> <li>Use <code>cargo fmt</code> for formatting</li> <li>Use <code>cargo clippy</code> for linting</li> <li>Document public APIs with rustdoc</li> </ul> <pre><code>cargo fmt --all\ncargo clippy --all-targets --all-features\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#python-tests","title":"Python Tests","text":"<ul> <li>Write tests using pytest</li> <li>Aim for &gt;95% code coverage</li> <li>Test both success and error cases</li> <li>Use descriptive test names</li> </ul> <pre><code>def test_model_builder_creates_valid_sir_model():\n    \"\"\"Test that ModelBuilder creates a valid SIR model.\"\"\"\n    model = (\n        ModelBuilder(name=\"Test SIR\")\n        .add_disease_state(id=\"S\", name=\"Susceptible\")\n        # ... rest of model\n        .build(ModelTypes.DIFFERENCE_EQUATIONS)\n    )\n    assert model.name == \"Test SIR\"\n</code></pre> <p>Run tests:</p> <pre><code>cd py-epimodel\npoetry run pytest -v --cov=epimodel\n</code></pre>"},{"location":"development/contributing/#rust-tests","title":"Rust Tests","text":"<ul> <li>Write unit tests in the same file</li> <li>Write integration tests in <code>tests/</code> directory</li> <li>Use <code>#[should_panic]</code> for error cases</li> </ul> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_model_creation() {\n        // Test implementation\n    }\n}\n</code></pre> <p>Run tests:</p> <pre><code>cargo test --workspace\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":""},{"location":"development/contributing/#python-docstrings","title":"Python Docstrings","text":"<p>Use NumPy-style docstrings:</p> <pre><code>def run(self, num_steps: int, output_format: str = \"dict_of_lists\") -&gt; dict:\n    \"\"\"\n    Runs the simulation and returns results.\n\n    Parameters\n    ----------\n    num_steps : int\n        Number of simulation steps to run.\n    output_format : str, default 'dict_of_lists'\n        Format for results ('dict_of_lists' or 'list_of_lists').\n\n    Returns\n    -------\n    dict\n        Simulation results in the specified format.\n\n    Raises\n    ------\n    ValueError\n        If num_steps is negative.\n\n    Examples\n    --------\n    &gt;&gt;&gt; sim = Simulation(model)\n    &gt;&gt;&gt; results = sim.run(num_steps=100)\n    \"\"\"\n</code></pre>"},{"location":"development/contributing/#rust-documentation","title":"Rust Documentation","text":"<p>Use rustdoc:</p> <pre><code>/// Runs the simulation for a given number of steps.\n///\n/// # Arguments\n///\n/// * `num_steps` - The number of time steps to simulate\n///\n/// # Returns\n///\n/// A vector of state vectors, one per time step\n///\n/// # Examples\n///\n/// ```\n/// let results = engine.run(100);\n/// assert_eq!(results.len(), 100);\n/// ```\npub fn run(&amp;self, num_steps: usize) -&gt; Vec&lt;Vec&lt;f64&gt;&gt; {\n    // Implementation\n}\n</code></pre>"},{"location":"development/contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow Conventional Commits:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Code style (formatting, missing semicolons, etc.)</li> <li><code>refactor</code>: Code refactoring</li> <li><code>perf</code>: Performance improvements</li> <li><code>test</code>: Adding or updating tests</li> <li><code>build</code>: Build system or dependencies</li> <li><code>ci</code>: CI/CD changes</li> <li><code>chore</code>: Other changes (releasing, etc.)</li> </ul> <p>Examples:</p> <pre><code>feat(transitions): add support for time-dependent rates\n\nImplemented mathematical expression parsing for dynamic\ntransition rates that change over time.\n\nCloses #123\n</code></pre> <pre><code>fix(simulation): prevent negative population values\n\nAdded validation to ensure compartment populations\nremain non-negative during simulation.\n</code></pre>"},{"location":"development/contributing/#code-review-process","title":"Code Review Process","text":""},{"location":"development/contributing/#for-contributors","title":"For Contributors","text":"<ol> <li>Respond to feedback promptly and professionally</li> <li>Make requested changes or discuss alternatives</li> <li>Keep the PR updated with the target branch</li> <li>Test locally before requesting re-review</li> </ol>"},{"location":"development/contributing/#for-reviewers","title":"For Reviewers","text":"<ol> <li>Be constructive and respectful</li> <li>Explain reasoning for requested changes</li> <li>Acknowledge good work when you see it</li> <li>Test the changes when possible</li> </ol>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<p>See Release Process for details on versioning and releases.</p>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check the docs</li> <li>Discussions: Use GitHub Discussions</li> <li>Issues: Report bugs via GitHub Issues</li> </ul>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors will be recognized in:</p> <ul> <li>The project's AUTHORS file</li> <li>Release notes for significant contributions</li> <li>GitHub's contributor graph</li> </ul> <p>Thank you for contributing to EpiModel! \ud83c\udf89</p>"},{"location":"development/release/","title":"Release Process","text":"<p>EpiModel follows Semantic Versioning (SemVer) for version numbering: <code>MAJOR.MINOR.PATCH</code></p>"},{"location":"development/release/#version-guidelines","title":"Version Guidelines","text":""},{"location":"development/release/#major-version-x00","title":"MAJOR version (X.0.0)","text":"<p>Incremented for incompatible API changes: - Breaking changes to public API - Removal of deprecated features - Major architectural changes affecting backwards compatibility - Example: Changing method signatures, removing public methods</p>"},{"location":"development/release/#minor-version-0x0","title":"MINOR version (0.X.0)","text":"<p>Incremented for backwards-compatible new features: - New functionality added - New disease states, stratifications, or transition types - Performance improvements without API changes - Deprecation notices (without removal) - Example: Adding new mathematical functions, new model types</p>"},{"location":"development/release/#patch-version-00x","title":"PATCH version (0.0.X)","text":"<p>Incremented for backwards-compatible bug fixes: - Bug fixes that don't change the API - Documentation improvements - Internal refactoring - Security patches - Example: Fixing calculation errors, typos in error messages</p>"},{"location":"development/release/#release-workflow","title":"Release Workflow","text":""},{"location":"development/release/#step-1-prepare-the-release","title":"Step 1: Prepare the Release","text":""},{"location":"development/release/#11-update-version-numbers","title":"1.1 Update Version Numbers","text":"<p>Edit the following files: - <code>py-epimodel/pyproject.toml</code> - Update <code>version</code> field - <code>Cargo.toml</code> - Update <code>[workspace.package]</code> version</p> <pre><code># py-epimodel/pyproject.toml\n[tool.poetry]\nversion = \"1.2.3\"\n\n# Cargo.toml\n[workspace.package]\nversion = \"1.2.3\"\n</code></pre>"},{"location":"development/release/#12-update-changelog-if-maintained","title":"1.2 Update CHANGELOG (if maintained)","text":"<p>Document all changes under the new version:</p> <pre><code>## [1.2.3] - 2024-12-15\n\n### Added\n- New mathematical functions for transition rates\n- Support for multi-compartment transitions\n\n### Changed\n- Improved simulation performance by 20%\n\n### Fixed\n- Fixed population conservation bug in stratified models\n- Corrected type hints in Simulation class\n\n### Security\n- Updated dependencies to patch vulnerabilities\n</code></pre>"},{"location":"development/release/#13-run-quality-checks","title":"1.3 Run Quality Checks","text":"<pre><code># Python checks\ncd py-epimodel\npoetry run ruff check .\npoetry run ruff format .\npoetry run mypy epimodel\npoetry run pytest\n\n# Rust checks\ncd ..\ncargo fmt --all\ncargo clippy --all-targets --all-features\ncargo test --workspace\n</code></pre>"},{"location":"development/release/#14-commit-version-changes","title":"1.4 Commit Version Changes","text":"<pre><code>git add py-epimodel/pyproject.toml Cargo.toml CHANGELOG.md\ngit commit -m \"chore: bump version to X.Y.Z\"\ngit push origin main\n</code></pre>"},{"location":"development/release/#step-2-create-github-release","title":"Step 2: Create GitHub Release","text":""},{"location":"development/release/#21-create-tag","title":"2.1 Create Tag","text":"<pre><code>git tag -a vX.Y.Z -m \"Release version X.Y.Z\"\ngit push origin vX.Y.Z\n</code></pre>"},{"location":"development/release/#22-create-github-release","title":"2.2 Create GitHub Release","text":"<ol> <li>Go to Releases page</li> <li>Click \"Draft a new release\"</li> <li>Select tag: <code>vX.Y.Z</code></li> <li>Set release title: <code>Version X.Y.Z</code></li> <li>Add release notes:</li> </ol> <pre><code>## What's New in X.Y.Z\n\n### New Features\n- Feature 1 description\n- Feature 2 description\n\n###  Bug Fixes\n- Fix 1 description\n- Fix 2 description\n\n### Documentation\n- Documentation improvements\n\n### Performance\n- Performance improvements\n\n## Breaking Changes (for major versions)\n- List breaking changes\n- Migration guide\n\n## Installation\n\npip install epimodel==X.Y.Z\n\n## Full Changelog\nSee [CHANGELOG.md](https://github.com/MUNQU/epimodel/blob/main/CHANGELOG.md)\n</code></pre> <ol> <li>Click \"Publish release\"</li> </ol>"},{"location":"development/release/#step-3-automated-pypi-publication","title":"Step 3: Automated PyPI Publication","text":"<p>Once the release is published, the GitHub Actions workflow automatically:</p> <ol> <li>Builds wheels for Linux, Windows, and macOS</li> <li>Creates source distribution (sdist)</li> <li>Publishes to PyPI using trusted publishing</li> </ol> <p>Monitor progress: - Go to Actions tab - Watch the \"Release to PyPI\" workflow</p>"},{"location":"development/release/#step-4-verify-the-release","title":"Step 4: Verify the Release","text":""},{"location":"development/release/#41-check-pypi","title":"4.1 Check PyPI","text":"<p>Verify the package appears at: https://pypi.org/project/epimodel/</p>"},{"location":"development/release/#42-test-installation","title":"4.2 Test Installation","text":"<pre><code># Create fresh virtual environment\npython -m venv test_env\nsource test_env/bin/activate  # or test_env\\Scripts\\activate on Windows\n\n# Install the new version\npip install epimodel==X.Y.Z\n\n# Verify it works\npython -c \"from epimodel import ModelBuilder; print('Success!')\"\n</code></pre>"},{"location":"development/release/#43-test-functionality","title":"4.3 Test Functionality","text":"<pre><code>from epimodel import ModelBuilder, Simulation\nfrom epimodel.constants import ModelTypes\n\n# Run a quick test\nmodel = (\n    ModelBuilder(name=\"Test\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"N\", value=1000.0)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsim = Simulation(model)\nresults = sim.run(num_steps=100)\nprint(f\"Final infected: {results['I'][-1]:.0f}\")\n</code></pre>"},{"location":"development/release/#step-5-sync-branches","title":"Step 5: Sync Branches","text":"<pre><code># Merge main back to develop\ngit checkout develop\ngit merge main\ngit push origin develop\n</code></pre>"},{"location":"development/release/#pre-release-versions","title":"Pre-release Versions","text":"<p>For testing before official release:</p>"},{"location":"development/release/#alpha-releases","title":"Alpha Releases","text":"<pre><code># Version: X.Y.Z-alpha.N\ngit tag -a v1.3.0-alpha.1 -m \"Alpha release for testing\"\ngit push origin v1.3.0-alpha.1\n</code></pre>"},{"location":"development/release/#beta-releases","title":"Beta Releases","text":"<pre><code># Version: X.Y.Z-beta.N\ngit tag -a v1.3.0-beta.1 -m \"Beta release for testing\"\ngit push origin v1.3.0-beta.1\n</code></pre>"},{"location":"development/release/#release-candidates","title":"Release Candidates","text":"<pre><code># Version: X.Y.Z-rc.N\ngit tag -a v1.3.0-rc.1 -m \"Release candidate\"\ngit push origin v1.3.0-rc.1\n</code></pre> <p>Important: Mark GitHub releases as \"pre-release\" to prevent automatic PyPI publication.</p>"},{"location":"development/release/#version-support-policy","title":"Version Support Policy","text":"<ul> <li>Latest version: Fully supported with new features and bug fixes</li> <li>Older versions: No support, users encouraged to upgrade</li> </ul>"},{"location":"development/release/#pypi-trusted-publishing-setup","title":"PyPI Trusted Publishing Setup","text":"<p>To enable automated PyPI publishing, configure trusted publishing:</p> <ol> <li>Go to PyPI and log in</li> <li>Go to your project settings</li> <li>Navigate to \"Publishing\" section</li> <li>Add GitHub as a trusted publisher:</li> <li>Owner: MUNQU</li> <li>Repository: epimodel</li> <li>Workflow: release.yml</li> <li>Environment: pypi</li> </ol> <p>This allows GitHub Actions to publish without API tokens.</p>"},{"location":"development/release/#release-checklist","title":"Release Checklist","text":"<ul> <li>[ ] Version updated in <code>pyproject.toml</code></li> <li>[ ] Version updated in <code>Cargo.toml</code></li> <li>[ ] CHANGELOG updated with all changes</li> <li>[ ] All tests passing locally</li> <li>[ ] Version committed and pushed to main</li> <li>[ ] Git tag created and pushed</li> <li>[ ] GitHub release created with notes</li> <li>[ ] CI/CD pipeline completed successfully</li> <li>[ ] Package verified on PyPI</li> <li>[ ] Installation tested in clean environment</li> <li>[ ] Main merged back to develop</li> <li>[ ] Release announced (if applicable)</li> </ul>"},{"location":"development/release/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/release/#pypi-upload-fails","title":"PyPI Upload Fails","text":"<ol> <li>Check GitHub Actions logs</li> <li>Verify trusted publishing is configured</li> <li>Ensure version number is unique (not already on PyPI)</li> <li>Check for artifact build errors</li> </ol>"},{"location":"development/release/#wheel-build-fails","title":"Wheel Build Fails","text":"<ol> <li>Check that Rust code compiles on all platforms</li> <li>Verify maturin configuration is correct</li> <li>Check for platform-specific dependencies</li> </ol>"},{"location":"development/release/#version-conflicts","title":"Version Conflicts","text":"<ol> <li>Ensure version is updated in all required files</li> <li>Use <code>git tag -d vX.Y.Z</code> to delete incorrect tags locally</li> <li>Use <code>git push origin :refs/tags/vX.Y.Z</code> to delete remote tags</li> </ol>"},{"location":"development/workflow/","title":"Development Workflow","text":""},{"location":"development/workflow/#development-setup","title":"Development Setup","text":"<p>EpiModel is built with Rust and Python. To set up your development environment:</p>"},{"location":"development/workflow/#1-install-prerequisites","title":"1. Install Prerequisites","text":"<pre><code># Install Rust toolchain\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Install Python 3.11 or higher\n# (use your system's package manager)\n\n# Install Poetry\ncurl -sSL https://install.python-poetry.org | python3 -\n</code></pre>"},{"location":"development/workflow/#2-clone-and-setup","title":"2. Clone and Setup","text":"<pre><code>git clone https://github.com/MUNQU/epimodel.git\ncd epimodel\n\n# Install Python dependencies\ncd py-epimodel\npoetry install --with dev\n\n# Install pre-commit hooks (optional but recommended)\npoetry run pre-commit install\n</code></pre>"},{"location":"development/workflow/#3-build-the-project","title":"3. Build the Project","text":"<pre><code># Build Rust workspace\ncargo build --workspace\n\n# Build Python extension\ncd py-epimodel\nmaturin develop --release\n</code></pre>"},{"location":"development/workflow/#branching-strategy","title":"Branching Strategy","text":"<p>We use a simplified Git Flow approach:</p> <ul> <li><code>main</code>: Production-ready code. Protected branch.</li> <li><code>develop</code>: Integration branch for features. Used for staging releases.</li> <li><code>feature/*</code>: New features, refactoring, or significant changes (e.g., <code>feature/add-stochastic-model</code>)</li> <li><code>fix/*</code>: Bug fixes (e.g., <code>fix/calculation-error</code>)</li> <li><code>docs/*</code>: Documentation-only changes (e.g., <code>docs/update-api-reference</code>)</li> <li><code>test/*</code>: Test additions or improvements (e.g., <code>test/add-sir-model-tests</code>)</li> <li><code>chore/*</code>: Maintenance tasks, dependencies (e.g., <code>chore/update-dependencies</code>)</li> </ul>"},{"location":"development/workflow/#development-process","title":"Development Process","text":""},{"location":"development/workflow/#1-starting-new-work","title":"1. Starting New Work","text":"<pre><code># Always start from the latest develop branch\ngit checkout develop\ngit pull origin develop\n\n# Create a feature branch\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/workflow/#2-making-changes","title":"2. Making Changes","text":"<pre><code># Make your changes to the code\n\n# Run quality checks before committing\ncd py-epimodel\npoetry run ruff check . --fix         # Auto-fix Python linting issues\npoetry run ruff format .              # Format Python code\npoetry run mypy epimodel              # Type checking\n\ncd ..\ncargo fmt --all                       # Format Rust code\ncargo clippy --all-targets --fix      # Fix Rust linting issues\n</code></pre>"},{"location":"development/workflow/#3-testing-your-changes","title":"3. Testing Your Changes","text":"<pre><code># Run Python tests\ncd py-epimodel\npoetry run pytest -v\n\n# Run Rust tests\ncd ..\ncargo test --workspace\n</code></pre>"},{"location":"development/workflow/#4-committing-changes","title":"4. Committing Changes","text":"<p>We follow Conventional Commits for commit messages:</p> <pre><code># Commit format: &lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\ngit add .\ngit commit -m \"feat(transitions): add support for time-varying rates\"\ngit commit -m \"fix(simulation): correct population calculation\"\ngit commit -m \"docs(readme): update installation instructions\"\ngit commit -m \"test(models): add tests for stratified models\"\n</code></pre> <p>Commit Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation only</li> <li><code>style</code>: Code style changes (formatting)</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Adding or updating tests</li> <li><code>chore</code>: Maintenance tasks, dependencies</li> <li><code>perf</code>: Performance improvements</li> <li><code>ci</code>: CI/CD changes</li> <li><code>build</code>: Build system changes</li> </ul> <p>Branch vs Commit Type:</p> <p>The branch name indicates the primary purpose of the work, while commit types describe individual changes:</p> <ul> <li>A <code>feature/refactor-api</code> branch may have <code>refactor</code>, <code>test</code>, and <code>docs</code> commits</li> <li>A <code>test/*</code> branch primarily adds tests but may have <code>fix</code> commits too</li> <li>A <code>docs/*</code> branch is documentation-only, so all commits should use <code>docs</code> type</li> </ul>"},{"location":"development/workflow/#5-pushing-and-creating-pull-requests","title":"5. Pushing and Creating Pull Requests","text":"<pre><code># Push your branch\ngit push origin feature/your-feature-name\n\n# Create a Pull Request on GitHub\n# - Target the 'develop' branch\n# - Fill in the PR template with:\n#   - Description of changes\n#   - Related issues\n#   - Testing performed\n#   - Screenshots (if UI changes)\n</code></pre>"},{"location":"development/workflow/#6-code-review-and-ci","title":"6. Code Review and CI","text":"<p>When you create a PR, automated checks run:</p> <ul> <li>Code Quality Pipeline: Linting, formatting, type checking for both Python and Rust</li> <li>Build Pipeline: Builds on Ubuntu, Windows, and macOS with Python versions</li> <li>Test Coverage: Runs all tests and reports coverage</li> </ul> <p>PR Requirements:</p> <ul> <li>All CI checks must pass</li> <li>At least one approving review</li> <li>No merge conflicts with target branch</li> <li>Code coverage should be &gt;95%</li> </ul>"},{"location":"development/workflow/#7-merging-to-develop","title":"7. Merging to Develop","text":"<p>Once approved:</p> <pre><code># Merge using \"Squash and merge\" or \"Rebase and merge\" on GitHub\n# Delete the feature branch after merging\n</code></pre>"},{"location":"development/workflow/#continuous-integration-pipelines","title":"Continuous Integration Pipelines","text":"<p>The project uses three main CI/CD pipelines:</p>"},{"location":"development/workflow/#1-code-quality-on-every-pushpr","title":"1. Code Quality (on every push/PR)","text":"<ul> <li>Python: Ruff (linting/formatting), MyPy (type checking), Pytest (testing)</li> <li>Rust: rustfmt (formatting), Clippy (linting), cargo test</li> <li>Runs on: Ubuntu</li> <li>Purpose: Ensure code quality standards</li> </ul>"},{"location":"development/workflow/#2-build-on-every-pushpr","title":"2. Build (on every push/PR)","text":"<ul> <li>Builds on: Ubuntu, Windows, macOS</li> <li>Python versions: 3.11, 3.12</li> <li>Tests: Full test suite on all platforms</li> <li>Artifacts: Wheel files for each platform</li> <li>Purpose: Ensure cross-platform compatibility</li> </ul>"},{"location":"development/workflow/#3-release-on-github-release","title":"3. Release (on GitHub release)","text":"<ul> <li>Builds wheels for all platforms</li> <li>Creates source distribution</li> <li>Publishes to PyPI using trusted publishing</li> <li>Purpose: Automated deployment</li> </ul>"},{"location":"development/workflow/#local-development-tips","title":"Local Development Tips","text":""},{"location":"development/workflow/#quick-commands","title":"Quick Commands","text":"<pre><code># Run all quality checks (Python)\ncd py-epimodel &amp;&amp; poetry run ruff check . &amp;&amp; poetry run ruff format . &amp;&amp; poetry run mypy epimodel &amp;&amp; poetry run pytest\n\n# Run all quality checks (Rust)\ncargo fmt --all &amp;&amp; cargo clippy --all-targets &amp;&amp; cargo test --workspace\n\n# Build and test the Python package locally\ncd py-epimodel\nmaturin develop --release\npoetry run pytest\n</code></pre>"},{"location":"development/workflow/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Install pre-commit hooks to automatically check code before committing:</p> <pre><code>cd py-epimodel\npoetry run pre-commit install\n</code></pre> <p>This runs:</p> <ul> <li>Ruff linting and formatting</li> <li>MyPy type checking</li> <li>Trailing whitespace removal</li> <li>End-of-file fixing</li> <li>Poetry lock file validation</li> <li>Ensures <code>poetry.lock</code> stays in sync with <code>pyproject.toml</code></li> </ul>"},{"location":"development/workflow/#keeping-poetrylock-in-sync","title":"Keeping poetry.lock in Sync","text":"<p>Important: Always ensure <code>poetry.lock</code> is synchronized with <code>pyproject.toml</code> before committing.</p>"},{"location":"development/workflow/#automatic-recommended","title":"Automatic (Recommended)","text":"<p>Pre-commit hooks handle this automatically: <pre><code>cd py-epimodel\npoetry run pre-commit install  # One-time setup\n\n# Now git commit automatically updates poetry.lock if needed\ngit add pyproject.toml\ngit commit -m \"chore: update dependencies\"\n</code></pre></p>"},{"location":"development/workflow/#manual","title":"Manual","text":"<p>If not using pre-commit hooks: <pre><code>cd py-epimodel\npoetry check  # Check if lock file is in sync\npoetry lock   # Update lock file without changing versions\ngit add poetry.lock\ngit commit -m \"chore: update poetry.lock\"\n</code></pre></p> <p>Why this matters: Out-of-sync lock files cause CI/CD pipeline failures. The pre-commit hook prevents this automatically.</p>"},{"location":"development/workflow/#debugging-rust-from-python","title":"Debugging Rust from Python","text":"<pre><code># Build with debug symbols\nmaturin develop\n\n# Run Python\ncd py-epimodel\npoetry run python -m your_test_script.py\n</code></pre>"},{"location":"development/workflow/#building-documentation","title":"Building Documentation","text":"<p>The project uses MkDocs Material for documentation:</p> <pre><code># Install documentation dependencies\ncd py-epimodel\npoetry install --with docs\n\n# Serve documentation locally\npoetry run mkdocs serve\n\n# Build documentation\npoetry run mkdocs build\n</code></pre> <p>Visit http://127.0.0.1:8000 to view the documentation locally.</p>"},{"location":"development/workflow/#next-steps","title":"Next Steps","text":"<ul> <li>Contributing Guidelines - Best practices for contributions</li> <li>Release Process - How releases are managed</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>Rust toolchain (for building from source)</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>Once published, you can install EpiModel directly from PyPI:</p> <pre><code>pip install epimodel\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>To install the latest development version:</p>"},{"location":"getting-started/installation/#1-install-prerequisites","title":"1. Install Prerequisites","text":""},{"location":"getting-started/installation/#install-rust","title":"Install Rust","text":"<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre>"},{"location":"getting-started/installation/#install-poetry-optional-for-development","title":"Install Poetry (optional, for development)","text":"<pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre>"},{"location":"getting-started/installation/#2-clone-the-repository","title":"2. Clone the Repository","text":"<pre><code>git clone https://github.com/MUNQU/epimodel.git\ncd epimodel\n</code></pre>"},{"location":"getting-started/installation/#3-install-with-pip","title":"3. Install with pip","text":"<pre><code>pip install maturin\ncd py-epimodel\nmaturin develop --release\n</code></pre>"},{"location":"getting-started/installation/#4-install-with-poetry-for-development","title":"4. Install with Poetry (for development)","text":"<pre><code>cd py-epimodel\npoetry install\nmaturin develop --release\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test that EpiModel is correctly installed:</p> <pre><code>from epimodel import ModelBuilder\nfrom epimodel.constants import ModelTypes\n\nprint(\"EpiModel installed successfully!\")\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first model</li> <li>Core Concepts - Understand EpiModel fundamentals</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will help you build and run your first epidemiological model with EpiModel.</p>"},{"location":"getting-started/quickstart/#your-first-sir-model","title":"Your First SIR Model","text":"<p>Let's create a basic SIR (Susceptible-Infected-Recovered) model:</p> <pre><code>from epimodel import ModelBuilder, Simulation\nfrom epimodel.constants import ModelTypes\n\n# Build the model\nmodel = (\n    ModelBuilder(name=\"Basic SIR\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)   # Transmission rate\n    .add_parameter(id=\"gamma\", value=0.1)  # Recovery rate\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"  # Mathematical formula\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run simulation\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n\n# Display results\nprint(f\"Susceptible at day 100: {results['S'][-1]:.0f}\")\nprint(f\"Infected at day 100: {results['I'][-1]:.0f}\")\nprint(f\"Recovered at day 100: {results['R'][-1]:.0f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"getting-started/quickstart/#1-import-required-classes","title":"1. Import Required Classes","text":"<pre><code>from epimodel import ModelBuilder, Simulation\nfrom epimodel.constants import ModelTypes\n</code></pre> <ul> <li><code>ModelBuilder</code>: Fluent API for constructing models</li> <li><code>Simulation</code>: Runs the model simulation</li> <li><code>ModelTypes</code>: Enumeration of available model types</li> </ul>"},{"location":"getting-started/quickstart/#2-define-disease-states","title":"2. Define Disease States","text":"<pre><code>.add_disease_state(id=\"S\", name=\"Susceptible\")\n.add_disease_state(id=\"I\", name=\"Infected\")\n.add_disease_state(id=\"R\", name=\"Recovered\")\n</code></pre> <p>Disease states represent compartments in your model.</p>"},{"location":"getting-started/quickstart/#3-add-parameters","title":"3. Add Parameters","text":"<pre><code>.add_parameter(id=\"beta\", value=0.3)   # Transmission rate\n.add_parameter(id=\"gamma\", value=0.1)  # Recovery rate\n</code></pre> <p>Parameters are constants used in transition rate formulas.</p>"},{"location":"getting-started/quickstart/#4-define-transitions","title":"4. Define Transitions","text":"<pre><code>.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"\n)\n</code></pre> <p>Transitions move populations between states using mathematical formulas.</p>"},{"location":"getting-started/quickstart/#5-set-initial-conditions","title":"5. Set Initial Conditions","text":"<pre><code>.set_initial_conditions(\n    population_size=1000,\n    disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n)\n</code></pre> <p>Define the starting population distribution.</p>"},{"location":"getting-started/quickstart/#6-build-and-run","title":"6. Build and Run","text":"<pre><code>model = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've built your first model, explore:</p> <ul> <li>Core Concepts - Deep dive into EpiModel concepts</li> <li>Building Models - Advanced model construction</li> <li>Mathematical Expressions - Complex rate formulas</li> <li>Examples - More complete examples</li> </ul>"},{"location":"guide/building-models/","title":"Building Models","text":"<p>The <code>ModelBuilder</code> class provides a fluent API for constructing epidemiological models.</p>"},{"location":"guide/building-models/#modelbuilder-basics","title":"ModelBuilder Basics","text":""},{"location":"guide/building-models/#creating-a-builder","title":"Creating a Builder","text":"<pre><code>from epimodel import ModelBuilder\n\nbuilder = ModelBuilder(\n    name=\"My Model\",\n    version=\"1.0\",\n    description=\"Optional description\"\n)\n</code></pre>"},{"location":"guide/building-models/#chaining-methods","title":"Chaining Methods","text":"<p>The builder uses method chaining for a clean, readable API:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR Model\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .build(ModelTypes.DIFFERENCE_EQUATIONS)\n)\n</code></pre>"},{"location":"guide/building-models/#adding-disease-states","title":"Adding Disease States","text":"<pre><code>builder.add_disease_state(\n    id=\"S\",                    # Required: Unique identifier\n    name=\"Susceptible\",        # Required: Display name\n    description=\"Population susceptible to infection\"  # Optional\n)\n</code></pre>"},{"location":"guide/building-models/#best-practices","title":"Best Practices","text":"<ul> <li>Use short, clear IDs (S, I, R, E, etc.)</li> <li>Provide descriptive names</li> </ul>"},{"location":"guide/building-models/#adding-stratifications","title":"Adding Stratifications","text":"<p>Stratifications create population subgroups:</p> <pre><code>builder.add_stratification(\n    id=\"age_group\",\n    categories=[\"0-17\", \"18-64\", \"65+\"],\n    description=\"Age-based stratification\"\n)\n</code></pre>"},{"location":"guide/building-models/#multiple-stratifications","title":"Multiple Stratifications","text":"<pre><code>builder.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\nbuilder.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n</code></pre> <p>This creates compartments: <code>S_young_urban</code>, <code>S_young_rural</code>, <code>S_old_urban</code>, <code>S_old_rural</code>, etc.</p>"},{"location":"guide/building-models/#adding-parameters","title":"Adding Parameters","text":"<p>Parameters are global constants used in formulas:</p> <pre><code>builder.add_parameter(\n    id=\"beta\",\n    value=0.3,\n    description=\"Transmission rate per contact per day\"\n)\n</code></pre>"},{"location":"guide/building-models/#parameter-guidelines","title":"Parameter Guidelines","text":"<ul> <li>Use meaningful IDs (beta, gamma, R0, etc.)</li> <li>Document units and meaning</li> <li>Ensure values are realistic for your model</li> </ul>"},{"location":"guide/building-models/#adding-transitions","title":"Adding Transitions","text":"<p>Transitions move populations between states.</p>"},{"location":"guide/building-models/#understanding-transition-rates","title":"Understanding Transition Rates","text":"<p>The <code>rate</code> parameter accepts mathematical expressions that can include:</p> <ul> <li>Parameters: Reference parameter IDs (e.g., <code>\"gamma\"</code>)</li> <li>Disease states: Use state populations (e.g., <code>\"S\"</code>, <code>\"I\"</code>)</li> <li>Special variables: <code>N</code> (total population), <code>step</code> or <code>t</code> (current time step), <code>pi</code>, <code>e</code></li> <li>Mathematical operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> (power)</li> <li>Functions: <code>sin()</code>, <code>cos()</code>, <code>exp()</code>, <code>log()</code>, <code>sqrt()</code>, <code>max()</code>, <code>min()</code>, etc.</li> </ul> <p>For the complete list of functions and advanced examples, see Mathematical Expressions.</p>"},{"location":"guide/building-models/#simple-parameter-based-rates","title":"Simple Parameter-Based Rates","text":"<pre><code>builder.add_transition(\n    id=\"recovery\",\n    source=[\"I\"],\n    target=[\"R\"],\n    rate=\"gamma\"  # References parameter id\n)\n</code></pre>"},{"location":"guide/building-models/#formula-based-rates","title":"Formula-Based Rates","text":"<pre><code>builder.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"  # Mathematical expression\n)\n</code></pre>"},{"location":"guide/building-models/#constant-rates","title":"Constant Rates","text":"<pre><code>builder.add_transition(\n    id=\"birth\",\n    source=[],      # Empty = enters system\n    target=[\"S\"],\n    rate=\"0.001\"    # Fixed rate\n)\n</code></pre>"},{"location":"guide/building-models/#time-dependent-rates","title":"Time-Dependent Rates","text":"<pre><code>builder.add_transition(\n    id=\"seasonal_infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * (1 + 0.3 * sin(2 * pi * t / 365)) * S * I / N\"\n)\n</code></pre> <p>See Mathematical Expressions for more complex rate formulas.</p>"},{"location":"guide/building-models/#multi-state-transitions","title":"Multi-State Transitions","text":"<pre><code># Death from any compartment\nbuilder.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],  # Empty = leaves system\n    rate=\"mu\"\n)\n</code></pre>"},{"location":"guide/building-models/#setting-initial-conditions","title":"Setting Initial Conditions","text":""},{"location":"guide/building-models/#basic-setup","title":"Basic Setup","text":"<pre><code>builder.set_initial_conditions(\n    population_size=1000,\n    disease_state_fractions={\n        \"S\": 0.99,\n        \"I\": 0.01,\n        \"R\": 0.0\n    }\n)\n</code></pre>"},{"location":"guide/building-models/#with-stratifications","title":"With Stratifications","text":"<pre><code>builder.set_initial_conditions(\n    population_size=10000,\n    disease_state_fractions={\n        \"S\": 0.99,\n        \"I\": 0.01,\n        \"R\": 0.0\n    },\n    stratification_fractions={\n        \"age_group\": {\n            \"young\": 0.3,\n            \"adult\": 0.5,\n            \"elderly\": 0.2\n        },\n        \"risk\": {\n            \"low\": 0.8,\n            \"high\": 0.2\n        }\n    }\n)\n</code></pre>"},{"location":"guide/building-models/#building-the-model","title":"Building the Model","text":"<p>Once all components are added, build the model:</p> <pre><code>from epimodel.constants import ModelTypes\n\nmodel = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n</code></pre>"},{"location":"guide/building-models/#validation","title":"Validation","text":"<p>The build process validates:</p> <ul> <li>All disease state fractions sum to 1.0</li> <li>All stratification fractions sum to 1.0</li> <li>Transition sources/targets reference valid states</li> <li>Mathematical expressions are syntactically correct</li> <li>No security issues in formulas</li> </ul> <p>If validation fails, a descriptive error is raised.</p>"},{"location":"guide/building-models/#advanced-conditional-transitions","title":"Advanced: Conditional Transitions","text":"<p>Create transitions that only occur under certain conditions:</p> <pre><code># Create a condition\ncondition = builder.create_condition(\n    logic=\"and\",\n    rules=[\n        {\"variable\": \"state:I\", \"operator\": \"gt\", \"value\": 100},\n        {\"variable\": \"step\", \"operator\": \"gt\", \"value\": 30}\n    ]\n)\n\n# Add conditional transition\nbuilder.add_transition(\n    id=\"intervention\",\n    source=[\"S\"],\n    target=[\"S\"],\n    rate=\"0.5 * beta\",  # Reduced transmission\n    condition=condition\n)\n</code></pre>"},{"location":"guide/building-models/#loading-from-json","title":"Loading from JSON","text":"<p>Load pre-defined models from JSON files:</p> <pre><code>from epimodel import ModelLoader\n\nmodel = ModelLoader.from_json(\"path/to/model.json\")\n</code></pre>"},{"location":"guide/building-models/#json-structure","title":"JSON Structure","text":"<pre><code>{\n  \"name\": \"SIR Model\",\n  \"version\": \"1.0\",\n  \"population\": {\n    \"disease_states\": [\n      { \"id\": \"S\", \"name\": \"Susceptible\" },\n      { \"id\": \"I\", \"name\": \"Infected\" },\n      { \"id\": \"R\", \"name\": \"Recovered\" }\n    ]\n  },\n  \"parameters\": [\n    { \"id\": \"beta\", \"value\": 0.3 },\n    { \"id\": \"gamma\", \"value\": 0.1 }\n  ],\n  \"dynamics\": {\n    \"typology\": \"difference_equations\",\n    \"transitions\": [\n      {\n        \"id\": \"infection\",\n        \"source\": [\"S\"],\n        \"target\": [\"I\"],\n        \"rate\": \"beta * S * I / N\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"guide/building-models/#complete-example","title":"Complete Example","text":"<pre><code>from epimodel import ModelBuilder, Simulation\nfrom epimodel.constants import ModelTypes\n\n# Build SEIR model\nmodel = (\n    ModelBuilder(name=\"SEIR Model\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"E\", name=\"Exposed\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4, description=\"Transmission rate\")\n    .add_parameter(id=\"sigma\", value=0.2, description=\"Incubation rate\")\n    .add_parameter(id=\"gamma\", value=0.1, description=\"Recovery rate\")\n    .add_transition(id=\"exposure\", source=[\"S\"], target=[\"E\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"infection\", source=[\"E\"], target=[\"I\"], rate=\"sigma\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.999, \"E\": 0.0, \"I\": 0.001, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run simulation\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=200)\n</code></pre>"},{"location":"guide/building-models/#next-steps","title":"Next Steps","text":"<ul> <li>Mathematical Expressions - Advanced formulas</li> <li>Simulations - Running and analyzing models</li> <li>Examples - Complete model examples</li> </ul>"},{"location":"guide/core-concepts/","title":"Core Concepts","text":"<p>EpiModel is built around several key concepts that work together to create epidemiological models.</p>"},{"location":"guide/core-concepts/#disease-states","title":"Disease States","text":"<p>Disease states (also called compartments) represent different stages of infection in your population.</p> <pre><code>builder.add_disease_state(id=\"S\", name=\"Susceptible\")\nbuilder.add_disease_state(id=\"E\", name=\"Exposed\")\nbuilder.add_disease_state(id=\"I\", name=\"Infected\")\nbuilder.add_disease_state(id=\"R\", name=\"Recovered\")\n</code></pre>"},{"location":"guide/core-concepts/#common-disease-states","title":"Common Disease States","text":"ID Name Description S Susceptible Individuals who can become infected E Exposed Infected but not yet infectious I Infected Actively infected and infectious R Recovered No longer infectious, immune D Dead Deceased from disease"},{"location":"guide/core-concepts/#stratifications","title":"Stratifications","text":"<p>Stratifications allow you to model population subgroups (age, location, risk factors, etc.):</p> <pre><code># Age stratification\nbuilder.add_stratification(\n    id=\"age_group\",\n    categories=[\"young\", \"adult\", \"elderly\"]\n)\n\n# Location stratification\nbuilder.add_stratification(\n    id=\"region\",\n    categories=[\"urban\", \"rural\"]\n)\n</code></pre>"},{"location":"guide/core-concepts/#initial-conditions-with-stratifications","title":"Initial Conditions with Stratifications","text":"<pre><code>builder.set_initial_conditions(\n    population_size=10000,\n    disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0},\n    stratification_fractions={\n        \"age_group\": {\n            \"young\": 0.3,\n            \"adult\": 0.5,\n            \"elderly\": 0.2\n        }\n    }\n)\n</code></pre> <p>This creates compartments: <code>S_young</code>, <code>S_adult</code>, <code>S_elderly</code>, <code>I_young</code>, etc.</p>"},{"location":"guide/core-concepts/#parameters","title":"Parameters","text":"<p>Parameters are global constants used throughout your model:</p> <pre><code>builder.add_parameter(\n    id=\"beta\",\n    value=0.3,\n    description=\"Transmission rate per contact\"\n)\n\nbuilder.add_parameter(\n    id=\"gamma\",\n    value=0.1,\n    description=\"Recovery rate (1/infectious_period)\"\n)\n</code></pre>"},{"location":"guide/core-concepts/#common-parameters","title":"Common Parameters","text":"Parameter Meaning Typical Range <code>beta</code> Transmission rate 0.1 - 1.0 <code>gamma</code> Recovery rate 0.05 - 0.5 <code>sigma</code> Incubation rate (1/incubation_period) 0.1 - 0.5 <code>mu</code> Birth/death rate 0.0001 - 0.001 <code>R0</code> Basic reproduction number 1.0 - 10.0"},{"location":"guide/core-concepts/#transitions","title":"Transitions","text":"<p>Transitions define how populations move between disease states:</p>"},{"location":"guide/core-concepts/#simple-transitions","title":"Simple Transitions","text":"<pre><code># Recovery: I \u2192 R\nbuilder.add_transition(\n    id=\"recovery\",\n    source=[\"I\"],\n    target=[\"R\"],\n    rate=\"gamma\"\n)\n</code></pre>"},{"location":"guide/core-concepts/#formula-based-transitions","title":"Formula-Based Transitions","text":"<pre><code># Infection: S \u2192 I (with force of infection)\nbuilder.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"\n)\n</code></pre>"},{"location":"guide/core-concepts/#multi-source-transitions","title":"Multi-Source Transitions","text":"<pre><code># Natural death from any state\nbuilder.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],  # Empty = removal from system\n    rate=\"0.000027\"  # Daily death rate\n)\n</code></pre>"},{"location":"guide/core-concepts/#initial-conditions","title":"Initial Conditions","text":"<p>Initial conditions define the starting state of your model:</p> <pre><code>builder.set_initial_conditions(\n    population_size=1000,\n    disease_state_fractions={\n        \"S\": 0.99,   # 99% susceptible\n        \"I\": 0.01,   # 1% infected\n        \"R\": 0.0     # 0% recovered\n    }\n)\n</code></pre>"},{"location":"guide/core-concepts/#validation-rules","title":"Validation Rules","text":"<ul> <li>Disease state fractions must sum to 1.0</li> <li>Stratification fractions must sum to 1.0 for each stratification</li> <li>Population size must be positive</li> <li>All disease states must have initial fractions defined</li> </ul>"},{"location":"guide/core-concepts/#model-types","title":"Model Types","text":"<p>EpiModel currently supports:</p> <pre><code>from epimodel.constants import ModelTypes\n\nmodel = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n</code></pre>"},{"location":"guide/core-concepts/#difference-equations","title":"Difference Equations","text":"<ul> <li>Discrete time steps</li> <li>Deterministic dynamics</li> <li>Fast computation</li> <li>Best for: Population-level modeling, policy analysis</li> </ul>"},{"location":"guide/core-concepts/#the-model-building-process","title":"The Model Building Process","text":"<p>A typical workflow:</p> <ol> <li>Define disease states - What compartments exist?</li> <li>Add stratifications (optional) - What subgroups matter?</li> <li>Define parameters - What rates and constants?</li> <li>Create transitions - How do populations flow?</li> <li>Set initial conditions - What's the starting state?</li> <li>Build the model - Validate and construct</li> <li>Run simulation - Execute and analyze</li> </ol>"},{"location":"guide/core-concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Building Models - Detailed ModelBuilder API</li> <li>Mathematical Expressions - Advanced formulas</li> <li>Examples - Complete model examples</li> </ul>"},{"location":"guide/examples/","title":"Examples","text":"<p>Complete examples demonstrating different modeling scenarios.</p>"},{"location":"guide/examples/#example-1-basic-sir-model","title":"Example 1: Basic SIR Model","text":"<p>Classic Susceptible-Infected-Recovered model:</p> <pre><code>from epimodel import ModelBuilder, Simulation\nfrom epimodel.constants import ModelTypes\nimport matplotlib.pyplot as plt\n\n# Build model\nmodel = (\n    ModelBuilder(name=\"Basic SIR\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Simulate\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n\n# Plot\nplt.figure(figsize=(10, 6))\nplt.plot(results[\"S\"], label=\"Susceptible\", color=\"blue\")\nplt.plot(results[\"I\"], label=\"Infected\", color=\"red\")\nplt.plot(results[\"R\"], label=\"Recovered\", color=\"green\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Population\")\nplt.title(\"SIR Model\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"guide/examples/#example-2-seir-model","title":"Example 2: SEIR Model","text":"<p>Adding an exposed (incubation) period:</p> <pre><code>model = (\n    ModelBuilder(name=\"SEIR Model\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"E\", name=\"Exposed\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4, description=\"Transmission rate\")\n    .add_parameter(id=\"sigma\", value=0.2, description=\"Incubation rate\")\n    .add_parameter(id=\"gamma\", value=0.1, description=\"Recovery rate\")\n    .add_transition(id=\"exposure\", source=[\"S\"], target=[\"E\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"infection\", source=[\"E\"], target=[\"I\"], rate=\"sigma\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.999, \"E\": 0.0, \"I\": 0.001, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=200)\n</code></pre>"},{"location":"guide/examples/#example-3-seasonal-transmission","title":"Example 3: Seasonal Transmission","text":"<p>Modeling seasonal variation in transmission:</p> <pre><code>model = (\n    ModelBuilder(name=\"Seasonal SIR\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta_mean\", value=0.3)\n    .add_parameter(id=\"beta_amp\", value=0.2)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(\n        id=\"seasonal_infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        # Seasonal forcing: peaks in winter (day 0, 365, ...)\n        rate=\"beta_mean * (1 + beta_amp * sin(2 * pi * step / 365)) * S * I / N\"\n    )\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run for 3 years to see seasonal pattern\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=365 * 3)\n\nplt.figure(figsize=(12, 6))\nplt.plot(results[\"I\"], color=\"red\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Infected Population\")\nplt.title(\"Seasonal Transmission Pattern\")\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"guide/examples/#example-4-age-stratified-model","title":"Example 4: Age-Stratified Model","text":"<p>Different age groups with varying susceptibility:</p> <pre><code>model = (\n    ModelBuilder(name=\"Age-Stratified SIR\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_stratification(id=\"age\", categories=[\"child\", \"adult\", \"elderly\"])\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma_child\", value=0.15)\n    .add_parameter(id=\"gamma_adult\", value=0.12)\n    .add_parameter(id=\"gamma_elderly\", value=0.08)\n    # Note: In a real age-stratified model, you'd add transitions for each age group\n    # This is a simplified example\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma_adult\")\n    .set_initial_conditions(\n        population_size=10000,\n        disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0},\n        stratification_fractions={\n            \"age\": {\n                \"child\": 0.25,\n                \"adult\": 0.55,\n                \"elderly\": 0.20\n            }\n        }\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=200)\n\n# Plot stratified results\nplt.figure(figsize=(12, 8))\n\n# Plot infected by age group\nfor age in [\"child\", \"adult\", \"elderly\"]:\n    key = f\"I_{age}\"\n    if key in results:\n        plt.plot(results[key], label=f\"Infected ({age})\")\n\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Population\")\nplt.title(\"Age-Stratified Infections\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"guide/examples/#example-5-vaccination-campaign","title":"Example 5: Vaccination Campaign","text":"<p>Adding vaccination to an SIR model:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR with Vaccination\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"vax_rate\", value=0.01)  # 1% per day\n    .add_parameter(id=\"vax_eff\", value=0.9)     # 90% effective\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .add_transition(\n        id=\"vaccination\",\n        source=[\"S\"],\n        target=[\"R\"],\n        rate=\"vax_rate * vax_eff\"  # Effective vaccination rate\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Compare with and without vaccination\nsimulation = Simulation(model)\nresults_vax = simulation.run(num_steps=200)\n\n# Model without vaccination\nmodel_no_vax = (\n    ModelBuilder(name=\"SIR No Vaccination\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation_no_vax = Simulation(model_no_vax)\nresults_no_vax = simulation_no_vax.run(num_steps=200)\n\n# Compare\nplt.figure(figsize=(12, 5))\n\nplt.subplot(1, 2, 1)\nplt.plot(results_no_vax[\"I\"], label=\"No Vaccination\", color=\"red\")\nplt.plot(results_vax[\"I\"], label=\"With Vaccination\", color=\"orange\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Infected\")\nplt.title(\"Impact of Vaccination on Infections\")\nplt.legend()\nplt.grid(True)\n\nplt.subplot(1, 2, 2)\nplt.plot(results_no_vax[\"R\"], label=\"No Vaccination\", color=\"green\")\nplt.plot(results_vax[\"R\"], label=\"With Vaccination\", color=\"lightgreen\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Recovered/Immune\")\nplt.title(\"Immunity Over Time\")\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"guide/examples/#example-6-healthcare-capacity","title":"Example 6: Healthcare Capacity","text":"<p>Modeling reduced recovery when hospitals are overwhelmed:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR with Healthcare Capacity\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.5)\n    .add_parameter(id=\"gamma_max\", value=0.15)\n    .add_parameter(id=\"hospital_cap\", value=100.0)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(\n        id=\"recovery_saturated\",\n        source=[\"I\"],\n        target=[\"R\"],\n        # Recovery slows as infections approach hospital capacity\n        rate=\"gamma_max * (1 - max(0, (I - hospital_cap) / hospital_cap))\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.95, \"I\": 0.05, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=150)\n\nplt.figure(figsize=(10, 6))\nplt.plot(results[\"I\"], label=\"Infected\", color=\"red\")\nplt.axhline(y=100, color=\"black\", linestyle=\"--\", label=\"Hospital Capacity\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Population\")\nplt.title(\"Healthcare Capacity Saturation\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"guide/examples/#example-7-waning-immunity","title":"Example 7: Waning Immunity","text":"<p>Recovered individuals gradually become susceptible again:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIRS Model\", version=\"1.0\")\n    .add_disease_state(id=\"S\", name=\"Susceptible\")\n    .add_disease_state(id=\"I\", name=\"Infected\")\n    .add_disease_state(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"omega\", value=0.01)  # Waning immunity rate\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .add_transition(id=\"waning\", source=[\"R\"], target=[\"S\"], rate=\"omega\")\n    .set_initial_conditions(\n        population_size=1000,\n        disease_state_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run for longer to see endemic equilibrium\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=1000)\n\nplt.figure(figsize=(12, 6))\nplt.plot(results[\"S\"], label=\"Susceptible\", color=\"blue\")\nplt.plot(results[\"I\"], label=\"Infected\", color=\"red\")\nplt.plot(results[\"R\"], label=\"Recovered\", color=\"green\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Population\")\nplt.title(\"SIRS Model with Waning Immunity\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"guide/examples/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Mathematical Expressions - Advanced formulas</li> <li>Contributing - Build your own examples</li> </ul>"},{"location":"guide/mathematical-expressions/","title":"Mathematical Expressions","text":"<p>EpiModel supports rich mathematical expressions in transition rates, enabling complex and realistic disease dynamics.</p>"},{"location":"guide/mathematical-expressions/#basic-syntax","title":"Basic Syntax","text":"<p>Transition rates are specified as string expressions that are evaluated during simulation:</p> <pre><code>.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"  # Mathematical expression as a string\n)\n</code></pre>"},{"location":"guide/mathematical-expressions/#arithmetic-operations","title":"Arithmetic Operations","text":""},{"location":"guide/mathematical-expressions/#basic-operations","title":"Basic Operations","text":"Operation Operator Example Description Addition <code>+</code> <code>\"alpha + beta\"</code> Sum of two values Subtraction <code>-</code> <code>\"alpha - beta\"</code> Difference Multiplication <code>*</code> <code>\"beta * S\"</code> Product Division <code>/</code> <code>\"I / N\"</code> Division Exponentiation <code>**</code> <code>\"beta ** 2\"</code> Power Parentheses <code>()</code> <code>\"(alpha + beta) * I\"</code> Grouping"},{"location":"guide/mathematical-expressions/#examples","title":"Examples","text":"<pre><code>rate = \"beta * S * I\"           # Multiply transmission rate by populations\nrate = \"gamma + delta\"          # Add two parameters\nrate = \"beta / N\"               # Divide by total population\nrate = \"(beta + gamma) / 2\"     # Average with parentheses\nrate = \"beta ** 2\"              # Square a value\n</code></pre>"},{"location":"guide/mathematical-expressions/#available-variables","title":"Available Variables","text":""},{"location":"guide/mathematical-expressions/#disease-state-variables","title":"Disease State Variables","text":"<p>Reference any disease state by its ID:</p> <pre><code># In a model with states S, I, R\nrate = \"beta * S * I\"    # Use S and I populations\nrate = \"gamma * I\"       # Use I population\nrate = \"0.01 * R\"        # Use R population\n</code></pre>"},{"location":"guide/mathematical-expressions/#special-variables","title":"Special Variables","text":"Variable Type Description <code>N</code> float Total population (automatic sum of all compartments) <code>step</code> int Current simulation step (0, 1, 2, ...) <code>t</code> int Alias for <code>step</code> <code>pi</code> float Mathematical constant \u03c0 \u2248 3.14159 <code>e</code> float Mathematical constant e \u2248 2.71828 <p>Examples:</p> <pre><code>rate = \"beta * I / N\"              # Frequency-dependent transmission\nrate = \"beta * sin(2 * pi * t)\"    # Periodic variation\nrate = \"gamma * exp(-0.01 * step)\" # Exponential decay over time\n</code></pre>"},{"location":"guide/mathematical-expressions/#parameter-references","title":"Parameter References","text":"<p>Reference any parameter by its ID:</p> <pre><code>.add_parameter(id=\"beta\", value=0.3)\n.add_parameter(id=\"gamma\", value=0.1)\n\n.add_transition(rate=\"beta * S * I / N\")  # Uses beta parameter\n.add_transition(rate=\"gamma\")             # Uses gamma parameter\n</code></pre>"},{"location":"guide/mathematical-expressions/#mathematical-functions","title":"Mathematical Functions","text":""},{"location":"guide/mathematical-expressions/#trigonometric-functions","title":"Trigonometric Functions","text":"Function Description Example <code>sin(x)</code> Sine <code>sin(2 * pi * t / 365)</code> <code>cos(x)</code> Cosine <code>cos(t)</code> <code>tan(x)</code> Tangent <code>tan(x)</code> <code>asin(x)</code> Arc sine <code>asin(x)</code> <code>acos(x)</code> Arc cosine <code>acos(x)</code> <code>atan(x)</code> Arc tangent <code>atan(x)</code> <code>atan2(y, x)</code> Two-argument arc tangent <code>atan2(y, x)</code> <p>Example:</p> <pre><code># Seasonal variation (peaks annually)\nrate = \"beta * sin(2 * pi * step / 365)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#exponential-and-logarithmic","title":"Exponential and Logarithmic","text":"Function Description Example <code>exp(x)</code> Exponential (e^x) <code>exp(-0.01 * t)</code> <code>log(x)</code> Natural logarithm <code>log(I + 1)</code> <code>ln(x)</code> Alias for <code>log</code> <code>ln(I + 1)</code> <code>log10(x)</code> Base-10 logarithm <code>log10(I)</code> <code>log2(x)</code> Base-2 logarithm <code>log2(I)</code> <p>Example:</p> <pre><code># Exponential decay over time\nrate = \"gamma * exp(-0.01 * step)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#power-and-root","title":"Power and Root","text":"Function Description Example <code>sqrt(x)</code> Square root <code>sqrt(I)</code> <code>pow(x, y)</code> Power (x^y) <code>pow(I, 2)</code> <code>x ** y</code> Power operator <code>I ** 2</code> <p>Example:</p> <pre><code># Square root relationship\nrate = \"beta * sqrt(I)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#comparison-functions","title":"Comparison Functions","text":"Function Description Example <code>max(a, b)</code> Maximum of two values <code>max(0, beta - 0.01)</code> <code>min(a, b)</code> Minimum of two values <code>min(gamma, 0.5)</code> <code>abs(x)</code> Absolute value <code>abs(x)</code> <p>Example:</p> <pre><code># Ensure rate stays positive\nrate = \"max(0, beta - 0.001 * step)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#rounding-functions","title":"Rounding Functions","text":"Function Description Example <code>floor(x)</code> Round down <code>floor(beta * I)</code> <code>ceil(x)</code> Round up <code>ceil(gamma * I)</code> <code>round(x)</code> Round to nearest <code>round(alpha * I)</code>"},{"location":"guide/mathematical-expressions/#hyperbolic-functions","title":"Hyperbolic Functions","text":"Function Description Example <code>sinh(x)</code> Hyperbolic sine <code>sinh(x)</code> <code>cosh(x)</code> Hyperbolic cosine <code>cosh(x)</code> <code>tanh(x)</code> Hyperbolic tangent <code>tanh(x)</code>"},{"location":"guide/mathematical-expressions/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/mathematical-expressions/#time-dependent-rates","title":"Time-Dependent Rates","text":"<p>Use <code>step</code> or <code>t</code> for time-varying rates:</p> <pre><code># Linear increase\nrate = \"0.1 + 0.001 * step\"\n\n# Exponential decay\nrate = \"beta * exp(-0.01 * t)\"\n\n# Seasonal pattern (annual cycle)\nrate = \"beta * (1 + 0.3 * sin(2 * pi * step / 365))\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#population-dependent-rates","title":"Population-Dependent Rates","text":"<pre><code># Standard mass action\nrate = \"beta * S * I\"\n\n# Frequency-dependent (normalized by population)\nrate = \"beta * S * I / N\"\n\n# Saturation effect\nrate = \"beta * I / (1 + I)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#threshold-effects","title":"Threshold Effects","text":"<pre><code># Activate when condition is met\nrate = \"max(0, beta) * (I &gt; 100)\"  # Only when I &gt; 100\n\n# Reduce transmission above threshold\nrate = \"beta * min(1, 100 / I)\"    # Reduces when I &gt; 100\n</code></pre>"},{"location":"guide/mathematical-expressions/#composite-expressions","title":"Composite Expressions","text":"<p>Combine multiple effects:</p> <pre><code># Seasonal transmission with saturation\nrate = \"beta * (1 + 0.3 * sin(2 * pi * t / 365)) * S * I / (N + I)\"\n\n# Time-varying intervention\nrate = \"beta * max(0.2, 1 - 0.01 * step) * S * I / N\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#operator-precedence","title":"Operator Precedence","text":"<p>From highest to lowest priority:</p> <ol> <li>Parentheses: <code>()</code></li> <li>Exponentiation: <code>**</code></li> <li>Multiplication/Division: <code>*</code>, <code>/</code></li> <li>Addition/Subtraction: <code>+</code>, <code>-</code></li> </ol> <p>Examples:</p> <pre><code>rate = \"2 + 3 * 4\"        # = 14 (multiplication first)\nrate = \"(2 + 3) * 4\"      # = 20 (parentheses first)\nrate = \"2 ** 3 * 4\"       # = 32 (exponentiation first)\nrate = \"2 * 3 ** 4\"       # = 162 (exponentiation before multiplication)\n</code></pre>"},{"location":"guide/mathematical-expressions/#best-practices","title":"Best Practices","text":""},{"location":"guide/mathematical-expressions/#1-use-meaningful-parameters","title":"1. Use Meaningful Parameters","text":"<pre><code># Good: Clear parameter names\n.add_parameter(id=\"beta\", value=0.3)\nrate = \"beta * S * I / N\"\n\n# Avoid: Magic numbers\nrate = \"0.3 * S * I / N\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#2-prevent-division-by-zero","title":"2. Prevent Division by Zero","text":"<pre><code># Good: Add small constant\nrate = \"beta * I / (N + 1)\"\n\n# Good: Use max\nrate = \"beta * I / max(N, 1)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#3-keep-expressions-simple","title":"3. Keep Expressions Simple","text":"<pre><code># Good: Simple and readable\nrate = \"beta * S * I / N\"\n\n# Acceptable but complex:\nrate = \"beta * (1 + 0.3 * sin(2 * pi * t / 365)) * S * I / N\"\n\n# Better: Split into parameters\n.add_parameter(id=\"seasonal_beta\", value=\"beta * (1 + 0.3 * sin(2 * pi * t / 365))\")\nrate = \"seasonal_beta * S * I / N\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#4-document-complex-expressions","title":"4. Document Complex Expressions","text":"<pre><code>.add_transition(\n    id=\"seasonal_infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * (1 + 0.3 * sin(2 * pi * step / 365)) * S * I / N\",\n    description=\"Infection with 30% seasonal amplitude, annual cycle\"\n)\n</code></pre>"},{"location":"guide/mathematical-expressions/#security-features","title":"Security Features","text":"<p>EpiModel validates all expressions for security:</p>"},{"location":"guide/mathematical-expressions/#safe-operations","title":"Safe Operations","text":"<pre><code>rate = \"beta * S * I / N\"                    # Mathematical operations\nrate = \"sin(2 * pi * t)\"                     # Mathematical functions\nrate = \"max(0, gamma - 0.01 * step)\"        # Built-in functions\n</code></pre>"},{"location":"guide/mathematical-expressions/#blocked-operations","title":"Blocked Operations","text":"<pre><code>rate = \"__import__('os')\"                    # Python imports\nrate = \"eval('code')\"                        # Code evaluation\nrate = \"exec('code')\"                        # Code execution\nrate = \"open('file')\"                        # File operations\n</code></pre> <p>The parser:</p> <ul> <li>Only allows mathematical operations and approved functions</li> <li>Blocks all Python/Rust code execution</li> <li>Validates syntax before simulation</li> <li>Prevents code injection attacks</li> </ul>"},{"location":"guide/mathematical-expressions/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/mathematical-expressions/#expression-complexity","title":"Expression Complexity","text":"<ul> <li>Fast: <code>\"gamma\"</code> (parameter lookup)</li> <li>Fast: <code>\"beta * I\"</code> (simple arithmetic)</li> <li>Medium: <code>\"beta * S * I / N\"</code> (multiple operations)</li> <li>Slower: <code>\"beta * exp(-0.01 * step) * sin(2 * pi * t / 365)\"</code> (functions + operations)</li> </ul>"},{"location":"guide/mathematical-expressions/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use parameters for constants:</li> </ol> <pre><code># Slower: recalculates each step\nrate = \"0.3 * S * I / 1000\"\n\n# Faster: parameter lookup\n.add_parameter(id=\"beta\", value=0.3)\nrate = \"beta * S * I / N\"\n</code></pre> <ol> <li>Simplify when possible:</li> </ol> <pre><code># Complex\nrate = \"beta * I / N + gamma * I / N\"\n\n# Simplified\nrate = \"(beta + gamma) * I / N\"\n</code></pre> <ol> <li>Profile complex models: Use <code>time</code> module to measure performance with different expressions.</li> </ol>"},{"location":"guide/mathematical-expressions/#complete-function-reference","title":"Complete Function Reference","text":""},{"location":"guide/mathematical-expressions/#all-available-functions","title":"All Available Functions","text":"Category Functions Trigonometric <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>asin</code>, <code>acos</code>, <code>atan</code>, <code>atan2</code> Exponential/Log <code>exp</code>, <code>log</code>, <code>ln</code>, <code>log10</code>, <code>log2</code> Power/Root <code>sqrt</code>, <code>pow</code> Comparison <code>max</code>, <code>min</code>, <code>abs</code> Rounding <code>floor</code>, <code>ceil</code>, <code>round</code> Hyperbolic <code>sinh</code>, <code>cosh</code>, <code>tanh</code>"},{"location":"guide/mathematical-expressions/#all-available-variables","title":"All Available Variables","text":"Variable Type Description Disease states float Any state ID (S, I, R, etc.) Parameters float Any parameter ID <code>N</code> float Total population <code>step</code> int Current time step <code>t</code> int Alias for step <code>pi</code> float \u03c0 constant <code>e</code> float e constant"},{"location":"guide/mathematical-expressions/#all-operators","title":"All Operators","text":"Operator Description <code>+</code> Addition <code>-</code> Subtraction <code>*</code> Multiplication <code>/</code> Division <code>**</code> Exponentiation <code>()</code> Grouping"},{"location":"guide/mathematical-expressions/#next-steps","title":"Next Steps","text":"<ul> <li>Building Models - Use expressions in transitions</li> <li>Simulations - Run models with mathematical expressions</li> <li>Examples - See complex expressions in complete models</li> </ul>"},{"location":"guide/simulations/","title":"Running Simulations","text":"<p>Once you've built a model, use the <code>Simulation</code> class to run it and analyze results.</p>"},{"location":"guide/simulations/#basic-simulation","title":"Basic Simulation","text":"<pre><code>from epimodel import Simulation\n\n# Create simulation from model\nsimulation = Simulation(model)\n\n# Run for 100 time steps\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/simulations/#output-formats","title":"Output Formats","text":"<p>EpiModel supports two output formats for simulation results.</p>"},{"location":"guide/simulations/#dictionary-of-lists-default","title":"Dictionary of Lists (Default)","text":"<p>Each disease state maps to a list of values over time:</p> <pre><code>results = simulation.run(num_steps=100, output_format=\"dict_of_lists\")\n\n# Access results\nsusceptible = results[\"S\"]  # [990, 985, 978, ...]\ninfected = results[\"I\"]     # [10, 15, 22, ...]\nrecovered = results[\"R\"]    # [0, 0, 0, ...]\n\n# Get final values\nfinal_S = results[\"S\"][-1]\nfinal_I = results[\"I\"][-1]\nfinal_R = results[\"R\"][-1]\n\nprint(f\"Final state: S={final_S:.0f}, I={final_I:.0f}, R={final_R:.0f}\")\n</code></pre> <p>Best for: Plotting, time series analysis, accessing specific compartments</p>"},{"location":"guide/simulations/#list-of-lists","title":"List of Lists","text":"<p>Each time step is a list of all compartment values:</p> <pre><code>results = simulation.run(num_steps=100, output_format=\"list_of_lists\")\n\n# results[time][compartment_index]\ninitial_state = results[0]     # [990, 10, 0]\nmidpoint_state = results[50]   # [450, 200, 350]\nfinal_state = results[-1]      # [340, 50, 610]\n\n# Iterate over time steps\nfor t, state in enumerate(results):\n    total = sum(state)\n    print(f\"Step {t}: Total population = {total}\")\n</code></pre> <p>Best for: Matrix operations, comparing states, exporting to CSV</p>"},{"location":"guide/simulations/#working-with-stratifications","title":"Working with Stratifications","text":"<p>Stratifications create multiple compartments by combining disease states with stratification categories. Understanding how to access and analyze stratified results is crucial for complex models.</p>"},{"location":"guide/simulations/#understanding-stratified-compartment-names","title":"Understanding Stratified Compartment Names","text":"<p>When you add stratifications, EpiModel creates compartments by combining disease state IDs with stratification category names using underscore notation:</p> <p>Pattern: <code>{disease_state}_{category1}_{category2}_...</code></p> <pre><code># Model with one stratification (age)\n.add_disease_state(id=\"S\", name=\"Susceptible\")\n.add_disease_state(id=\"I\", name=\"Infected\")\n.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n\n# Creates compartments: S_young, S_old, I_young, I_old\n</code></pre> <pre><code># Model with two stratifications (age and location)\n.add_disease_state(id=\"I\", name=\"Infected\")\n.add_stratification(id=\"age\", categories=[\"child\", \"adult\"])\n.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n\n# Creates compartments:\n# I_child_urban, I_child_rural, I_adult_urban, I_adult_rural\n</code></pre>"},{"location":"guide/simulations/#accessing-stratified-results","title":"Accessing Stratified Results","text":""},{"location":"guide/simulations/#1-list-all-compartments","title":"1. List All Compartments","text":"<pre><code>results = simulation.run(num_steps=100)\n\n# See all compartment names\nprint(\"All compartments:\", list(results.keys()))\n# Output: ['S_young', 'S_old', 'I_young', 'I_old', 'R_young', 'R_old']\n\n# Count compartments\nprint(f\"Total compartments: {len(results)}\")\n</code></pre>"},{"location":"guide/simulations/#2-access-specific-strata","title":"2. Access Specific Strata","text":"<pre><code># Access specific age groups\nyoung_infected = results[\"I_young\"]\nold_infected = results[\"I_old\"]\n\n# Access specific combinations (multiple stratifications)\nurban_child_infected = results[\"I_child_urban\"]\nrural_adult_infected = results[\"I_adult_rural\"]\n</code></pre>"},{"location":"guide/simulations/#3-filter-compartments-by-pattern","title":"3. Filter Compartments by Pattern","text":"<pre><code># Get all infected compartments\ninfected_keys = [key for key in results.keys() if key.startswith(\"I_\")]\nprint(\"Infected compartments:\", infected_keys)\n\n# Get all young compartments\nyoung_keys = [key for key in results.keys() if \"_young\" in key]\nprint(\"Young compartments:\", young_keys)\n\n# Get all urban compartments (multi-stratification)\nurban_keys = [key for key in results.keys() if \"_urban\" in key]\n</code></pre>"},{"location":"guide/simulations/#aggregating-stratified-results","title":"Aggregating Stratified Results","text":""},{"location":"guide/simulations/#sum-across-one-stratification","title":"Sum Across One Stratification","text":"<pre><code># Total infected across all age groups\ntotal_infected = np.array(results[\"I_young\"]) + np.array(results[\"I_old\"])\n\n# Or using list comprehension\ntotal_infected = [y + o for y, o in zip(results[\"I_young\"], results[\"I_old\"])]\n</code></pre>"},{"location":"guide/simulations/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/simulations/#1-case-sensitivity","title":"1. Case Sensitivity","text":"<pre><code># Compartment names use exact category names\n.add_stratification(id=\"age\", categories=[\"Young\", \"Old\"])  # Capital Y and O\n# Access with: results[\"I_Young\"], results[\"I_Old\"]\n</code></pre>"},{"location":"guide/simulations/#2-order-of-stratifications","title":"2. Order of Stratifications","text":"<pre><code># Categories combine in the order stratifications are added\n.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n\n# Creates: I_young_urban, I_young_rural, I_old_urban, I_old_rural\n# NOT: I_urban_young, I_rural_young, etc.\n</code></pre>"},{"location":"guide/simulations/#3-missing-compartments","title":"3. Missing Compartments","text":"<pre><code># Always check compartments exist before accessing\nkey = \"I_young\"\nif key in results:\n    data = results[key]\nelse:\n    print(f\"Compartment {key} not found. Available: {list(results.keys())}\")\n</code></pre>"},{"location":"guide/simulations/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - Complete model examples with analysis</li> <li>API Reference - Detailed Simulation API</li> <li>Mathematical Expressions - Advanced formulas</li> </ul>"}]}