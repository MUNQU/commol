{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Commol","text":"<p>A high-performance compartment modelling library for mathematical modeling using difference equations. Commol provides a clean Python API backed by a fast Rust engine for numerical computations.</p> <p>Alpha Stage - API Unstable</p> <p>Commol is currently in alpha development. The API is not yet stable and may change between versions without backward compatibility guarantees.</p> <pre><code>- Breaking changes may occur in any release\n- Not recommended for production use yet\n- API will stabilize in version 1.0.0\n\nWe welcome feedback and contributions as we work toward a stable release!\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Intuitive Model Building: Fluent API for constructing compartment models</li> <li>Mathematical Expressions: Support for complex mathematical formulas in transition rates</li> <li>High Performance: Rust-powered simulation engine for fast computations</li> <li>Flexible Architecture: Support for stratified populations and conditional transitions</li> <li>Type Safety: Comprehensive validation using Pydantic models</li> <li>Multiple Output Formats: Get results as dictionaries or lists for easy analysis</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n\n# Build a simple SIR model\nmodel = (\n    ModelBuilder(name=\"Basic SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"N\", value=1000.0)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run simulation\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide - Install Commol</li> <li>Quick Start - Build your first model</li> <li>Core Concepts - Understand the fundamentals</li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#user-guide","title":"User Guide","text":"<p>Learn how to build and run compartment models:</p> <ul> <li>Core Concepts - Disease states, stratifications, parameters</li> <li>Building Models - Using the ModelBuilder API</li> <li>Mathematical Expressions - Advanced rate formulas</li> <li>Running Simulations - Execute models and analyze results</li> <li>Model Calibration - Fit models to observed data</li> <li>Examples - Complete model examples (SIR, SEIR, stratified)</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<p>Complete API documentation for all public interfaces:</p> <ul> <li>Model Builder - ModelBuilder class documentation</li> <li>Simulation - Simulation runner</li> <li>Calibrator - Parameter calibration and optimization</li> <li>Constants - Model types and enumerations</li> </ul>"},{"location":"#development","title":"Development","text":"<p>Contributing to Commol:</p> <ul> <li>Development Workflow - Setup, branching, CI/CD</li> <li>Contributing Guidelines - How to contribute</li> <li>Release Process - Version management and releases</li> </ul>"},{"location":"#license","title":"License","text":"<p>Commol is licensed under the MIT License. See License for details.</p>"},{"location":"#authors","title":"Authors","text":"<p>MUNQU Team</p> <ul> <li>Rafael J. Villanueva Mic\u00f3</li> <li>Carlos Andreu Vilarroig</li> <li>David Mart\u00ednez Rodr\u00edguez</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to Commol will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>GitHub Actions CI/CD pipelines for code quality, building, and PyPI releases</li> <li>MkDocs Material documentation site</li> <li>Comprehensive development workflow documentation</li> <li>Contributing guidelines and release process documentation</li> </ul>"},{"location":"about/changelog/#001-2025","title":"[0.0.1] - 2025","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of Commol</li> <li>ModelBuilder fluent API for constructing compartment models</li> <li>Support for difference equations models</li> <li>Disease states and stratifications</li> <li>Mathematical expression support in transition rates</li> <li>Rust-powered simulation engine</li> <li>Python API with Pydantic validation</li> <li>Basic SIR, SEIR model support</li> <li>Initial conditions and parameter management</li> <li>Simulation runner with multiple output formats</li> </ul>"},{"location":"about/changelog/#security","title":"Security","text":"<ul> <li>Expression validation to prevent code injection</li> <li>Input sanitization for mathematical formulas</li> </ul>"},{"location":"about/changelog/#version-history","title":"Version History","text":"<ul> <li>0.0.1 - Initial release with core functionality</li> <li>Unreleased - Current development version</li> </ul> <p>For detailed information about each release, see the GitHub Releases page.</p>"},{"location":"about/license/","title":"License","text":"<p>EpiModel is licensed under the MIT License.</p>"},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2025 MUNQU Team</p> <ul> <li>Rafael J. Villanueva Mic\u00f3</li> <li>Carlos Andreu Vilarroig</li> <li>David Mart\u00ednez Rodr\u00edguez</li> </ul> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>EpiModel uses the following open-source libraries:</p>"},{"location":"about/license/#python-dependencies","title":"Python Dependencies","text":"<ul> <li>Pydantic - MIT License</li> <li>cffi - MIT License</li> </ul>"},{"location":"about/license/#rust-dependencies","title":"Rust Dependencies","text":"<ul> <li>pyo3 - Apache-2.0 OR MIT License</li> <li>serde - Apache-2.0 OR MIT License</li> </ul> <p>For a complete list of dependencies and their licenses, see the project's <code>Cargo.toml</code> and <code>pyproject.toml</code> files.</p>"},{"location":"advanced/model-structure/","title":"Model Structure (Advanced)","text":"<p>For Advanced Users</p> <p>This section documents the internal structure of the <code>Model</code> class and its components.</p> <pre><code>**Most users don't need this** - use `ModelBuilder` instead to create models.\n\nThis is useful for:\n- Understanding the internal model representation\n- Working with `ModelLoader.from_json()`\n- Contributing to the library\n- Debugging complex models\n</code></pre>"},{"location":"advanced/model-structure/#model","title":"Model","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.model.Model","title":"Model","text":"<p>               Bases: <code>BaseModel</code></p> <p>Root class of compartment model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A unique name that identifies the model.</p> <code>description</code> <code>str | None</code> <p>A human-readable description of the model's purpose and function.</p> <code>version</code> <code>str | None</code> <p>The version number of the model.</p> <code>population</code> <code>Population</code> <p>Population details, subpopulations, stratifications and initial conditions.</p> <code>parameters</code> <code>list[Parameter]</code> <p>A list of global model parameters.</p> <code>dynamics</code> <code>Dynamics</code> <p>The rules that govern system evolution.</p> Source code in <code>commol/context/model.py</code> <pre><code>class Model(BaseModel):\n    \"\"\"\n    Root class of compartment model.\n\n    Attributes\n    ----------\n    name : str\n        A unique name that identifies the model.\n    description : str | None\n        A human-readable description of the model's purpose and function.\n    version : str | None\n        The version number of the model.\n    population : Population\n        Population details, subpopulations, stratifications and initial conditions.\n    parameters : list[Parameter]\n        A list of global model parameters.\n    dynamics : Dynamics\n        The rules that govern system evolution.\n    \"\"\"\n\n    name: str = Field(..., description=\"Name which identifies the model.\")\n    description: str | None = Field(\n        None,\n        description=\"Human-readable description of the model's purpose and function.\",\n    )\n    version: str | None = Field(None, description=\"Version number of the model.\")\n\n    population: Population\n    parameters: list[Parameter]\n    dynamics: Dynamics\n\n    @model_validator(mode=\"after\")\n    def validate_unique_parameter_ids(self) -&gt; Self:\n        \"\"\"\n        Validates that parameter IDs are unique.\n        \"\"\"\n        parameter_ids = [p.id for p in self.parameters]\n        if len(parameter_ids) != len(set(parameter_ids)):\n            duplicates = [\n                item for item in set(parameter_ids) if parameter_ids.count(item) &gt; 1\n            ]\n            raise ValueError(f\"Duplicate parameter IDs found: {duplicates}\")\n        return self\n\n    def update_parameters(self, parameter_values: Mapping[str, float | None]) -&gt; None:\n        \"\"\"\n        Update parameter values in the model.\n\n        Parameters\n        ----------\n        parameter_values : Mapping[str, float | None]\n            Dictionary mapping parameter IDs to their new values.\n\n        Raises\n        ------\n        ValueError\n            If a parameter ID in the dictionary doesn't exist in the model.\n        \"\"\"\n        param_dict = {param.id: param for param in self.parameters}\n\n        for param_id, value in parameter_values.items():\n            if param_id not in param_dict:\n                raise ValueError(\n                    (\n                        f\"Parameter '{param_id}' not found in model. \"\n                        f\"Available parameters: {', '.join(param_dict.keys())}\"\n                    )\n                )\n            param_dict[param_id].value = value\n\n    def get_uncalibrated_parameters(self) -&gt; list[str]:\n        \"\"\"\n        Get a list of parameter IDs that have None values (need calibration).\n\n        Returns\n        -------\n        list[str]\n            List of parameter IDs that require calibration.\n        \"\"\"\n        return [param.id for param in self.parameters if param.value is None]\n\n    def get_uncalibrated_initial_conditions(self) -&gt; list[str]:\n        \"\"\"\n        Get a list of bin IDs that have None fractions (need calibration).\n\n        Returns\n        -------\n        list[str]\n            List of bin IDs with uncalibrated initial conditions.\n        \"\"\"\n        return self.population.initial_conditions.get_uncalibrated_bins()\n\n    def update_initial_conditions(\n        self, bin_fractions: Mapping[str, float | None]\n    ) -&gt; None:\n        \"\"\"\n        Update initial condition fractions for specified bins.\n\n        Parameters\n        ----------\n        bin_fractions : Mapping[str, float | None]\n            Dictionary mapping bin IDs to their new fraction values.\n\n        Raises\n        ------\n        ValueError\n            If a bin ID in the dictionary doesn't exist in the model.\n        \"\"\"\n        self.population.initial_conditions.update_bin_fractions(bin_fractions)\n\n    @model_validator(mode=\"after\")\n    def validate_formula_variables(self) -&gt; Self:\n        \"\"\"\n        Validate that all variables in rate expressions are defined.\n        This is done by gathering all valid identifiers and checking each\n        transition's rate expressions against them.\n        \"\"\"\n        valid_identifiers = self._get_valid_identifiers()\n\n        for transition in self.dynamics.transitions:\n            self._validate_transition_rates(transition, valid_identifiers)\n        return self\n\n    def _get_valid_identifiers(self) -&gt; set[str]:\n        \"\"\"Gathers all valid identifiers for use in rate expressions.\"\"\"\n        special_vars = {\"N\", \"step\", \"pi\", \"e\", \"t\"}\n        param_ids = {param.id for param in self.parameters}\n        bin_ids = {bin_item.id for bin_item in self.population.bins}\n\n        strat_category_ids: set[str] = {\n            cat for strat in self.population.stratifications for cat in strat.categories\n        }\n\n        subpopulation_n_vars = self._get_subpopulation_n_vars()\n\n        return (\n            param_ids\n            | bin_ids\n            | strat_category_ids\n            | special_vars\n            | subpopulation_n_vars\n        )\n\n    def _get_subpopulation_n_vars(self) -&gt; set[str]:\n        \"\"\"Generates all possible N_{category...} variable names.\"\"\"\n        if not self.population.stratifications:\n            return set()\n\n        subpopulation_n_vars: set[str] = set()\n        category_groups = [s.categories for s in self.population.stratifications]\n\n        # All possible combinations of categories across different stratifications\n        full_category_combos = product(*category_groups)\n\n        for combo_tuple in full_category_combos:\n            # For each combo, find all non-empty subsets\n            for i in range(1, len(combo_tuple) + 1):\n                for subset in combinations(combo_tuple, i):\n                    var_name = f\"N_{'_'.join(subset)}\"\n                    subpopulation_n_vars.add(var_name)\n\n        return subpopulation_n_vars\n\n    def _validate_transition_rates(\n        self, transition: Transition, valid_identifiers: set[str]\n    ) -&gt; None:\n        \"\"\"Validates the rate expressions for a single transition.\"\"\"\n        if transition.rate:\n            self._validate_rate_expression(\n                transition.rate, transition.id, \"rate\", valid_identifiers\n            )\n\n        if transition.stratified_rates:\n            for sr in transition.stratified_rates:\n                self._validate_rate_expression(\n                    sr.rate, transition.id, \"stratified_rate\", valid_identifiers\n                )\n\n    def _validate_rate_expression(\n        self, rate: str, transition_id: str, context: str, valid_identifiers: set[str]\n    ) -&gt; None:\n        \"\"\"Validates variables in a single rate expression.\"\"\"\n        variables = get_expression_variables(rate)\n        undefined_vars = [var for var in variables if var not in valid_identifiers]\n        if undefined_vars:\n            param_ids = {param.id for param in self.parameters}\n            bin_ids = {bin_item.id for bin_item in self.population.bins}\n            raise ValueError(\n                (\n                    f\"Undefined variables in transition '{transition_id}' \"\n                    f\"{context} '{rate}': {', '.join(undefined_vars)}. \"\n                    f\"Available parameters: \"\n                    f\"{', '.join(sorted(param_ids)) if param_ids else 'none'}. \"\n                    f\"Available bins: \"\n                    f\"{', '.join(sorted(bin_ids)) if bin_ids else 'none'}.\"\n                )\n            )\n\n    @model_validator(mode=\"after\")\n    def validate_transition_ids(self) -&gt; Self:\n        \"\"\"\n        Validates that transition ids (source/target) are consistent in type\n        and match the defined Bin IDs or Stratification Categories\n        in the Population instance.\n        \"\"\"\n\n        bin_ids = {bin_item.id for bin_item in self.population.bins}\n        categories_ids = {\n            cat for strat in self.population.stratifications for cat in strat.categories\n        }\n        bin_and_categories_ids = bin_ids.union(categories_ids)\n\n        for transition in self.dynamics.transitions:\n            source = set(transition.source)\n            target = set(transition.target)\n            transition_ids = source.union(target)\n\n            if not transition_ids.issubset(bin_and_categories_ids):\n                invalid_ids = transition_ids - bin_and_categories_ids\n                raise ValueError(\n                    (\n                        f\"Transition '{transition.id}' contains invalid ids: \"\n                        f\"{invalid_ids}. Ids must be defined in Bin ids \"\n                        f\"or Stratification Categories.\"\n                    )\n                )\n\n            is_bin_flow = transition_ids.issubset(bin_ids)\n            is_stratification_flow = transition_ids.issubset(categories_ids)\n\n            if (not is_bin_flow) and (not is_stratification_flow):\n                bin_elements = transition_ids.intersection(bin_ids)\n                categories_elements = transition_ids.intersection(categories_ids)\n                raise ValueError(\n                    (\n                        f\"Transition '{transition.id}' mixes id types. \"\n                        f\"Found Bin ids ({bin_elements}) and \"\n                        f\"Stratification Categories ids ({categories_elements}). \"\n                        \"Transitions must be purely Bin flow or purely \"\n                        f\"Stratification flow.\"\n                    )\n                )\n\n            if is_stratification_flow:\n                category_to_stratification_map = {\n                    cat: strat.id\n                    for strat in self.population.stratifications\n                    for cat in strat.categories\n                }\n                parent_stratification_ids = {\n                    category_to_stratification_map[cat_id] for cat_id in transition_ids\n                }\n                if len(parent_stratification_ids) &gt; 1:\n                    mixed_strats = \", \".join(parent_stratification_ids)\n                    raise ValueError(\n                        (\n                            f\"Transition '{transition.id}' is a Stratification flow \"\n                            f\"but involves categories from multiple stratifications: \"\n                            f\"{mixed_strats}. A single transition must only move \"\n                            f\"between categories belonging to the same parent \"\n                            f\"stratification.\"\n                        )\n                    )\n\n        return self\n\n    def print_equations(self, output_file: str | None = None) -&gt; None:\n        \"\"\"\n        Prints the equations of the model in mathematical form.\n\n        Displays model metadata and the system of equations in both\n        compact (mathematical notation) and expanded (individual equations) forms.\n\n        For DifferentialEquations models, displays equations as dX/dt = ...\n        For DifferenceEquations models,\n        displays equations as [X(t+Dt) - X(t)] / Dt = ...\n\n        Parameters\n        ----------\n        output_file : str | None\n            If provided, writes the equations to this file path instead of printing\n            to console. If None, prints to console.\n        \"\"\"\n\n        lines = self._generate_model_header()\n\n        # Always generate both compact and expanded forms\n        lines.extend(self._generate_compact_form())\n        lines.append(\"\")\n        lines.extend(self._generate_expanded_form())\n\n        output = \"\\n\".join(lines)\n        self._write_output(output, output_file)\n\n    def _generate_model_header(self) -&gt; list[str]:\n        \"\"\"Generate the header lines with model metadata.\"\"\"\n        lines: list[str] = []\n        lines.append(\"=\" * 40)\n        lines.append(\"MODEL INFORMATION\")\n        lines.append(\"=\" * 40)\n        lines.append(f\"Model: {self.name}\")\n        lines.append(f\"Model Type: {self.dynamics.typology}\")\n        lines.append(f\"Number of Bins: {len(self.population.bins)}\")\n        lines.append(\n            f\"Number of Stratifications: {len(self.population.stratifications)}\"\n        )\n        lines.append(f\"Number of Parameters: {len(self.parameters)}\")\n        lines.append(f\"Number of Transitions: {len(self.dynamics.transitions)}\")\n\n        # List bins\n        bin_ids = [bin_item.id for bin_item in self.population.bins]\n        lines.append(f\"Bins: {', '.join(bin_ids)}\")\n\n        # List stratifications\n        if self.population.stratifications:\n            lines.append(\"Stratifications:\")\n            for strat in self.population.stratifications:\n                categories = \", \".join(strat.categories)\n                lines.append(f\"  - {strat.id}: [{categories}]\")\n\n        lines.append(\"\")\n        return lines\n\n    def _collect_bin_and_category_ids(self) -&gt; set[str]:\n        \"\"\"Collect all IDs from bins and stratification categories.\"\"\"\n        all_ids = {bin_item.id for bin_item in self.population.bins}\n        for strat in self.population.stratifications:\n            all_ids.update(strat.categories)\n        return all_ids\n\n    def _build_flow_equations(\n        self, bin_and_category_ids: set[str]\n    ) -&gt; dict[str, dict[str, list[str]]]:\n        \"\"\"Build a mapping of bins and categories to their inflows and outflows.\"\"\"\n        equations: dict[str, dict[str, list[str]]] = {\n            id_: {\"inflows\": [], \"outflows\": []} for id_ in bin_and_category_ids\n        }\n        for transition in self.dynamics.transitions:\n            rate = transition.rate if transition.rate else \"\"\n            source_counts = {\n                state: transition.source.count(state)\n                for state in set(transition.source)\n            }\n            target_counts = {\n                state: transition.target.count(state)\n                for state in set(transition.target)\n            }\n            all_states = set(transition.source) | set(transition.target)\n            for state in all_states:\n                net_change = target_counts.get(state, 0) - source_counts.get(state, 0)\n                if net_change &gt; 0:\n                    equations[state][\"inflows\"].append(rate)\n                elif net_change &lt; 0:\n                    equations[state][\"outflows\"].append(rate)\n\n        return equations\n\n    def _format_bin_equation(self, flows: dict[str, list[str]]) -&gt; str:\n        \"\"\"Format the equation for a single bin or category from its flows.\"\"\"\n        terms: list[str] = []\n\n        for inflow in flows[\"inflows\"]:\n            if inflow:  # Only add if not empty\n                terms.append(f\"+ ({inflow})\")\n\n        for outflow in flows[\"outflows\"]:\n            if outflow:  # Only add if not empty\n                terms.append(f\"- ({outflow})\")\n\n        if not terms:\n            return \"0\"\n\n        result = \" \".join(terms)\n        # Remove leading + sign and space if present\n        if result.startswith(\"+ \"):\n            result = result[2:]\n        return result\n\n    def _generate_compact_form(self) -&gt; list[str]:\n        \"\"\"Generate compact mathematical notation form for stratified models.\"\"\"\n        lines: list[str] = []\n        lines.append(\"=\" * 40)\n        lines.append(\"COMPACT FORM\")\n        lines.append(\"=\" * 40)\n        lines.append(\"\")\n\n        bin_ids = [bin_item.id for bin_item in self.population.bins]\n        bin_transitions, stratification_transitions = (\n            self._separate_transitions_by_type()\n        )\n\n        compartments = self._generate_compartments()\n\n        lines.extend(\n            self._format_bin_transitions_compact_stratified(\n                bin_transitions, compartments\n            )\n        )\n        lines.extend(\n            self._format_stratification_transitions_compact_stratified(\n                stratification_transitions, bin_ids\n            )\n        )\n        lines.extend(self._format_total_system_size(bin_ids))\n\n        return lines\n\n    def _generate_compartments(self) -&gt; list[tuple[str, ...]]:\n        \"\"\"\n        Generate all compartment combinations from bins and stratifications.\n        \"\"\"\n        bin_ids = [state.id for state in self.population.bins]\n\n        if not self.population.stratifications:\n            return [(state,) for state in bin_ids]\n\n        strat_categories = [\n            strat.categories for strat in self.population.stratifications\n        ]\n\n        compartments: list[tuple[str, ...]] = []\n        for bin_id in bin_ids:\n            for strat_combo in product(*strat_categories):\n                compartments.append((bin_id,) + strat_combo)\n\n        return compartments\n\n    def _compartment_to_string(self, compartment: tuple[str, ...]) -&gt; str:\n        \"\"\"Convert compartment tuple to string like 'S_young_urban'.\"\"\"\n        return \"_\".join(compartment)\n\n    def _get_rate_for_compartment(\n        self, transition: Transition, compartment: tuple[str, ...]\n    ) -&gt; str | None:\n        \"\"\"Get the appropriate rate for a compartment, considering stratified rates.\"\"\"\n        if not transition.stratified_rates or len(compartment) == 1:\n            return transition.rate\n\n        compartment_strat_map: dict[str, str] = {}\n        for i, strat in enumerate(self.population.stratifications):\n            compartment_strat_map[strat.id] = compartment[i + 1]\n\n        for strat_rate in transition.stratified_rates:\n            matches = True\n            for condition in strat_rate.conditions:\n                if (\n                    compartment_strat_map.get(condition.stratification)\n                    != condition.category\n                ):\n                    matches = False\n                    break\n            if matches:\n                return strat_rate.rate\n\n        # No stratified rate matched, use fallback\n        return transition.rate\n\n    def _separate_transitions_by_type(\n        self,\n    ) -&gt; tuple[list[Transition], list[Transition]]:\n        \"\"\"Separate transitions into bin and stratification types.\"\"\"\n        bin_ids = [bin_item.id for bin_item in self.population.bins]\n        bin_id_set = set(bin_ids)\n\n        bin_transitions: list[Transition] = []\n        stratification_transitions: list[Transition] = []\n\n        for transition in self.dynamics.transitions:\n            transition_ids = set(transition.source) | set(transition.target)\n            if transition_ids.issubset(bin_id_set):\n                bin_transitions.append(transition)\n            else:\n                stratification_transitions.append(transition)\n\n        return bin_transitions, stratification_transitions\n\n    def _format_stratification_transitions_compact(\n        self, bin_ids: list[str], stratification_transitions: list[Transition]\n    ) -&gt; list[str]:\n        \"\"\"Format stratification transitions in compact form.\"\"\"\n        lines: list[str] = []\n        strat_by_id = self._group_transitions_by_stratification(\n            stratification_transitions\n        )\n\n        for strat in self.population.stratifications:\n            if strat_by_id[strat.id]:\n                lines.append(f\"Stratification Transitions ({strat.id}):\")\n                disease_states_str = \", \".join(bin_ids)\n                lines.append(f\"For each bin X in {{{disease_states_str}}}:\")\n\n                for category in strat.categories:\n                    equation = self._build_category_equation(\n                        category, strat_by_id[strat.id]\n                    )\n                    if equation:\n                        lhs = self._get_equation_lhs(f\"X_{category}\")\n                        lines.append(f\"  {lhs}: {equation}\")\n\n                lines.append(\"\")\n\n        return lines\n\n    def _group_transitions_by_stratification(\n        self, transitions: list[Transition]\n    ) -&gt; dict[str, list[Transition]]:\n        \"\"\"Group stratification transitions by their stratification ID.\"\"\"\n        strat_by_id: dict[str, list[Transition]] = {}\n        for strat in self.population.stratifications:\n            strat_by_id[strat.id] = []\n            for transition in transitions:\n                transition_states = set(transition.source) | set(transition.target)\n                if transition_states.issubset(set(strat.categories)):\n                    strat_by_id[strat.id].append(transition)\n        return strat_by_id\n\n    def _build_category_equation(\n        self, category: str, transitions: list[Transition]\n    ) -&gt; str:\n        \"\"\"Build equation for a stratification category.\"\"\"\n        inflows: list[str] = []\n        outflows: list[str] = []\n\n        for transition in transitions:\n            if not transition.rate:\n                continue\n\n            source_count = transition.source.count(category)\n            target_count = transition.target.count(category)\n            net_change = target_count - source_count\n\n            if net_change &gt; 0:\n                inflows.append(f\"+ ({transition.rate} * X)\")\n            elif net_change &lt; 0:\n                outflows.append(f\"- ({transition.rate} * X)\")\n\n        terms = inflows + outflows\n        if not terms:\n            return \"\"\n\n        result = \" \".join(terms)\n        # Remove leading + sign if present\n        if result.startswith(\"+\"):\n            result = result[1:]\n        return result\n\n    def _format_bin_transitions_compact(\n        self, bin_ids: list[str], bin_transitions: list[Transition]\n    ) -&gt; list[str]:\n        \"\"\"Format bin transitions in compact form.\"\"\"\n        lines: list[str] = []\n\n        if not bin_transitions:\n            return lines\n\n        lines.append(\"Bin Transitions:\")\n\n        if self.population.stratifications:\n            all_categories = [\n                cat\n                for strat in self.population.stratifications\n                for cat in strat.categories\n            ]\n            categories_str = \", \".join(all_categories)\n            lines.append(f\"For each stratification s in {{{categories_str}}}:\")\n\n        for bin_id in bin_ids:\n            equation = self._build_bin_equation_from_transitions(\n                bin_id, bin_transitions\n            )\n            if equation:\n                suffix = \"_s\" if self.population.stratifications else \"\"\n                lhs = self._get_equation_lhs(f\"{bin_id}{suffix}\")\n                lines.append(f\"  {lhs}: {equation}\")\n\n        lines.append(\"\")\n        return lines\n\n    def _build_bin_equation_from_transitions(\n        self, bin_id: str, transitions: list[Transition]\n    ) -&gt; str:\n        \"\"\"Build equation for a bin.\"\"\"\n        inflows: list[str] = []\n        outflows: list[str] = []\n\n        for transition in transitions:\n            if not transition.rate:\n                continue\n\n            source_count = transition.source.count(bin_id)\n            target_count = transition.target.count(bin_id)\n            net_change = target_count - source_count\n\n            if net_change &gt; 0:\n                inflows.append(f\"+ ({transition.rate})\")\n            elif net_change &lt; 0:\n                outflows.append(f\"- ({transition.rate})\")\n\n        terms = inflows + outflows\n        if not terms:\n            return \"\"\n\n        result = \" \".join(terms)\n        # Remove leading + sign if present\n        if result.startswith(\"+\"):\n            result = result[1:]\n        return result\n\n    def _format_total_system_size(self, bin_ids: list[str]) -&gt; list[str]:\n        \"\"\"Format the total system size information.\"\"\"\n        lines: list[str] = []\n\n        num_disease_states = len(bin_ids)\n        if not self.population.stratifications:\n            total_equations = num_disease_states\n            lines.append(\n                (\n                    f\"Total System: {total_equations} coupled equations \"\n                    f\"({num_disease_states} bins)\"\n                )\n            )\n            return lines\n\n        num_strat_combinations = 1\n        strat_details: list[str] = []\n        for strat in self.population.stratifications:\n            num_cat = len(strat.categories)\n            num_strat_combinations *= num_cat\n            strat_details.append(f\"{num_cat} {strat.id}\")\n\n        total_equations = num_disease_states * num_strat_combinations\n\n        lines.append(\n            (\n                f\"Total System: {total_equations} coupled equations \"\n                f\"({num_disease_states} bins \u00d7 {' \u00d7 '.join(strat_details)})\"\n            )\n        )\n\n        return lines\n\n    def _format_bin_transitions_compact_stratified(\n        self, bin_transitions: list[Transition], compartments: list[tuple[str, ...]]\n    ) -&gt; list[str]:\n        \"\"\"Format bin transitions showing specific compartments and rates.\"\"\"\n        lines: list[str] = []\n\n        if not bin_transitions:\n            return lines\n\n        lines.append(\"Bin Transitions:\")\n\n        # Check if we have complete units for annotation\n        show_units = self._has_all_units()\n\n        # Cache variable units for efficiency when formatting multiple rates\n        variable_units = self._build_variable_units() if show_units else None\n\n        for transition in bin_transitions:\n            source_bins = transition.source\n            target_bins = transition.target\n\n            source_str = \", \".join(sorted(set(source_bins))) if source_bins else \"none\"\n            target_str = \", \".join(sorted(set(target_bins))) if target_bins else \"none\"\n            lines.append(\n                f\"{transition.id.capitalize()} ({source_str} -&gt; {target_str}):\"\n            )\n\n            # Handle influx transitions (empty source)\n            if not source_bins and target_bins:\n                for compartment in compartments:\n                    bin_id = compartment[0]\n                    if bin_id in target_bins:\n                        target_compartment_str = self._compartment_to_string(\n                            compartment\n                        )\n                        rate = self._get_rate_for_compartment(transition, compartment)\n                        rate_with_unit = self._format_rate_with_unit(\n                            rate, variable_units, show_units\n                        )\n\n                        lines.append(\n                            f\"  none -&gt; {target_compartment_str}: {rate_with_unit}\"\n                        )\n            # Handle normal transitions (source to target)\n            else:\n                for compartment in compartments:\n                    bin_id = compartment[0]\n\n                    if bin_id in source_bins:\n                        source_compartment_str = self._compartment_to_string(\n                            compartment\n                        )\n\n                        if target_bins:\n                            target_bin = target_bins[0]\n                            target_compartment_str = source_compartment_str.replace(\n                                bin_id, target_bin, 1\n                            )\n                        else:\n                            target_compartment_str = \"none\"\n\n                        rate = self._get_rate_for_compartment(transition, compartment)\n                        rate_with_unit = self._format_rate_with_unit(\n                            rate, variable_units, show_units\n                        )\n\n                        lines.append(\n                            f\"  {source_compartment_str} -&gt; \"\n                            f\"{target_compartment_str}: {rate_with_unit}\"\n                        )\n\n            lines.append(\"\")\n\n        return lines\n\n    def _build_stratified_for_each_line(\n        self, bin_ids: list[str], other_strats: list[\"Stratification\"]\n    ) -&gt; str:\n        if other_strats:\n            other_strats_strs = [\n                f\"each {s.id} in {{{', '.join(s.categories)}}}\" for s in other_strats\n            ]\n            return (\n                f\"For each bin X in {{{', '.join(bin_ids)}}} \"\n                f\"and {', '.join(other_strats_strs)}:\"\n            )\n        return f\"For each bin X in {{{', '.join(bin_ids)}}}:\"\n\n    def _build_stratified_transition_line(\n        self,\n        trans: Transition,\n        strat_idx: int,\n        combo: tuple[str, ...],\n        variable_units: dict[str, str] | None = None,\n        show_units: bool = True,\n    ) -&gt; str:\n        \"\"\"\n        Build a transition line for stratification transitions.\n\n        Parameters\n        ----------\n        trans : Transition\n            The transition to format.\n        strat_idx : int\n            Index of the stratification being transitioned.\n        combo : tuple[str, ...]\n            Combination of categories for other stratifications.\n        variable_units : dict[str, str] | None\n            Pre-computed variable units for efficiency.\n        show_units : bool, default=True\n            If True, annotate variables and show final unit.\n            If False, return the plain rate expression.\n\n        Returns\n        -------\n        str\n            Formatted transition line with unit annotation.\n        \"\"\"\n        src_cat = trans.source[0]\n        tgt_cat = trans.target[0]\n\n        source_parts = [\"\"] * len(self.population.stratifications)\n        target_parts = [\"\"] * len(self.population.stratifications)\n        source_parts[strat_idx] = src_cat\n        target_parts[strat_idx] = tgt_cat\n\n        combo_idx = 0\n        for i in range(len(self.population.stratifications)):\n            if i != strat_idx:\n                source_parts[i] = combo[combo_idx]\n                target_parts[i] = combo[combo_idx]\n                combo_idx += 1\n\n        source_comp = f\"X_{'_'.join(source_parts)}\"\n        target_comp = f\"X_{'_'.join(target_parts)}\"\n\n        sample_compartment = (\"X\",) + tuple(source_parts)\n        rate = self._get_rate_for_compartment(trans, sample_compartment)\n\n        # Build the rate expression with variable annotations\n        if show_units and rate and self.population.bins:\n            # Replace X with the first bin id to get a concrete compartment for\n            # annotation\n            first_bin_id = self.population.bins[0].id\n            concrete_compartment = (first_bin_id,) + tuple(source_parts)\n            concrete_comp_str = self._compartment_to_string(concrete_compartment)\n            full_rate_expr = f\"{rate} * {concrete_comp_str}\"\n\n            # Annotate the concrete expression with units\n            annotated_expr = self._annotate_rate_variables(\n                full_rate_expr, variable_units\n            )\n\n            # Replace the concrete compartment back with X (generic bin placeholder)\n            # Handle both simple case and stratified case\n            bin_unit = self.population.bins[0].unit\n            annotated_expr = annotated_expr.replace(\n                f\"{concrete_comp_str}({bin_unit})\", f\"{source_comp}({bin_unit})\"\n            )\n\n            # Get final unit\n            unit = self._get_rate_unit(full_rate_expr, variable_units)\n            unit_str = f\" [{unit}]\" if unit else \"\"\n\n            return f\"  {source_comp} -&gt; {target_comp}: {annotated_expr}{unit_str}\"\n        else:\n            # Fallback without annotations\n            rate_expr = (\n                f\"{rate} * {source_comp}\" if rate else f\"{trans.rate} * {source_comp}\"\n            )\n            return f\"  {source_comp} -&gt; {target_comp}: {rate_expr}\"\n\n    def _format_stratification_transitions_compact_stratified(\n        self,\n        stratification_transitions: list[Transition],\n        bin_ids: list[str],\n    ) -&gt; list[str]:\n        \"\"\"Format stratification transitions showing movements between categories.\"\"\"\n        lines: list[str] = []\n        strat_by_id = self._group_transitions_by_stratification(\n            stratification_transitions\n        )\n\n        # Check if we have complete units for annotation\n        show_units = self._has_all_units()\n\n        # Cache variable units for efficiency when formatting multiple rates\n        variable_units = self._build_variable_units() if show_units else None\n\n        for strat_idx, strat in enumerate(self.population.stratifications):\n            if not strat_by_id.get(strat.id):\n                continue\n\n            transition = strat_by_id[strat.id][0]\n            source_cat = transition.source[0] if transition.source else \"none\"\n            target_cat = transition.target[0] if transition.target else \"none\"\n\n            if not source_cat or not target_cat:\n                continue\n\n            lines.append(\n                (\n                    f\"{strat.id.capitalize()} Stratification Transitions \"\n                    f\"({source_cat} -&gt; {target_cat}):\"\n                )\n            )\n\n            other_strats = [\n                s\n                for i, s in enumerate(self.population.stratifications)\n                if i != strat_idx\n            ]\n\n            lines.append(self._build_stratified_for_each_line(bin_ids, other_strats))\n\n            for trans in strat_by_id[strat.id]:\n                other_cat_combos = (\n                    list(product(*[s.categories for s in other_strats]))\n                    if other_strats\n                    else [()]\n                )\n\n                for combo in other_cat_combos:\n                    lines.append(\n                        self._build_stratified_transition_line(\n                            trans, strat_idx, combo, variable_units, show_units\n                        )\n                    )\n\n            lines.append(\"\")\n\n        return lines\n\n    def _get_equation_lhs(self, variable_name: str) -&gt; str:\n        \"\"\"\n        Get the left-hand side of an equation based on model type.\n\n        Parameters\n        ----------\n        variable_name : str\n            The name of the variable\n\n        Returns\n        -------\n        str\n            The formatted LHS\n        \"\"\"\n        if self.dynamics.typology == ModelTypes.DIFFERENTIAL_EQUATIONS:\n            return f\"d{variable_name}/dt\"\n        else:  # DIFFERENCE_EQUATIONS\n            return f\"[{variable_name}(t+Dt) - {variable_name}(t)] / Dt\"\n\n    def _generate_expanded_form(self) -&gt; list[str]:\n        \"\"\"Generate expanded form with individual equations for each compartment.\"\"\"\n        lines: list[str] = []\n\n        lines.append(\"=\" * 40)\n        lines.append(\"EXPANDED FORM\")\n        lines.append(\"=\" * 40)\n\n        has_stratifications = len(self.population.stratifications) &gt; 0\n\n        if has_stratifications:\n            compartments = self._generate_compartments()\n            bin_transitions, stratification_transitions = (\n                self._separate_transitions_by_type()\n            )\n\n            for compartment in compartments:\n                compartment_str = self._compartment_to_string(compartment)\n                equation = self._build_compartment_equation(\n                    compartment, bin_transitions, stratification_transitions\n                )\n                lhs = self._get_equation_lhs(compartment_str)\n                lines.append(f\"{lhs} = {equation}\")\n        else:\n            bin_and_category_ids = self._collect_bin_and_category_ids()\n            equations = self._build_flow_equations(bin_and_category_ids)\n            bin_ids = [bin_item.id for bin_item in self.population.bins]\n\n            for bin_id in bin_ids:\n                equation = self._format_bin_equation(equations[bin_id])\n                lhs = self._get_equation_lhs(bin_id)\n                lines.append(f\"{lhs} = {equation}\")\n\n        return lines\n\n    def _build_compartment_equation(\n        self,\n        compartment: tuple[str, ...],\n        bin_transitions: list[Transition],\n        stratification_transitions: list[Transition],\n    ) -&gt; str:\n        \"\"\"Build the complete equation for a specific compartment.\"\"\"\n        terms: list[str] = []\n        bin_id = compartment[0]\n\n        for transition in bin_transitions:\n            source_count = transition.source.count(bin_id)\n            target_count = transition.target.count(bin_id)\n            net_change = target_count - source_count\n\n            if net_change != 0:\n                rate = self._get_rate_for_compartment(transition, compartment)\n                if rate:\n                    if net_change &gt; 0:\n                        terms.append(f\"+ ({rate})\")\n                    else:\n                        terms.append(f\"- ({rate})\")\n\n        for transition in stratification_transitions:\n            flow_term = self._get_stratification_flow_for_compartment(\n                compartment, transition\n            )\n            if flow_term:\n                terms.append(flow_term)\n\n        if not terms:\n            return \"0\"\n\n        equation = \" \".join(terms)\n        if equation.startswith(\"+ \"):\n            return equation[2:]\n        if equation.startswith(\"+\"):\n            return equation[1:]\n        return equation\n\n    def _get_stratification_flow_for_compartment(\n        self, compartment: tuple[str, ...], transition: Transition\n    ) -&gt; str | None:\n        \"\"\"Calculate stratification flow term for a compartment.\"\"\"\n        if len(compartment) == 1:\n            return None\n\n        transition_states = set(transition.source) | set(transition.target)\n        target_strat_idx = None\n\n        for i, strat in enumerate(self.population.stratifications):\n            if transition_states.issubset(set(strat.categories)):\n                target_strat_idx = i\n                break\n\n        if target_strat_idx is None:\n            return None\n\n        compartment_category = compartment[target_strat_idx + 1]\n        source_categories = transition.source\n        target_categories = transition.target\n\n        source_count = source_categories.count(compartment_category)\n        target_count = target_categories.count(compartment_category)\n        net_change = target_count - source_count\n\n        if net_change == 0:\n            return None\n\n        rate = self._get_rate_for_compartment(transition, compartment)\n        if not rate:\n            return None\n\n        if net_change &lt; 0:\n            compartment_str = self._compartment_to_string(compartment)\n            return f\"- ({rate} * {compartment_str})\"\n        else:\n            source_category = source_categories[0] if source_categories else None\n            if source_category:\n                source_compartment = list(compartment)\n                source_compartment[target_strat_idx + 1] = source_category\n                source_compartment_str = self._compartment_to_string(\n                    tuple(source_compartment)\n                )\n                return f\"+ ({rate} * {source_compartment_str})\"\n\n        return None\n\n    def _write_output(self, output: str, output_file: str | None) -&gt; None:\n        \"\"\"Write output to file or console.\"\"\"\n        if output_file:\n            with open(output_file, \"w\") as f:\n                _ = f.write(output)\n        else:\n            print(output)\n\n    def check_unit_consistency(self, verbose: bool = False) -&gt; None:\n        \"\"\"\n        Check unit consistency of all equations in the model.\n\n        This method validates that all transition rates have consistent units.\n        It only performs the check if ALL parameters have units specified.\n        If any parameter lacks a unit, the check is skipped.\n\n        For difference equation models, all rates should have units that result in\n        population change rates (e.g., \"person/day\" or \"1/day\" when multiplied by\n        population).\n\n        Parameters\n        ----------\n        verbose : bool, default=False\n            If True, prints a success message when all units are consistent.\n\n        Raises\n        ------\n        UnitConsistencyError\n            If unit inconsistencies are found in any equation.\n        ValueError\n            If the model type doesn't support unit checking.\n\n        Notes\n        -----\n        - Bin variables are assumed to have units of \"person\"\n        - Predefined variables (N, N_young, etc.) have units of \"person\"\n        - Time step variables (t, step) are dimensionless\n        - Mathematical constants (pi, e) are dimensionless\n        \"\"\"\n        self._validate_unit_check_preconditions()\n\n        # Build variable units mapping\n        variable_units = self._build_variable_units()\n\n        # Check each transition and collect errors\n        errors = self._collect_unit_errors(variable_units)\n\n        if errors:\n            error_message = \"Unit consistency check failed:\\n\" + \"\\n\".join(\n                f\"  - {err}\" for err in errors\n            )\n            raise UnitConsistencyError(error_message)\n\n        if verbose:\n            print(\"Unit consistency check passed successfully.\")\n\n    def _validate_unit_check_preconditions(self) -&gt; None:\n        \"\"\"\n        Validate preconditions for unit consistency checking.\n\n        Raises\n        ------\n        UnitConsistencyError\n            If constant parameters are missing units.\n        ValueError\n            If the model type doesn't support unit checking.\n        \"\"\"\n        # Check if all non-formula parameters have units\n        non_formula_params_missing_units = [\n            p\n            for p in self.parameters\n            if p.unit is None and not isinstance(p.value, str)\n        ]\n\n        if non_formula_params_missing_units:\n            param_names = \", \".join([p.id for p in non_formula_params_missing_units])\n            raise UnitConsistencyError(\n                (\n                    f\"Cannot perform unit consistency check. The following constant \"\n                    f\"parameters are missing units: {param_names}. \"\n                    f\"Please specify units for all parameters, or use formulas \"\n                    f\"to allow automatic unit inference.\"\n                )\n            )\n\n        if self.dynamics.typology != ModelTypes.DIFFERENCE_EQUATIONS:\n            raise ValueError(\n                (\n                    f\"Unit checking is only supported for DifferenceEquations models. \"\n                    f\"Current model type: {self.dynamics.typology}\"\n                )\n            )\n\n    def _collect_unit_errors(self, variable_units: dict[str, str]) -&gt; list[str]:\n        \"\"\"\n        Collect unit consistency errors from all transitions.\n\n        Parameters\n        ----------\n        variable_units : dict[str, str]\n            Mapping of variable names to their units.\n\n        Returns\n        -------\n        list[str]\n            List of error messages for inconsistent units.\n        \"\"\"\n        errors: list[str] = []\n\n        for transition in self.dynamics.transitions:\n            # Check main rate\n            if transition.rate:\n                is_consistent, error_msg = self._check_transition_rate_units(\n                    transition.rate,\n                    transition.id,\n                    variable_units,\n                )\n                if not is_consistent and error_msg:\n                    errors.append(error_msg)\n\n            # Check stratified rates\n            if transition.stratified_rates:\n                for idx, strat_rate in enumerate(transition.stratified_rates):\n                    is_consistent, error_msg = self._check_transition_rate_units(\n                        strat_rate.rate,\n                        f\"{transition.id} (stratified rate {idx + 1})\",\n                        variable_units,\n                    )\n                    if not is_consistent and error_msg:\n                        errors.append(error_msg)\n\n        return errors\n\n    def _build_variable_units(self) -&gt; dict[str, str]:\n        \"\"\"Build a mapping of all variables to their units.\"\"\"\n        variable_units: dict[str, str] = {}\n\n        # Add base units for parameters, bins, and special variables\n        self._add_base_variable_units(variable_units)\n\n        # Infer units for formula parameters\n        self._infer_formula_parameter_units(variable_units)\n\n        return variable_units\n\n    def _add_base_variable_units(self, variable_units: dict[str, str]) -&gt; None:\n        \"\"\"Add units for parameters, bins, categories, and special variables.\"\"\"\n        self._add_parameter_units(variable_units)\n        self._add_bin_units(variable_units)\n        self._add_stratification_category_units(variable_units)\n        self._add_compartment_units(variable_units)\n        self._add_predefined_variable_units(variable_units)\n        self._add_special_variable_units(variable_units)\n\n    def _add_parameter_units(self, variable_units: dict[str, str]) -&gt; None:\n        \"\"\"Add units for parameters with explicit units.\"\"\"\n        for param in self.parameters:\n            if param.unit:\n                variable_units[param.id] = param.unit\n\n    def _add_bin_units(self, variable_units: dict[str, str]) -&gt; None:\n        \"\"\"Add units for bins.\"\"\"\n        for state in self.population.bins:\n            if state.unit:\n                variable_units[state.id] = state.unit\n\n    def _add_stratification_category_units(\n        self, variable_units: dict[str, str]\n    ) -&gt; None:\n        \"\"\"Add units for stratification categories (inherit from bins).\"\"\"\n        if not self.population.bins or not self.population.bins[0].unit:\n            return\n\n        bin_unit = self.population.bins[0].unit\n        for strat in self.population.stratifications:\n            for category in strat.categories:\n                variable_units[category] = bin_unit\n\n    def _add_compartment_units(self, variable_units: dict[str, str]) -&gt; None:\n        \"\"\"Add units for compartment combinations (e.g., S_young, I_old).\"\"\"\n        if not self.population.stratifications:\n            return\n\n        compartments = self._generate_compartments()\n        for compartment in compartments:\n            compartment_str = self._compartment_to_string(compartment)\n            bin_id = compartment[0]\n            bin_obj = next((b for b in self.population.bins if b.id == bin_id), None)\n            if bin_obj and bin_obj.unit:\n                variable_units[compartment_str] = bin_obj.unit\n\n    def _add_predefined_variable_units(self, variable_units: dict[str, str]) -&gt; None:\n        \"\"\"Add units for predefined variables (N, N_young, etc.).\"\"\"\n        bin_unit = self.population.bins[0].unit if self.population.bins else None\n        predefined_units = get_predefined_variable_units(\n            self.population.stratifications, bin_unit\n        )\n        variable_units.update(predefined_units)\n\n    def _add_special_variable_units(self, variable_units: dict[str, str]) -&gt; None:\n        \"\"\"Add dimensionless special variables (t, step, pi, e).\"\"\"\n        variable_units[\"step\"] = \"dimensionless\"\n        variable_units[\"t\"] = \"dimensionless\"\n        variable_units[\"pi\"] = \"dimensionless\"\n        variable_units[\"e\"] = \"dimensionless\"\n\n    def _infer_formula_parameter_units(self, variable_units: dict[str, str]) -&gt; None:\n        \"\"\"Infer units for formula parameters through iterative resolution.\"\"\"\n        max_iterations = 10\n        formula_params_without_units: list[Parameter] = []\n\n        for _ in range(max_iterations):\n            inferred_any = self._try_infer_formula_units(\n                variable_units, formula_params_without_units\n            )\n            if not inferred_any:\n                break\n\n        # Validate that all formula parameters have units\n        self._validate_formula_parameter_units(\n            variable_units, formula_params_without_units\n        )\n\n    def _try_infer_formula_units(\n        self,\n        variable_units: dict[str, str],\n        failed_params: list[Parameter],\n    ) -&gt; bool:\n        \"\"\"\n        Try to infer units for one iteration. Returns True if any units were inferred.\n        \"\"\"\n        inferred_any = False\n\n        for param in self.parameters:\n            if param.id in variable_units or not isinstance(param.value, str):\n                continue\n\n            try:\n                if self._infer_single_formula_unit(param, variable_units):\n                    inferred_any = True\n            except Exception:\n                if param not in failed_params:\n                    failed_params.append(param)\n\n        return inferred_any\n\n    def _infer_single_formula_unit(\n        self, param: Parameter, variable_units: dict[str, str]\n    ) -&gt; bool:\n        \"\"\"Infer unit for a single formula parameter. Returns True if successful.\"\"\"\n        if not isinstance(param.value, str):\n            return False\n\n        formula_vars = get_expression_variables(param.value)\n\n        # Check if all variables have units\n        formula_var_units: dict[str, str] = {}\n        for var in formula_vars:\n            if var in variable_units:\n                formula_var_units[var] = variable_units[var]\n            else:\n                return False  # Not all variables have units yet\n\n        # Infer the unit\n        if formula_var_units:\n            from commol.utils.equations import parse_equation_unit\n\n            inferred_unit = parse_equation_unit(param.value, formula_var_units)\n            variable_units[param.id] = str(inferred_unit.units)\n        else:\n            # Formula has no variables (e.g., \"2 * 3\")\n            variable_units[param.id] = \"dimensionless\"\n\n        return True\n\n    def _validate_formula_parameter_units(\n        self,\n        variable_units: dict[str, str],\n        failed_params: list[Parameter],\n    ) -&gt; None:\n        \"\"\"Validate that all formula parameters have units, raise errors if not.\"\"\"\n        for param in failed_params:\n            if param.id not in variable_units:\n                if not isinstance(param.value, str):\n                    raise UnitConsistencyError(\n                        (\n                            f\"Cannot infer unit for parameter '{param.id}'. \"\n                            f\"Parameter value is not a formula string. \"\n                            f\"Please provide an explicit unit for this parameter.\"\n                        )\n                    )\n\n                formula_vars = get_expression_variables(param.value)\n                missing_vars = [v for v in formula_vars if v not in variable_units]\n\n                if missing_vars:\n                    raise UnitConsistencyError(\n                        (\n                            f\"Cannot infer unit for formula parameter '{param.id}'. \"\n                            f\"Formula '{param.value}' references variables without \"\n                            f\"units: {', '.join(missing_vars)}. \"\n                            f\"Please specify units for all referenced parameters or \"\n                            f\"provide an explicit unit for '{param.id}'.\"\n                        )\n                    )\n                else:\n                    raise UnitConsistencyError(\n                        (\n                            f\"Cannot infer unit for formula parameter '{param.id}'. \"\n                            f\"Formula '{param.value}' could not be parsed. \"\n                            f\"Please provide an explicit unit for this parameter.\"\n                        )\n                    )\n\n    def _infer_time_unit(self) -&gt; str | None:\n        \"\"\"\n        Infer the time unit used in the model from parameter units.\n\n        Returns\n        -------\n        str | None\n            The inferred time unit (e.g., \"day\", \"week\", \"month\"), or None if no\n            time unit can be inferred.\n\n        Notes\n        -----\n        This method looks for parameters with units like \"1/time_unit\" or\n        \"quantity/time_unit\" to infer the time unit used throughout the model.\n        \"\"\"\n        from commol.utils.equations import ureg\n\n        for param in self.parameters:\n            if param.unit is None:\n                continue\n\n            try:\n                unit_obj = ureg(param.unit)\n\n                # Check if the unit has a time dimension in the denominator\n                # (e.g., \"1/day\", \"person/week\", \"individual/month\")\n                if \"[time]\" in str(unit_obj.dimensionality):\n                    # Extract the time component\n                    # The dimensionality will be like {[time]: -1, ...}\n                    if unit_obj.dimensionality.get(\"[time]\", 0) &lt; 0:\n                        # Get the time unit by analyzing the unit string\n                        unit_str = str(unit_obj.units)\n\n                        # Common time units to check\n                        time_units = [\n                            \"second\",\n                            \"minute\",\n                            \"hour\",\n                            \"day\",\n                            \"week\",\n                            \"fortnight\",\n                            \"month\",\n                            \"year\",\n                            \"semester\",\n                            \"wk\",\n                            \"mon\",\n                            \"yr\",\n                            \"s\",\n                            \"min\",\n                            \"h\",\n                            \"d\",\n                        ]\n\n                        for time_unit in time_units:\n                            if time_unit in unit_str:\n                                return time_unit\n\n            except Exception:\n                continue\n\n        return None\n\n    def _check_transition_rate_units(\n        self,\n        rate: str,\n        transition_id: str,\n        variable_units: dict[str, str],\n    ) -&gt; tuple[bool, str | None]:\n        \"\"\"\n        Check units for a single transition rate.\n\n        For transitions in difference equations, rates represent the absolute change\n        in population per time step, so they should have units of \"bin_unit/time_unit\"\n        (e.g., \"person/day\", \"individual/week\").\n        \"\"\"\n        # Get variables used in the rate expression\n        variables = get_expression_variables(rate)\n\n        # Build variable units for this specific rate\n        rate_variable_units: dict[str, str] = {}\n        for var in variables:\n            if var in variable_units:\n                rate_variable_units[var] = variable_units[var]\n            else:\n                # Variable not found\n                # This should have been caught by earlier validation\n                return (\n                    False,\n                    (\n                        f\"Transition '{transition_id}': Variable '{var}' in rate \"\n                        f\"'{rate}' has no defined unit\"\n                    ),\n                )\n\n        # Determine the expected unit based on bin_unit and time_unit\n        bin_unit = self.population.bins[0].unit if self.population.bins else \"person\"\n        time_unit = self._infer_time_unit() or \"day\"\n\n        expected_unit = f\"{bin_unit}/{time_unit}\"\n\n        # Check unit consistency\n        is_consistent, error_msg = check_equation_units(\n            rate, rate_variable_units, expected_unit\n        )\n\n        if not is_consistent:\n            return (\n                False,\n                f\"Transition '{transition_id}': {error_msg}\",\n            )\n\n        return (True, None)\n\n    def _get_rate_unit(\n        self, rate: str, variable_units: dict[str, str] | None = None\n    ) -&gt; str | None:\n        \"\"\"\n        Calculate the unit for a transition rate expression.\n\n        Parameters\n        ----------\n        rate : str\n            The rate expression to analyze.\n        variable_units : dict[str, str] | None\n            Pre-computed variable units mapping. If None, will be computed.\n            Providing this parameter improves performance when calling this\n            method multiple times.\n\n        Returns\n        -------\n        str | None\n            The unit of the rate expression, or None if units cannot be determined.\n        \"\"\"\n        try:\n            # Use provided variable units or build them\n            if variable_units is None:\n                variable_units = self._build_variable_units()\n\n            # Get variables used in the rate expression\n            variables = get_expression_variables(rate)\n\n            # Build variable units for this specific rate\n            rate_variable_units: dict[str, str] = {}\n            for var in variables:\n                if var in variable_units:\n                    rate_variable_units[var] = variable_units[var]\n                else:\n                    # Variable not found, cannot determine unit\n                    return None\n\n            # Parse the equation to get its unit\n            from commol.utils.equations import parse_equation_unit\n\n            equation_unit = parse_equation_unit(rate, rate_variable_units)\n            return str(equation_unit.units)\n\n        except Exception:\n            # If any error occurs, return None\n            return None\n\n    def _annotate_rate_variables(\n        self, rate: str, variable_units: dict[str, str] | None = None\n    ) -&gt; str:\n        \"\"\"\n        Annotate variables in a rate expression with their units in parentheses.\n\n        Parameters\n        ----------\n        rate : str\n            The rate expression to annotate.\n        variable_units : dict[str, str] | None\n            Pre-computed variable units mapping for efficiency.\n\n        Returns\n        -------\n        str\n            The rate expression with variables annotated with their units,\n            e.g., \"beta(1/day) * S(person) * I(person) / N(person)\".\n            If units cannot be determined, returns the original rate.\n        \"\"\"\n        if not rate:\n            return rate\n\n        try:\n            # Use provided variable units or build them\n            if variable_units is None:\n                variable_units = self._build_variable_units()\n\n            # Get variables used in the rate expression\n            variables = get_expression_variables(rate)\n\n            # Build a mapping of variable -&gt; annotated version\n            annotated_rate = rate\n            # Sort by length descending to avoid partial replacements\n            # (e.g., replace \"beta_young\" before \"beta\")\n            for var in sorted(variables, key=len, reverse=True):\n                if var in variable_units:\n                    unit = variable_units[var]\n                    # Replace the variable with annotated version\n                    # Use word boundaries to avoid partial matches\n                    import re\n\n                    pattern = r\"\\b\" + re.escape(var) + r\"\\b\"\n                    replacement = f\"{var}({unit})\"\n                    annotated_rate = re.sub(pattern, replacement, annotated_rate)\n\n            return annotated_rate\n\n        except Exception:\n            # If any error occurs, return original rate\n            return rate\n\n    def _has_all_units(self) -&gt; bool:\n        \"\"\"\n        Check if all units are defined. Raises error if partial units.\n\n        Returns\n        -------\n        bool\n            True if all units defined, False if no units defined.\n\n        Raises\n        ------\n        ValueError\n            If units are partially defined.\n        \"\"\"\n        has_any_bin_unit = any(b.unit for b in self.population.bins)\n        has_any_param_unit = any(\n            p.unit for p in self.parameters if not isinstance(p.value, str)\n        )\n\n        if not has_any_bin_unit and not has_any_param_unit:\n            return False\n\n        # If any units exist, all must be defined\n        if not all(b.unit for b in self.population.bins):\n            raise ValueError(\"Some bins have units but not all\")\n        if any(p.unit is None for p in self.parameters if not isinstance(p.value, str)):\n            raise ValueError(\"Some parameters have units but not all\")\n\n        return True\n\n    def _format_rate_with_unit(\n        self,\n        rate: str | None,\n        variable_units: dict[str, str] | None = None,\n        show_units: bool = True,\n    ) -&gt; str:\n        \"\"\"\n        Format a rate expression with variable units and final unit annotation.\n\n        Parameters\n        ----------\n        rate : str | None\n            The rate expression to format.\n        variable_units : dict[str, str] | None\n            Pre-computed variable units mapping for efficiency.\n        show_units : bool, default=True\n            If True, annotate variables and show final unit.\n            If False, return the plain rate expression.\n\n        Returns\n        -------\n        str\n            The formatted rate string with variables annotated and final unit,\n            e.g., \"beta(1/day) * S(person) * I(person) / N(person) [person / day]\".\n            Returns \"None\" if rate is None.\n        \"\"\"\n        if not rate:\n            return \"None\"\n\n        if not show_units:\n            return rate\n\n        # Annotate variables with their units\n        annotated_rate = self._annotate_rate_variables(rate, variable_units)\n\n        # Add final unit\n        unit = self._get_rate_unit(rate, variable_units)\n        unit_suffix = f\" [{unit}]\" if unit else \"\"\n\n        return f\"{annotated_rate}{unit_suffix}\"\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.model.Model.validate_unique_parameter_ids","title":"validate_unique_parameter_ids","text":"<pre><code>validate_unique_parameter_ids() -&gt; Self\n</code></pre> <p>Validates that parameter IDs are unique.</p> Source code in <code>commol/context/model.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_unique_parameter_ids(self) -&gt; Self:\n    \"\"\"\n    Validates that parameter IDs are unique.\n    \"\"\"\n    parameter_ids = [p.id for p in self.parameters]\n    if len(parameter_ids) != len(set(parameter_ids)):\n        duplicates = [\n            item for item in set(parameter_ids) if parameter_ids.count(item) &gt; 1\n        ]\n        raise ValueError(f\"Duplicate parameter IDs found: {duplicates}\")\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.update_parameters","title":"update_parameters","text":"<pre><code>update_parameters(parameter_values: Mapping[str, float | None]) -&gt; None\n</code></pre> <p>Update parameter values in the model.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_values</code> <code>Mapping[str, float | None]</code> <p>Dictionary mapping parameter IDs to their new values.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a parameter ID in the dictionary doesn't exist in the model.</p> Source code in <code>commol/context/model.py</code> <pre><code>def update_parameters(self, parameter_values: Mapping[str, float | None]) -&gt; None:\n    \"\"\"\n    Update parameter values in the model.\n\n    Parameters\n    ----------\n    parameter_values : Mapping[str, float | None]\n        Dictionary mapping parameter IDs to their new values.\n\n    Raises\n    ------\n    ValueError\n        If a parameter ID in the dictionary doesn't exist in the model.\n    \"\"\"\n    param_dict = {param.id: param for param in self.parameters}\n\n    for param_id, value in parameter_values.items():\n        if param_id not in param_dict:\n            raise ValueError(\n                (\n                    f\"Parameter '{param_id}' not found in model. \"\n                    f\"Available parameters: {', '.join(param_dict.keys())}\"\n                )\n            )\n        param_dict[param_id].value = value\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.get_uncalibrated_parameters","title":"get_uncalibrated_parameters","text":"<pre><code>get_uncalibrated_parameters() -&gt; list[str]\n</code></pre> <p>Get a list of parameter IDs that have None values (need calibration).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of parameter IDs that require calibration.</p> Source code in <code>commol/context/model.py</code> <pre><code>def get_uncalibrated_parameters(self) -&gt; list[str]:\n    \"\"\"\n    Get a list of parameter IDs that have None values (need calibration).\n\n    Returns\n    -------\n    list[str]\n        List of parameter IDs that require calibration.\n    \"\"\"\n    return [param.id for param in self.parameters if param.value is None]\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.get_uncalibrated_initial_conditions","title":"get_uncalibrated_initial_conditions","text":"<pre><code>get_uncalibrated_initial_conditions() -&gt; list[str]\n</code></pre> <p>Get a list of bin IDs that have None fractions (need calibration).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of bin IDs with uncalibrated initial conditions.</p> Source code in <code>commol/context/model.py</code> <pre><code>def get_uncalibrated_initial_conditions(self) -&gt; list[str]:\n    \"\"\"\n    Get a list of bin IDs that have None fractions (need calibration).\n\n    Returns\n    -------\n    list[str]\n        List of bin IDs with uncalibrated initial conditions.\n    \"\"\"\n    return self.population.initial_conditions.get_uncalibrated_bins()\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.update_initial_conditions","title":"update_initial_conditions","text":"<pre><code>update_initial_conditions(bin_fractions: Mapping[str, float | None]) -&gt; None\n</code></pre> <p>Update initial condition fractions for specified bins.</p> <p>Parameters:</p> Name Type Description Default <code>bin_fractions</code> <code>Mapping[str, float | None]</code> <p>Dictionary mapping bin IDs to their new fraction values.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a bin ID in the dictionary doesn't exist in the model.</p> Source code in <code>commol/context/model.py</code> <pre><code>def update_initial_conditions(\n    self, bin_fractions: Mapping[str, float | None]\n) -&gt; None:\n    \"\"\"\n    Update initial condition fractions for specified bins.\n\n    Parameters\n    ----------\n    bin_fractions : Mapping[str, float | None]\n        Dictionary mapping bin IDs to their new fraction values.\n\n    Raises\n    ------\n    ValueError\n        If a bin ID in the dictionary doesn't exist in the model.\n    \"\"\"\n    self.population.initial_conditions.update_bin_fractions(bin_fractions)\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.validate_formula_variables","title":"validate_formula_variables","text":"<pre><code>validate_formula_variables() -&gt; Self\n</code></pre> <p>Validate that all variables in rate expressions are defined. This is done by gathering all valid identifiers and checking each transition's rate expressions against them.</p> Source code in <code>commol/context/model.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_formula_variables(self) -&gt; Self:\n    \"\"\"\n    Validate that all variables in rate expressions are defined.\n    This is done by gathering all valid identifiers and checking each\n    transition's rate expressions against them.\n    \"\"\"\n    valid_identifiers = self._get_valid_identifiers()\n\n    for transition in self.dynamics.transitions:\n        self._validate_transition_rates(transition, valid_identifiers)\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.validate_transition_ids","title":"validate_transition_ids","text":"<pre><code>validate_transition_ids() -&gt; Self\n</code></pre> <p>Validates that transition ids (source/target) are consistent in type and match the defined Bin IDs or Stratification Categories in the Population instance.</p> Source code in <code>commol/context/model.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_transition_ids(self) -&gt; Self:\n    \"\"\"\n    Validates that transition ids (source/target) are consistent in type\n    and match the defined Bin IDs or Stratification Categories\n    in the Population instance.\n    \"\"\"\n\n    bin_ids = {bin_item.id for bin_item in self.population.bins}\n    categories_ids = {\n        cat for strat in self.population.stratifications for cat in strat.categories\n    }\n    bin_and_categories_ids = bin_ids.union(categories_ids)\n\n    for transition in self.dynamics.transitions:\n        source = set(transition.source)\n        target = set(transition.target)\n        transition_ids = source.union(target)\n\n        if not transition_ids.issubset(bin_and_categories_ids):\n            invalid_ids = transition_ids - bin_and_categories_ids\n            raise ValueError(\n                (\n                    f\"Transition '{transition.id}' contains invalid ids: \"\n                    f\"{invalid_ids}. Ids must be defined in Bin ids \"\n                    f\"or Stratification Categories.\"\n                )\n            )\n\n        is_bin_flow = transition_ids.issubset(bin_ids)\n        is_stratification_flow = transition_ids.issubset(categories_ids)\n\n        if (not is_bin_flow) and (not is_stratification_flow):\n            bin_elements = transition_ids.intersection(bin_ids)\n            categories_elements = transition_ids.intersection(categories_ids)\n            raise ValueError(\n                (\n                    f\"Transition '{transition.id}' mixes id types. \"\n                    f\"Found Bin ids ({bin_elements}) and \"\n                    f\"Stratification Categories ids ({categories_elements}). \"\n                    \"Transitions must be purely Bin flow or purely \"\n                    f\"Stratification flow.\"\n                )\n            )\n\n        if is_stratification_flow:\n            category_to_stratification_map = {\n                cat: strat.id\n                for strat in self.population.stratifications\n                for cat in strat.categories\n            }\n            parent_stratification_ids = {\n                category_to_stratification_map[cat_id] for cat_id in transition_ids\n            }\n            if len(parent_stratification_ids) &gt; 1:\n                mixed_strats = \", \".join(parent_stratification_ids)\n                raise ValueError(\n                    (\n                        f\"Transition '{transition.id}' is a Stratification flow \"\n                        f\"but involves categories from multiple stratifications: \"\n                        f\"{mixed_strats}. A single transition must only move \"\n                        f\"between categories belonging to the same parent \"\n                        f\"stratification.\"\n                    )\n                )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.print_equations","title":"print_equations","text":"<pre><code>print_equations(output_file: str | None = None) -&gt; None\n</code></pre> <p>Prints the equations of the model in mathematical form.</p> <p>Displays model metadata and the system of equations in both compact (mathematical notation) and expanded (individual equations) forms.</p> <p>For DifferentialEquations models, displays equations as dX/dt = ... For DifferenceEquations models, displays equations as [X(t+Dt) - X(t)] / Dt = ...</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>str | None</code> <p>If provided, writes the equations to this file path instead of printing to console. If None, prints to console.</p> <code>None</code> Source code in <code>commol/context/model.py</code> <pre><code>def print_equations(self, output_file: str | None = None) -&gt; None:\n    \"\"\"\n    Prints the equations of the model in mathematical form.\n\n    Displays model metadata and the system of equations in both\n    compact (mathematical notation) and expanded (individual equations) forms.\n\n    For DifferentialEquations models, displays equations as dX/dt = ...\n    For DifferenceEquations models,\n    displays equations as [X(t+Dt) - X(t)] / Dt = ...\n\n    Parameters\n    ----------\n    output_file : str | None\n        If provided, writes the equations to this file path instead of printing\n        to console. If None, prints to console.\n    \"\"\"\n\n    lines = self._generate_model_header()\n\n    # Always generate both compact and expanded forms\n    lines.extend(self._generate_compact_form())\n    lines.append(\"\")\n    lines.extend(self._generate_expanded_form())\n\n    output = \"\\n\".join(lines)\n    self._write_output(output, output_file)\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.check_unit_consistency","title":"check_unit_consistency","text":"<pre><code>check_unit_consistency(verbose: bool = False) -&gt; None\n</code></pre> <p>Check unit consistency of all equations in the model.</p> <p>This method validates that all transition rates have consistent units. It only performs the check if ALL parameters have units specified. If any parameter lacks a unit, the check is skipped.</p> <p>For difference equation models, all rates should have units that result in population change rates (e.g., \"person/day\" or \"1/day\" when multiplied by population).</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, prints a success message when all units are consistent.</p> <code>False</code> <p>Raises:</p> Type Description <code>UnitConsistencyError</code> <p>If unit inconsistencies are found in any equation.</p> <code>ValueError</code> <p>If the model type doesn't support unit checking.</p> Notes <ul> <li>Bin variables are assumed to have units of \"person\"</li> <li>Predefined variables (N, N_young, etc.) have units of \"person\"</li> <li>Time step variables (t, step) are dimensionless</li> <li>Mathematical constants (pi, e) are dimensionless</li> </ul> Source code in <code>commol/context/model.py</code> <pre><code>def check_unit_consistency(self, verbose: bool = False) -&gt; None:\n    \"\"\"\n    Check unit consistency of all equations in the model.\n\n    This method validates that all transition rates have consistent units.\n    It only performs the check if ALL parameters have units specified.\n    If any parameter lacks a unit, the check is skipped.\n\n    For difference equation models, all rates should have units that result in\n    population change rates (e.g., \"person/day\" or \"1/day\" when multiplied by\n    population).\n\n    Parameters\n    ----------\n    verbose : bool, default=False\n        If True, prints a success message when all units are consistent.\n\n    Raises\n    ------\n    UnitConsistencyError\n        If unit inconsistencies are found in any equation.\n    ValueError\n        If the model type doesn't support unit checking.\n\n    Notes\n    -----\n    - Bin variables are assumed to have units of \"person\"\n    - Predefined variables (N, N_young, etc.) have units of \"person\"\n    - Time step variables (t, step) are dimensionless\n    - Mathematical constants (pi, e) are dimensionless\n    \"\"\"\n    self._validate_unit_check_preconditions()\n\n    # Build variable units mapping\n    variable_units = self._build_variable_units()\n\n    # Check each transition and collect errors\n    errors = self._collect_unit_errors(variable_units)\n\n    if errors:\n        error_message = \"Unit consistency check failed:\\n\" + \"\\n\".join(\n            f\"  - {err}\" for err in errors\n        )\n        raise UnitConsistencyError(error_message)\n\n    if verbose:\n        print(\"Unit consistency check passed successfully.\")\n</code></pre>"},{"location":"advanced/model-structure/#population","title":"Population","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.population.Population","title":"Population","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the compartments, stratifications, and initial conditions of the population.</p> <p>Attributes:</p> Name Type Description <code>disease_states</code> <code>list[Bin]</code> <p>A list of compartments or states that make up the model.</p> <code>stratifications</code> <code>list[Stratification]</code> <p>A list of categorical subdivisions of the population.</p> <code>initial_conditions</code> <code>Initialization</code> <p>Initial state of the subpopulations and stratifications.</p> Source code in <code>commol/context/population.py</code> <pre><code>class Population(BaseModel):\n    \"\"\"\n    Defines the compartments, stratifications, and initial conditions of the population.\n\n    Attributes\n    ----------\n    disease_states : list[Bin]\n        A list of compartments or states that make up the model.\n    stratifications : list[Stratification]\n        A list of categorical subdivisions of the population.\n    initial_conditions: Initialization\n        Initial state of the subpopulations and stratifications.\n    \"\"\"\n\n    bins: list[Bin]\n    stratifications: list[Stratification]\n    transitions: list[Transition]\n    initial_conditions: InitialConditions\n\n    @field_validator(\"bins\")\n    @classmethod\n    def validate_bins_not_empty(cls, v: list[Bin]) -&gt; list[Bin]:\n        if not v:\n            raise ValueError(\"At least one bin must be defined.\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_unique_ids(self) -&gt; Self:\n        \"\"\"\n        Validates that bin and stratification IDs are unique.\n        \"\"\"\n        bin_ids = [ds.id for ds in self.bins]\n        if len(bin_ids) != len(set(bin_ids)):\n            duplicates = [item for item in set(bin_ids) if bin_ids.count(item) &gt; 1]\n            raise ValueError(f\"Duplicate bin IDs found: {duplicates}\")\n\n        stratification_ids = [s.id for s in self.stratifications]\n        if len(stratification_ids) != len(set(stratification_ids)):\n            duplicates = [\n                item\n                for item in set(stratification_ids)\n                if stratification_ids.count(item) &gt; 1\n            ]\n            raise ValueError(f\"Duplicate stratification IDs found: {duplicates}\")\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_bin_initial_conditions(self) -&gt; Self:\n        \"\"\"\n        Validates initial conditions against the defined model bins.\n        \"\"\"\n        initial_conditions = self.initial_conditions\n\n        bins_map = {bin_item.id: bin_item for bin_item in self.bins}\n\n        bin_fractions_dict = {\n            bf.bin: bf.fraction for bf in initial_conditions.bin_fractions\n        }\n\n        actual_bins = set(bin_fractions_dict.keys())\n        expected_bins = set(bins_map.keys())\n\n        if actual_bins != expected_bins:\n            missing = expected_bins - actual_bins\n            extra = actual_bins - expected_bins\n            raise ValueError(\n                (\n                    f\"Initial bin fractions keys must exactly match \"\n                    f\"bin ids. Missing ids: {missing}, Extra ids: {extra}.\"\n                )\n            )\n\n        # Only validate sum if all fractions are calibrated (not None)\n        # The InitialConditions validator handles the None case\n        if all(frac is not None for frac in bin_fractions_dict.values()):\n            # Filter out None values before summing (type checker requirement)\n            calibrated_fractions = [\n                f for f in bin_fractions_dict.values() if f is not None\n            ]\n            bins_sum_fractions = sum(calibrated_fractions)\n            if not math.isclose(bins_sum_fractions, 1.0, abs_tol=1e-6):\n                raise ValueError(\n                    f\"Bin fractions must sum to 1.0, but got {bins_sum_fractions:.7f}.\"\n                )\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_stratified_rates(self) -&gt; Self:\n        \"\"\"\n        Validates that stratified rates reference existing stratifications and\n        categories.\n        \"\"\"\n        strat_map = {strat.id: strat for strat in self.stratifications}\n\n        for transition in self.transitions:\n            if transition.stratified_rates:\n                for idx, stratified_rate in enumerate(transition.stratified_rates):\n                    for condition in stratified_rate.conditions:\n                        # Validate stratification exists\n                        if condition.stratification not in strat_map:\n                            raise ValueError(\n                                (\n                                    f\"In transition '{transition.id}', stratified rate \"\n                                    f\"{idx}: Stratification \"\n                                    f\"'{condition.stratification}' not found. \"\n                                    f\"Available: {list(strat_map.keys())}\"\n                                )\n                            )\n\n                        # Validate category exists\n                        strat = strat_map[condition.stratification]\n                        if condition.category not in strat.categories:\n                            raise ValueError(\n                                (\n                                    f\"In transition '{transition.id}', stratified rate \"\n                                    f\"{idx}: Category '{condition.category}' not found \"\n                                    f\"in stratification '{condition.stratification}'. \"\n                                    f\"Available: {strat.categories}\"\n                                )\n                            )\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_stratification_initial_conditions(self) -&gt; Self:\n        \"\"\"\n        Validates initial conditions against the defined model Stratification.\n        \"\"\"\n        initial_conditions = self.initial_conditions\n\n        strat_map = {strat.id: strat for strat in self.stratifications}\n\n        actual_strat = {\n            sf.stratification for sf in initial_conditions.stratification_fractions\n        }\n        expected_strat = set(strat_map.keys())\n\n        if actual_strat != expected_strat:\n            missing = expected_strat - actual_strat\n            extra = actual_strat - expected_strat\n            raise ValueError(\n                (\n                    f\"Initial stratification fractions keys must exactly match \"\n                    f\"stratification ids. Missing ids: {missing}, Extra ids: {extra}.\"\n                )\n            )\n\n        for strat_fractions in initial_conditions.stratification_fractions:\n            strat_id = strat_fractions.stratification\n            strat_instance = strat_map[strat_id]\n\n            fractions_dict = {\n                sf.category: sf.fraction for sf in strat_fractions.fractions\n            }\n\n            categories_expected = set(strat_instance.categories)\n            categories_actual = set(fractions_dict.keys())\n\n            if categories_actual != categories_expected:\n                missing = categories_expected - categories_actual\n                extra = categories_actual - categories_expected\n                raise ValueError(\n                    (\n                        f\"Categories for stratification '{strat_id}' must exactly \"\n                        f\"match defined categories in instance '{strat_instance.id}'. \"\n                        f\"Missing categories: {missing}, Extra categories: {extra}.\"\n                    )\n                )\n\n            strat_sum_fractions = sum(fractions_dict.values())\n            if not math.isclose(strat_sum_fractions, 1.0, abs_tol=1e-6):\n                raise ValueError(\n                    (\n                        f\"Stratification fractions for '{strat_id}' must sum to 1.0, \"\n                        f\"but got {strat_sum_fractions:.7}.\"\n                    )\n                )\n\n        return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.population.Population-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.population.Population.validate_unique_ids","title":"validate_unique_ids","text":"<pre><code>validate_unique_ids() -&gt; Self\n</code></pre> <p>Validates that bin and stratification IDs are unique.</p> Source code in <code>commol/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_unique_ids(self) -&gt; Self:\n    \"\"\"\n    Validates that bin and stratification IDs are unique.\n    \"\"\"\n    bin_ids = [ds.id for ds in self.bins]\n    if len(bin_ids) != len(set(bin_ids)):\n        duplicates = [item for item in set(bin_ids) if bin_ids.count(item) &gt; 1]\n        raise ValueError(f\"Duplicate bin IDs found: {duplicates}\")\n\n    stratification_ids = [s.id for s in self.stratifications]\n    if len(stratification_ids) != len(set(stratification_ids)):\n        duplicates = [\n            item\n            for item in set(stratification_ids)\n            if stratification_ids.count(item) &gt; 1\n        ]\n        raise ValueError(f\"Duplicate stratification IDs found: {duplicates}\")\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.population.Population.validate_bin_initial_conditions","title":"validate_bin_initial_conditions","text":"<pre><code>validate_bin_initial_conditions() -&gt; Self\n</code></pre> <p>Validates initial conditions against the defined model bins.</p> Source code in <code>commol/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_bin_initial_conditions(self) -&gt; Self:\n    \"\"\"\n    Validates initial conditions against the defined model bins.\n    \"\"\"\n    initial_conditions = self.initial_conditions\n\n    bins_map = {bin_item.id: bin_item for bin_item in self.bins}\n\n    bin_fractions_dict = {\n        bf.bin: bf.fraction for bf in initial_conditions.bin_fractions\n    }\n\n    actual_bins = set(bin_fractions_dict.keys())\n    expected_bins = set(bins_map.keys())\n\n    if actual_bins != expected_bins:\n        missing = expected_bins - actual_bins\n        extra = actual_bins - expected_bins\n        raise ValueError(\n            (\n                f\"Initial bin fractions keys must exactly match \"\n                f\"bin ids. Missing ids: {missing}, Extra ids: {extra}.\"\n            )\n        )\n\n    # Only validate sum if all fractions are calibrated (not None)\n    # The InitialConditions validator handles the None case\n    if all(frac is not None for frac in bin_fractions_dict.values()):\n        # Filter out None values before summing (type checker requirement)\n        calibrated_fractions = [\n            f for f in bin_fractions_dict.values() if f is not None\n        ]\n        bins_sum_fractions = sum(calibrated_fractions)\n        if not math.isclose(bins_sum_fractions, 1.0, abs_tol=1e-6):\n            raise ValueError(\n                f\"Bin fractions must sum to 1.0, but got {bins_sum_fractions:.7f}.\"\n            )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.population.Population.validate_stratified_rates","title":"validate_stratified_rates","text":"<pre><code>validate_stratified_rates() -&gt; Self\n</code></pre> <p>Validates that stratified rates reference existing stratifications and categories.</p> Source code in <code>commol/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_stratified_rates(self) -&gt; Self:\n    \"\"\"\n    Validates that stratified rates reference existing stratifications and\n    categories.\n    \"\"\"\n    strat_map = {strat.id: strat for strat in self.stratifications}\n\n    for transition in self.transitions:\n        if transition.stratified_rates:\n            for idx, stratified_rate in enumerate(transition.stratified_rates):\n                for condition in stratified_rate.conditions:\n                    # Validate stratification exists\n                    if condition.stratification not in strat_map:\n                        raise ValueError(\n                            (\n                                f\"In transition '{transition.id}', stratified rate \"\n                                f\"{idx}: Stratification \"\n                                f\"'{condition.stratification}' not found. \"\n                                f\"Available: {list(strat_map.keys())}\"\n                            )\n                        )\n\n                    # Validate category exists\n                    strat = strat_map[condition.stratification]\n                    if condition.category not in strat.categories:\n                        raise ValueError(\n                            (\n                                f\"In transition '{transition.id}', stratified rate \"\n                                f\"{idx}: Category '{condition.category}' not found \"\n                                f\"in stratification '{condition.stratification}'. \"\n                                f\"Available: {strat.categories}\"\n                            )\n                        )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.population.Population.validate_stratification_initial_conditions","title":"validate_stratification_initial_conditions","text":"<pre><code>validate_stratification_initial_conditions() -&gt; Self\n</code></pre> <p>Validates initial conditions against the defined model Stratification.</p> Source code in <code>commol/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_stratification_initial_conditions(self) -&gt; Self:\n    \"\"\"\n    Validates initial conditions against the defined model Stratification.\n    \"\"\"\n    initial_conditions = self.initial_conditions\n\n    strat_map = {strat.id: strat for strat in self.stratifications}\n\n    actual_strat = {\n        sf.stratification for sf in initial_conditions.stratification_fractions\n    }\n    expected_strat = set(strat_map.keys())\n\n    if actual_strat != expected_strat:\n        missing = expected_strat - actual_strat\n        extra = actual_strat - expected_strat\n        raise ValueError(\n            (\n                f\"Initial stratification fractions keys must exactly match \"\n                f\"stratification ids. Missing ids: {missing}, Extra ids: {extra}.\"\n            )\n        )\n\n    for strat_fractions in initial_conditions.stratification_fractions:\n        strat_id = strat_fractions.stratification\n        strat_instance = strat_map[strat_id]\n\n        fractions_dict = {\n            sf.category: sf.fraction for sf in strat_fractions.fractions\n        }\n\n        categories_expected = set(strat_instance.categories)\n        categories_actual = set(fractions_dict.keys())\n\n        if categories_actual != categories_expected:\n            missing = categories_expected - categories_actual\n            extra = categories_actual - categories_expected\n            raise ValueError(\n                (\n                    f\"Categories for stratification '{strat_id}' must exactly \"\n                    f\"match defined categories in instance '{strat_instance.id}'. \"\n                    f\"Missing categories: {missing}, Extra categories: {extra}.\"\n                )\n            )\n\n        strat_sum_fractions = sum(fractions_dict.values())\n        if not math.isclose(strat_sum_fractions, 1.0, abs_tol=1e-6):\n            raise ValueError(\n                (\n                    f\"Stratification fractions for '{strat_id}' must sum to 1.0, \"\n                    f\"but got {strat_sum_fractions:.7}.\"\n                )\n            )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#bins","title":"Bins","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.bin.Bin","title":"Bin","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a single bin (base category) in the compartmental model.</p> <p>A bin represents a fundamental category before stratification. The combination of a bin with all stratifications produces the actual compartments.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Identifier of the bin.</p> <code>name</code> <code>str</code> <p>A descriptive, human-readable name for the bin.</p> <code>unit</code> <code>str | None</code> <p>The unit of measurement for this bin. If None, the bin will use the model-level bin_unit when specified.</p> Source code in <code>commol/context/bin.py</code> <pre><code>class Bin(BaseModel):\n    \"\"\"\n    Defines a single bin (base category) in the compartmental model.\n\n    A bin represents a fundamental category before stratification. The combination\n    of a bin with all stratifications produces the actual compartments.\n\n    Attributes\n    ----------\n    id : str\n        Identifier of the bin.\n    name : str\n        A descriptive, human-readable name for the bin.\n    unit : str | None\n        The unit of measurement for this bin.\n        If None, the bin will use the model-level bin_unit when specified.\n    \"\"\"\n\n    id: str = Field(..., description=\"Identifier of the bin.\")\n    name: str = Field(..., description=\"Descriptive, human-readable name for the bin.\")\n    unit: str | None = Field(\n        None,\n        description=\"Unit of measurement for this bin.\",\n    )\n\n    @override\n    def __hash__(self) -&gt; int:\n        return hash(self.id)\n\n    @override\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Bin) and self.id == other.id\n</code></pre>"},{"location":"advanced/model-structure/#stratifications","title":"Stratifications","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.stratification.Stratification","title":"Stratification","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a categorical subdivision of the population.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Identifier of the stratification.</p> <code>categories</code> <code>list[str]</code> <p>List of the different stratification groups identifiers.</p> Source code in <code>commol/context/stratification.py</code> <pre><code>class Stratification(BaseModel):\n    \"\"\"\n    Defines a categorical subdivision of the population.\n\n    Attributes\n    ----------\n    id : str\n        Identifier of the stratification.\n    categories : list[str]\n        List of the different stratification groups identifiers.\n    \"\"\"\n\n    id: str = Field(default=..., description=\"Identifier of the stratification.\")\n    categories: list[str] = Field(\n        default=...,\n        description=\"List of the different stratification groups identifiers.\",\n    )\n\n    @override\n    def __hash__(self) -&gt; int:\n        return hash(self.id)\n\n    @override\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Stratification) and self.id == other.id\n\n    @model_validator(mode=\"after\")\n    def validate_categories_length(self) -&gt; Self:\n        \"\"\"\n        Enforces that categories are not empty.\n        \"\"\"\n        if not self.categories:\n            raise ValueError(\n                (f\"Stratification '{self.id}' must have at least one category.\")\n            )\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_categories_uniqueness(self) -&gt; Self:\n        \"\"\"\n        Enforces that categories are not repeated.\n        \"\"\"\n        categories_set = set(self.categories)\n\n        if len(categories_set) != len(self.categories):\n            duplicates = [\n                item for item in categories_set if self.categories.count(item) &gt; 1\n            ]\n            raise ValueError(\n                (\n                    f\"Categories for stratification '{self.id}' must not be repeated. \"\n                    f\"Found duplicates: {list(set(duplicates))}.\"\n                )\n            )\n\n        return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.stratification.Stratification-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.stratification.Stratification.validate_categories_length","title":"validate_categories_length","text":"<pre><code>validate_categories_length() -&gt; Self\n</code></pre> <p>Enforces that categories are not empty.</p> Source code in <code>commol/context/stratification.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_categories_length(self) -&gt; Self:\n    \"\"\"\n    Enforces that categories are not empty.\n    \"\"\"\n    if not self.categories:\n        raise ValueError(\n            (f\"Stratification '{self.id}' must have at least one category.\")\n        )\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.stratification.Stratification.validate_categories_uniqueness","title":"validate_categories_uniqueness","text":"<pre><code>validate_categories_uniqueness() -&gt; Self\n</code></pre> <p>Enforces that categories are not repeated.</p> Source code in <code>commol/context/stratification.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_categories_uniqueness(self) -&gt; Self:\n    \"\"\"\n    Enforces that categories are not repeated.\n    \"\"\"\n    categories_set = set(self.categories)\n\n    if len(categories_set) != len(self.categories):\n        duplicates = [\n            item for item in categories_set if self.categories.count(item) &gt; 1\n        ]\n        raise ValueError(\n            (\n                f\"Categories for stratification '{self.id}' must not be repeated. \"\n                f\"Found duplicates: {list(set(duplicates))}.\"\n            )\n        )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#parameters","title":"Parameters","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.parameter.Parameter","title":"Parameter","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a global model parameter.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The identifier of the parameter.</p> <code>value</code> <code>float | str | None</code> <p>Value of the parameter. Can be: - float: A numerical constant value - str: A mathematical formula that can reference other parameters,        special variables (N, N_category, step/t, pi, e), or contain        mathematical expressions - None: Indicates that the parameter needs to be calibrated before use</p> <code>description</code> <code>str | None</code> <p>A human-readable description of the parameter.</p> <code>unit</code> <code>str | None</code> <p>The unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\"). If None, the parameter has no unit specified.</p> Source code in <code>commol/context/parameter.py</code> <pre><code>class Parameter(BaseModel):\n    \"\"\"\n    Defines a global model parameter.\n\n    Attributes\n    ----------\n    id : str\n        The identifier of the parameter.\n    value : float | str | None\n        Value of the parameter. Can be:\n        - float: A numerical constant value\n        - str: A mathematical formula that can reference other parameters,\n               special variables (N, N_category, step/t, pi, e), or contain\n               mathematical expressions\n        - None: Indicates that the parameter needs to be calibrated before use\n    description : str | None\n        A human-readable description of the parameter.\n    unit : str | None\n        The unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\").\n        If None, the parameter has no unit specified.\n    \"\"\"\n\n    id: str = Field(default=..., description=\"Identifier of the parameter.\")\n    value: float | str | None = Field(\n        default=...,\n        description=(\n            \"Value of the parameter. Can be a float (constant), \"\n            \"str (formula), or None (requires calibration).\"\n        ),\n    )\n    description: str | None = Field(\n        default=None, description=\"Human-readable description of the parameter.\"\n    )\n    unit: str | None = Field(\n        default=None,\n        description=\"Unit of the parameter (e.g., '1/day', 'dimensionless', 'person').\",\n    )\n\n    @field_validator(\"value\")\n    @classmethod\n    def validate_value(cls, value: float | str | None) -&gt; float | str | None:\n        \"\"\"Validate the parameter value.\"\"\"\n        if value is None:\n            return value\n        if isinstance(value, (int, float)):\n            return float(value)\n        if not value.strip():\n            raise ValueError(\"Formula cannot be empty\")\n        return value.strip()\n\n    def is_calibrated(self) -&gt; bool:\n        \"\"\"\n        Check if the parameter has a value (is calibrated).\n\n        Returns\n        -------\n        bool\n            True if the parameter has a value, False if it needs calibration.\n        \"\"\"\n        return self.value is not None\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.parameter.Parameter-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.parameter.Parameter.validate_value","title":"validate_value  <code>classmethod</code>","text":"<pre><code>validate_value(value: float | str | None) -&gt; float | str | None\n</code></pre> <p>Validate the parameter value.</p> Source code in <code>commol/context/parameter.py</code> <pre><code>@field_validator(\"value\")\n@classmethod\ndef validate_value(cls, value: float | str | None) -&gt; float | str | None:\n    \"\"\"Validate the parameter value.\"\"\"\n    if value is None:\n        return value\n    if isinstance(value, (int, float)):\n        return float(value)\n    if not value.strip():\n        raise ValueError(\"Formula cannot be empty\")\n    return value.strip()\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.parameter.Parameter.is_calibrated","title":"is_calibrated","text":"<pre><code>is_calibrated() -&gt; bool\n</code></pre> <p>Check if the parameter has a value (is calibrated).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the parameter has a value, False if it needs calibration.</p> Source code in <code>commol/context/parameter.py</code> <pre><code>def is_calibrated(self) -&gt; bool:\n    \"\"\"\n    Check if the parameter has a value (is calibrated).\n\n    Returns\n    -------\n    bool\n        True if the parameter has a value, False if it needs calibration.\n    \"\"\"\n    return self.value is not None\n</code></pre>"},{"location":"advanced/model-structure/#transitions","title":"Transitions","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.dynamics.Transition","title":"Transition","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a rule for system evolution.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Id of the transition.</p> <code>source</code> <code>list[str]</code> <p>The origin compartments.</p> <code>target</code> <code>list[str]</code> <p>The destination compartments.</p> <code>rate</code> <code>str | None</code> <p>Default mathematical formula, parameter name, or constant value for the flow. Used when no stratified rate matches. Numeric values are automatically converted to strings during validation.</p> <p>Operators: +, -, *, /, % (modulo), ^ or ** (power) Functions: sin, cos, tan, exp, ln, sqrt, abs, min, max, if, etc. Constants: pi, e</p> <p>Note: Both ^ and ** are supported for exponentiation (** is converted to ^).</p> <p>Examples: - \"beta\" (parameter reference) - \"0.5\" (constant, can also be passed as float 0.5) - \"beta * S * I / N\" (mathematical formula) - \"0.3 * sin(2 * pi * t / 365)\" (time-dependent formula) - \"2^10\" or \"2**10\" (power: both syntaxes work)</p> <code>stratified_rates</code> <code>list[StratifiedRate] | None</code> <p>Stratification-specific rates. Each rate applies to compartments that match all specified stratification conditions.</p> <code>condition</code> <code>Condition | None</code> <p>Logical restrictions for the transition.</p> Source code in <code>commol/context/dynamics.py</code> <pre><code>class Transition(BaseModel):\n    \"\"\"\n    Defines a rule for system evolution.\n\n    Attributes\n    ----------\n    id : str\n        Id of the transition.\n    source : list[str]\n        The origin compartments.\n    target : list[str]\n        The destination compartments.\n    rate : str | None\n        Default mathematical formula, parameter name, or constant value for the flow.\n        Used when no stratified rate matches. Numeric values are automatically\n        converted to strings during validation.\n\n        Operators: +, -, *, /, % (modulo), ^ or ** (power)\n        Functions: sin, cos, tan, exp, ln, sqrt, abs, min, max, if, etc.\n        Constants: pi, e\n\n        Note: Both ^ and ** are supported for exponentiation (** is converted to ^).\n\n        Examples:\n        - \"beta\" (parameter reference)\n        - \"0.5\" (constant, can also be passed as float 0.5)\n        - \"beta * S * I / N\" (mathematical formula)\n        - \"0.3 * sin(2 * pi * t / 365)\" (time-dependent formula)\n        - \"2^10\" or \"2**10\" (power: both syntaxes work)\n    stratified_rates : list[StratifiedRate] | None\n        Stratification-specific rates. Each rate applies to compartments that match\n        all specified stratification conditions.\n    condition : Condition | None\n        Logical restrictions for the transition.\n    \"\"\"\n\n    id: str = Field(default=..., description=\"Id of the transition.\")\n    source: list[str] = Field(default=..., description=\"Origin compartments.\")\n    target: list[str] = Field(default=..., description=\"Destination compartments.\")\n\n    rate: str | None = Field(\n        None,\n        description=(\n            \"Default rate expression (fallback when no stratified rate matches). \"\n            \"Can be a parameter reference (e.g., 'beta'), a constant (e.g., '0.5'), \"\n            \"or a mathematical expression (e.g., 'beta * S * I / N'). \"\n            \"Numeric values are automatically converted to strings during validation.\"\n        ),\n    )\n\n    stratified_rates: list[StratifiedRate] | None = Field(\n        default=None, description=\"List of stratification-specific rates\"\n    )\n\n    condition: Condition | None = Field(\n        default=None, description=\"Logical restrictions for the transition.\"\n    )\n\n    @field_validator(\"rate\", mode=\"before\")\n    @classmethod\n    def validate_rate(cls, value: str | None) -&gt; str | None:\n        \"\"\"\n        Convert numeric rates to strings and perform security and syntax validation.\n        \"\"\"\n        if value is None:\n            return value\n        try:\n            validate_expression_security(value)\n            commol_rs.core.MathExpression(value).validate()\n        except ValueError as e:\n            raise ValueError(f\"Validation failed for rate '{value}': {e}\")\n        return value\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.dynamics.Transition-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.dynamics.Transition.validate_rate","title":"validate_rate  <code>classmethod</code>","text":"<pre><code>validate_rate(value: str | None) -&gt; str | None\n</code></pre> <p>Convert numeric rates to strings and perform security and syntax validation.</p> Source code in <code>commol/context/dynamics.py</code> <pre><code>@field_validator(\"rate\", mode=\"before\")\n@classmethod\ndef validate_rate(cls, value: str | None) -&gt; str | None:\n    \"\"\"\n    Convert numeric rates to strings and perform security and syntax validation.\n    \"\"\"\n    if value is None:\n        return value\n    try:\n        validate_expression_security(value)\n        commol_rs.core.MathExpression(value).validate()\n    except ValueError as e:\n        raise ValueError(f\"Validation failed for rate '{value}': {e}\")\n    return value\n</code></pre>"},{"location":"advanced/model-structure/#initial-conditions","title":"Initial Conditions","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.initial_conditions.InitialConditions","title":"InitialConditions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Initial conditions for a simulation.</p> <p>Attributes:</p> Name Type Description <code>population_size</code> <code>int</code> <p>Population size.</p> <code>bin_fractions</code> <code>list[BinFraction]</code> <p>List of bin fractions. Each item contains a bin id and its initial fractional size. Fractions can be None if they need calibration.</p> <code>stratification_fractions</code> <code>(list[StratificationFractions], optional)</code> <p>List of stratification fractions. Each item contains a stratification id and its category fractions.</p> Source code in <code>commol/context/initial_conditions.py</code> <pre><code>class InitialConditions(BaseModel):\n    \"\"\"\n    Initial conditions for a simulation.\n\n    Attributes\n    ----------\n    population_size : int\n        Population size.\n    bin_fractions : list[BinFraction]\n        List of bin fractions. Each item contains a bin id and\n        its initial fractional size. Fractions can be None if they need calibration.\n    stratification_fractions : list[StratificationFractions], optional\n        List of stratification fractions. Each item contains a stratification id and\n        its category fractions.\n    \"\"\"\n\n    population_size: int = Field(..., description=\"Population size.\")\n    bin_fractions: list[BinFraction] = Field(\n        default=...,\n        description=(\n            \"List of bin fractions. Each item contains a bin id and its initial \"\n            \"fractional size. Fractions can be None if they need calibration.\"\n        ),\n    )\n    stratification_fractions: list[StratificationFractions] = Field(\n        default_factory=list,\n        description=(\n            \"List of stratification fractions. Each item contains a stratification id \"\n            \"and its category fractions.\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_calibrated_fractions_sum_to_one(self) -&gt; Self:\n        \"\"\"\n        Validate that bin fractions sum appropriately.\n\n        Rules:\n        - If all fractions are calibrated (no None): must sum to exactly 1.0\n        - If some fractions are None (uncalibrated): calibrated ones must sum to LESS\n            than 1.0\n        - If all fractions are None: skip validation (will be set before simulation)\n        \"\"\"\n        calibrated_fractions = [\n            bf.fraction for bf in self.bin_fractions if bf.fraction is not None\n        ]\n\n        # If all fractions are None (all need calibration), skip validation\n        if not calibrated_fractions:\n            return self\n\n        # If some fractions are calibrated, check if they sum correctly\n        # Note: We can't validate the sum if some are None, so we only warn\n        total = sum(calibrated_fractions)\n        uncalibrated_count = sum(1 for bf in self.bin_fractions if bf.fraction is None)\n\n        if uncalibrated_count &gt; 0:\n            # Some fractions are None: calibrated ones MUST be LESS than 1.0\n            if total &gt;= 1.0:\n                raise ValueError(\n                    (\n                        f\"Calibrated bin fractions sum to {total:.4f}, but must be \"\n                        f\"LESS than 1.0 to leave room for {uncalibrated_count} \"\n                        f\"uncalibrated fraction(s). Calibrated fractions: \"\n                        f\"{\n                            [\n                                (bf.bin, bf.fraction)\n                                for bf in self.bin_fractions\n                                if bf.fraction is not None\n                            ]\n                        }\"\n                    )\n                )\n        else:\n            # All fractions are calibrated, must sum to 1.0\n            if not math.isclose(total, 1.0, abs_tol=1e-4):\n                raise ValueError(\n                    (\n                        f\"Bin fractions must sum to 1.0, got {total:.4f}. \"\n                        f\"Fractions: {[bf.fraction for bf in self.bin_fractions]}\"\n                    )\n                )\n\n        return self\n\n    def get_uncalibrated_bins(self) -&gt; list[str]:\n        \"\"\"\n        Get list of bin IDs that have uncalibrated fractions (value = None).\n\n        Returns\n        -------\n        list[str]\n            List of bin IDs with uncalibrated initial conditions.\n        \"\"\"\n        return [bf.bin for bf in self.bin_fractions if bf.fraction is None]\n\n    def update_bin_fractions(self, fractions: Mapping[str, float | None]) -&gt; None:\n        \"\"\"\n        Update bin fractions by bin ID.\n\n        Parameters\n        ----------\n        fractions : Mapping[str, float | None]\n            Dictionary mapping bin IDs to their new fraction values.\n            None values indicate bins that need calibration.\n\n        Raises\n        ------\n        ValueError\n            If a bin ID is not found in the initial conditions.\n        \"\"\"\n        for bin_id, fraction in fractions.items():\n            found = False\n            for bf in self.bin_fractions:\n                if bf.bin == bin_id:\n                    bf.fraction = fraction\n                    found = True\n                    break\n            if not found:\n                raise ValueError(\n                    f\"Bin '{bin_id}' not found in initial conditions. \"\n                    f\"Available bins: {[bf.bin for bf in self.bin_fractions]}\"\n                )\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.initial_conditions.InitialConditions-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.initial_conditions.InitialConditions.validate_calibrated_fractions_sum_to_one","title":"validate_calibrated_fractions_sum_to_one","text":"<pre><code>validate_calibrated_fractions_sum_to_one() -&gt; Self\n</code></pre> <p>Validate that bin fractions sum appropriately.</p> <p>Rules: - If all fractions are calibrated (no None): must sum to exactly 1.0 - If some fractions are None (uncalibrated): calibrated ones must sum to LESS     than 1.0 - If all fractions are None: skip validation (will be set before simulation)</p> Source code in <code>commol/context/initial_conditions.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_calibrated_fractions_sum_to_one(self) -&gt; Self:\n    \"\"\"\n    Validate that bin fractions sum appropriately.\n\n    Rules:\n    - If all fractions are calibrated (no None): must sum to exactly 1.0\n    - If some fractions are None (uncalibrated): calibrated ones must sum to LESS\n        than 1.0\n    - If all fractions are None: skip validation (will be set before simulation)\n    \"\"\"\n    calibrated_fractions = [\n        bf.fraction for bf in self.bin_fractions if bf.fraction is not None\n    ]\n\n    # If all fractions are None (all need calibration), skip validation\n    if not calibrated_fractions:\n        return self\n\n    # If some fractions are calibrated, check if they sum correctly\n    # Note: We can't validate the sum if some are None, so we only warn\n    total = sum(calibrated_fractions)\n    uncalibrated_count = sum(1 for bf in self.bin_fractions if bf.fraction is None)\n\n    if uncalibrated_count &gt; 0:\n        # Some fractions are None: calibrated ones MUST be LESS than 1.0\n        if total &gt;= 1.0:\n            raise ValueError(\n                (\n                    f\"Calibrated bin fractions sum to {total:.4f}, but must be \"\n                    f\"LESS than 1.0 to leave room for {uncalibrated_count} \"\n                    f\"uncalibrated fraction(s). Calibrated fractions: \"\n                    f\"{\n                        [\n                            (bf.bin, bf.fraction)\n                            for bf in self.bin_fractions\n                            if bf.fraction is not None\n                        ]\n                    }\"\n                )\n            )\n    else:\n        # All fractions are calibrated, must sum to 1.0\n        if not math.isclose(total, 1.0, abs_tol=1e-4):\n            raise ValueError(\n                (\n                    f\"Bin fractions must sum to 1.0, got {total:.4f}. \"\n                    f\"Fractions: {[bf.fraction for bf in self.bin_fractions]}\"\n                )\n            )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.initial_conditions.InitialConditions.get_uncalibrated_bins","title":"get_uncalibrated_bins","text":"<pre><code>get_uncalibrated_bins() -&gt; list[str]\n</code></pre> <p>Get list of bin IDs that have uncalibrated fractions (value = None).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of bin IDs with uncalibrated initial conditions.</p> Source code in <code>commol/context/initial_conditions.py</code> <pre><code>def get_uncalibrated_bins(self) -&gt; list[str]:\n    \"\"\"\n    Get list of bin IDs that have uncalibrated fractions (value = None).\n\n    Returns\n    -------\n    list[str]\n        List of bin IDs with uncalibrated initial conditions.\n    \"\"\"\n    return [bf.bin for bf in self.bin_fractions if bf.fraction is None]\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.initial_conditions.InitialConditions.update_bin_fractions","title":"update_bin_fractions","text":"<pre><code>update_bin_fractions(fractions: Mapping[str, float | None]) -&gt; None\n</code></pre> <p>Update bin fractions by bin ID.</p> <p>Parameters:</p> Name Type Description Default <code>fractions</code> <code>Mapping[str, float | None]</code> <p>Dictionary mapping bin IDs to their new fraction values. None values indicate bins that need calibration.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a bin ID is not found in the initial conditions.</p> Source code in <code>commol/context/initial_conditions.py</code> <pre><code>def update_bin_fractions(self, fractions: Mapping[str, float | None]) -&gt; None:\n    \"\"\"\n    Update bin fractions by bin ID.\n\n    Parameters\n    ----------\n    fractions : Mapping[str, float | None]\n        Dictionary mapping bin IDs to their new fraction values.\n        None values indicate bins that need calibration.\n\n    Raises\n    ------\n    ValueError\n        If a bin ID is not found in the initial conditions.\n    \"\"\"\n    for bin_id, fraction in fractions.items():\n        found = False\n        for bf in self.bin_fractions:\n            if bf.bin == bin_id:\n                bf.fraction = fraction\n                found = True\n                break\n        if not found:\n            raise ValueError(\n                f\"Bin '{bin_id}' not found in initial conditions. \"\n                f\"Available bins: {[bf.bin for bf in self.bin_fractions]}\"\n            )\n</code></pre>"},{"location":"advanced/model-structure/#dynamics","title":"Dynamics","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.dynamics.Dynamics","title":"Dynamics","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines how the system evolves.</p> <p>Attributes:</p> Name Type Description <code>typology</code> <code>Literal['DifferenceEquations']</code> <p>The type of model.</p> <code>transitions</code> <code>List[Transition]</code> <p>A list of rules for state changes.</p> Source code in <code>commol/context/dynamics.py</code> <pre><code>class Dynamics(BaseModel):\n    \"\"\"\n    Defines how the system evolves.\n\n    Attributes\n    ----------\n    typology : Literal[\"DifferenceEquations\"]\n        The type of model.\n    transitions : List[Transition]\n        A list of rules for state changes.\n    \"\"\"\n\n    typology: Literal[ModelTypes.DIFFERENCE_EQUATIONS]\n    transitions: list[Transition]\n\n    @field_validator(\"transitions\")\n    @classmethod\n    def validate_transitions_not_empty(cls, v: list[Transition]) -&gt; list[Transition]:\n        if not v:\n            raise ValueError(\"At least one transition must be defined.\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_unique_transition_ids(self) -&gt; Self:\n        \"\"\"\n        Validates that transition IDs are unique.\n        \"\"\"\n        transition_ids = [t.id for t in self.transitions]\n        if len(transition_ids) != len(set(transition_ids)):\n            duplicates = [\n                item for item in set(transition_ids) if transition_ids.count(item) &gt; 1\n            ]\n            raise ValueError(f\"Duplicate transition IDs found: {duplicates}\")\n        return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.dynamics.Dynamics-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.dynamics.Dynamics.validate_unique_transition_ids","title":"validate_unique_transition_ids","text":"<pre><code>validate_unique_transition_ids() -&gt; Self\n</code></pre> <p>Validates that transition IDs are unique.</p> Source code in <code>commol/context/dynamics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_unique_transition_ids(self) -&gt; Self:\n    \"\"\"\n    Validates that transition IDs are unique.\n    \"\"\"\n    transition_ids = [t.id for t in self.transitions]\n    if len(transition_ids) != len(set(transition_ids)):\n        duplicates = [\n            item for item in set(transition_ids) if transition_ids.count(item) &gt; 1\n        ]\n        raise ValueError(f\"Duplicate transition IDs found: {duplicates}\")\n    return self\n</code></pre>"},{"location":"api/calibrator/","title":"Calibrator API","text":""},{"location":"api/calibrator/#commol.api.calibrator.Calibrator","title":"Calibrator","text":"<p>A Facade for running parameter calibration from a defined CalibrationProblem.</p> Source code in <code>commol/api/calibrator.py</code> <pre><code>class Calibrator:\n    \"\"\"\n    A Facade for running parameter calibration from a defined CalibrationProblem.\n    \"\"\"\n\n    def __init__(\n        self,\n        simulation: Simulation,\n        problem: CalibrationProblem,\n    ):\n        \"\"\"\n        Initializes the calibration from a Simulation and CalibrationProblem.\n\n        Parameters\n        ----------\n        simulation : Simulation\n            A fully initialized Simulation object with the model to calibrate.\n        problem : CalibrationProblem\n            A fully constructed and validated calibration problem definition.\n        \"\"\"\n        logger.info(\n            f\"Initializing Calibration for model: '{simulation.model_definition.name}'\"\n        )\n        self.simulation: Simulation = simulation\n        self.problem: CalibrationProblem = problem\n        self._engine: \"DifferenceEquationsProtocol\" = simulation.engine\n\n        logger.info(\n            (\n                f\"Calibration initialized with {len(problem.parameters)} parameters \"\n                f\"and {len(problem.observed_data)} observed data points.\"\n            )\n        )\n\n        # Validate calibration parameters against model\n        self._validate_calibration_parameters()\n\n    def run(self) -&gt; CalibrationResult:\n        \"\"\"\n        Runs the calibration optimization.\n\n        Returns\n        -------\n        CalibrationResult\n            Object containing the optimized parameter values, final loss,\n            convergence status, and other optimization statistics.\n\n        Raises\n        ------\n        ImportError\n            If Rust extension is not available.\n        ValueError\n            If calibration problem setup is invalid.\n        RuntimeError\n            If optimization fails.\n        \"\"\"\n        logger.info(\n            (\n                f\"Starting calibration with \"\n                f\"{self.problem.optimization_config.algorithm.value} algorithm and \"\n                f\"{self.problem.loss_config.function.value} loss function.\"\n            )\n        )\n\n        # Convert observed data to Rust types\n        rust_observed_data = [\n            rust_calibration.ObservedDataPoint(\n                step=point.step,\n                compartment=point.compartment,\n                value=point.value,\n                weight=point.weight,\n            )\n            for point in self.problem.observed_data\n        ]\n\n        # Convert parameters to Rust types\n        rust_parameters = [\n            rust_calibration.CalibrationParameter(\n                id=param.id,\n                parameter_type=self._to_rust_parameter_type(param.parameter_type),\n                min_bound=param.min_bound,\n                max_bound=param.max_bound,\n                initial_guess=param.initial_guess,\n            )\n            for param in self.problem.parameters\n        ]\n\n        # Convert loss config to Rust type\n        rust_loss_config = self._build_loss_config()\n\n        # Convert optimization config to Rust type\n        rust_optimization_config = self._build_optimization_config()\n\n        logger.info(\"Converted problem definition to Rust types.\")\n        logger.info(\"Running optimization...\")\n\n        # Get initial population size for initial condition fraction conversion\n        initial_population_size = self._get_initial_population_size()\n\n        # Call the Rust calibrate function\n        rust_result = rust_calibration.calibrate(\n            self._engine,\n            rust_observed_data,\n            rust_parameters,\n            rust_loss_config,\n            rust_optimization_config,\n            initial_population_size,\n        )\n\n        # Convert result back to Python CalibrationResult\n        result = CalibrationResult(\n            best_parameters=rust_result.best_parameters,\n            parameter_names=rust_result.parameter_names,\n            best_parameters_list=rust_result.best_parameters_list,\n            final_loss=rust_result.final_loss,\n            iterations=rust_result.iterations,\n            converged=rust_result.converged,\n            termination_reason=rust_result.termination_reason,\n        )\n\n        logger.info(\n            (\n                f\"Calibration finished after {result.iterations} iterations. \"\n                f\"Final loss: {result.final_loss:.6f}\"\n            )\n        )\n\n        return result\n\n    def _to_rust_parameter_type(\n        self, param_type: CalibrationParameterType\n    ) -&gt; \"CalibrationParameterTypeProtocol\":\n        \"\"\"Convert Python CalibrationParameterType to Rust type.\"\"\"\n        if param_type == CalibrationParameterType.PARAMETER:\n            return rust_calibration.CalibrationParameterType.Parameter\n        elif param_type == CalibrationParameterType.INITIAL_CONDITION:\n            return rust_calibration.CalibrationParameterType.InitialCondition\n        else:\n            raise ValueError(f\"Unknown parameter type: {param_type}\")\n\n    def _build_loss_config(self) -&gt; \"LossConfigProtocol\":\n        \"\"\"Convert Python LossConfig to Rust LossConfig.\"\"\"\n        loss_func = self.problem.loss_config.function\n\n        if loss_func == LossFunction.SSE:\n            return rust_calibration.LossConfig.sum_squared_error()\n        elif loss_func == LossFunction.RMSE:\n            return rust_calibration.LossConfig.root_mean_squared_error()\n        elif loss_func == LossFunction.MAE:\n            return rust_calibration.LossConfig.mean_absolute_error()\n        elif loss_func == LossFunction.WEIGHTED_SSE:\n            return rust_calibration.LossConfig.weighted_sse()\n        else:\n            raise ValueError(f\"Unsupported loss function: {loss_func}.\")\n\n    def _build_optimization_config(self) -&gt; \"OptimizationConfigProtocol\":\n        \"\"\"Convert Python OptimizationConfig to Rust OptimizationConfig.\"\"\"\n        opt_config = self.problem.optimization_config\n\n        if opt_config.algorithm == OptimizationAlgorithm.NELDER_MEAD:\n            if not isinstance(opt_config.config, NelderMeadConfig):\n                raise ValueError(\n                    (\n                        f\"Expected NelderMeadConfig for Nelder-Mead algorithm, \"\n                        f\"got {type(opt_config.config).__name__}\"\n                    )\n                )\n\n            nm_config = rust_calibration.NelderMeadConfig(\n                max_iterations=opt_config.config.max_iterations,\n                sd_tolerance=opt_config.config.sd_tolerance,\n                alpha=opt_config.config.alpha,\n                gamma=opt_config.config.gamma,\n                rho=opt_config.config.rho,\n                sigma=opt_config.config.sigma,\n                verbose=opt_config.config.verbose,\n                header_interval=opt_config.config.header_interval,\n            )\n            return rust_calibration.OptimizationConfig.nelder_mead(nm_config)\n\n        elif opt_config.algorithm == OptimizationAlgorithm.PARTICLE_SWARM:\n            if not isinstance(opt_config.config, ParticleSwarmConfig):\n                raise ValueError(\n                    (\n                        f\"Expected ParticleSwarmConfig for Particle Swarm algorithm, \"\n                        f\"got {type(opt_config.config).__name__}\"\n                    )\n                )\n\n            ps_config = rust_calibration.ParticleSwarmConfig(\n                num_particles=opt_config.config.num_particles,\n                max_iterations=opt_config.config.max_iterations,\n                target_cost=opt_config.config.target_cost,\n                inertia_factor=opt_config.config.inertia_factor,\n                cognitive_factor=opt_config.config.cognitive_factor,\n                social_factor=opt_config.config.social_factor,\n                seed=opt_config.config.seed,\n                verbose=opt_config.config.verbose,\n                header_interval=opt_config.config.header_interval,\n            )\n            return rust_calibration.OptimizationConfig.particle_swarm(ps_config)\n\n        else:\n            raise ValueError(\n                f\"Unsupported optimization algorithm: {opt_config.algorithm}\"\n            )\n\n    @property\n    def num_parameters(self) -&gt; int:\n        \"\"\"Number of parameters being calibrated.\"\"\"\n        return len(self.problem.parameters)\n\n    @property\n    def num_observations(self) -&gt; int:\n        \"\"\"Number of observed data points.\"\"\"\n        return len(self.problem.observed_data)\n\n    @property\n    def parameter_names(self) -&gt; list[str]:\n        \"\"\"Names of parameters being calibrated.\"\"\"\n        return [param.id for param in self.problem.parameters]\n\n    def _validate_calibration_parameters(self) -&gt; None:\n        \"\"\"\n        Validate that all calibration parameters exist in the model.\n\n        Raises\n        ------\n        ValueError\n            If a parameter ID doesn't exist in the model or if a bin ID is invalid.\n        \"\"\"\n        model = self.simulation.model_definition\n        model_param_ids = {p.id for p in model.parameters}\n        model_bin_ids = {b.id for b in model.population.bins}\n\n        for param in self.problem.parameters:\n            if param.parameter_type == CalibrationParameterType.PARAMETER:\n                if param.id not in model_param_ids:\n                    raise ValueError(\n                        f\"Calibration parameter '{param.id}' not found in model \"\n                        f\"parameters. Available parameters: \"\n                        f\"{sorted(model_param_ids)}\"\n                    )\n            elif param.parameter_type == CalibrationParameterType.INITIAL_CONDITION:\n                if param.id not in model_bin_ids:\n                    raise ValueError(\n                        f\"Calibration initial condition '{param.id}' not found in \"\n                        f\"model bins. Available bins: {sorted(model_bin_ids)}\"\n                    )\n            else:\n                raise ValueError(\n                    f\"Unknown calibration parameter type: {param.parameter_type}\"\n                )\n\n    def _get_compartment_index(self, bin_id: str) -&gt; int:\n        \"\"\"\n        Get the index of a bin/compartment by its ID.\n\n        Parameters\n        ----------\n        bin_id : str\n            The bin identifier\n\n        Returns\n        -------\n        int\n            The index of the compartment in the population vector\n\n        Raises\n        ------\n        ValueError\n            If the bin_id is not found\n        \"\"\"\n        bins = self.simulation.model_definition.population.bins\n        for idx, bin_obj in enumerate(bins):\n            if bin_obj.id == bin_id:\n                return idx\n        raise ValueError(f\"Bin '{bin_id}' not found in model\")\n\n    def _get_initial_population_size(self) -&gt; int:\n        \"\"\"Get the initial population size from the model.\"\"\"\n        initial_conditions = (\n            self.simulation.model_definition.population.initial_conditions\n        )\n        return initial_conditions.population_size\n</code></pre>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator-attributes","title":"Attributes","text":""},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.num_parameters","title":"num_parameters  <code>property</code>","text":"<pre><code>num_parameters: int\n</code></pre> <p>Number of parameters being calibrated.</p>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.num_observations","title":"num_observations  <code>property</code>","text":"<pre><code>num_observations: int\n</code></pre> <p>Number of observed data points.</p>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.parameter_names","title":"parameter_names  <code>property</code>","text":"<pre><code>parameter_names: list[str]\n</code></pre> <p>Names of parameters being calibrated.</p>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.__init__","title":"__init__","text":"<pre><code>__init__(simulation: Simulation, problem: CalibrationProblem)\n</code></pre> <p>Initializes the calibration from a Simulation and CalibrationProblem.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A fully initialized Simulation object with the model to calibrate.</p> required <code>problem</code> <code>CalibrationProblem</code> <p>A fully constructed and validated calibration problem definition.</p> required Source code in <code>commol/api/calibrator.py</code> <pre><code>def __init__(\n    self,\n    simulation: Simulation,\n    problem: CalibrationProblem,\n):\n    \"\"\"\n    Initializes the calibration from a Simulation and CalibrationProblem.\n\n    Parameters\n    ----------\n    simulation : Simulation\n        A fully initialized Simulation object with the model to calibrate.\n    problem : CalibrationProblem\n        A fully constructed and validated calibration problem definition.\n    \"\"\"\n    logger.info(\n        f\"Initializing Calibration for model: '{simulation.model_definition.name}'\"\n    )\n    self.simulation: Simulation = simulation\n    self.problem: CalibrationProblem = problem\n    self._engine: \"DifferenceEquationsProtocol\" = simulation.engine\n\n    logger.info(\n        (\n            f\"Calibration initialized with {len(problem.parameters)} parameters \"\n            f\"and {len(problem.observed_data)} observed data points.\"\n        )\n    )\n\n    # Validate calibration parameters against model\n    self._validate_calibration_parameters()\n</code></pre>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.run","title":"run","text":"<pre><code>run() -&gt; CalibrationResult\n</code></pre> <p>Runs the calibration optimization.</p> <p>Returns:</p> Type Description <code>CalibrationResult</code> <p>Object containing the optimized parameter values, final loss, convergence status, and other optimization statistics.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Rust extension is not available.</p> <code>ValueError</code> <p>If calibration problem setup is invalid.</p> <code>RuntimeError</code> <p>If optimization fails.</p> Source code in <code>commol/api/calibrator.py</code> <pre><code>def run(self) -&gt; CalibrationResult:\n    \"\"\"\n    Runs the calibration optimization.\n\n    Returns\n    -------\n    CalibrationResult\n        Object containing the optimized parameter values, final loss,\n        convergence status, and other optimization statistics.\n\n    Raises\n    ------\n    ImportError\n        If Rust extension is not available.\n    ValueError\n        If calibration problem setup is invalid.\n    RuntimeError\n        If optimization fails.\n    \"\"\"\n    logger.info(\n        (\n            f\"Starting calibration with \"\n            f\"{self.problem.optimization_config.algorithm.value} algorithm and \"\n            f\"{self.problem.loss_config.function.value} loss function.\"\n        )\n    )\n\n    # Convert observed data to Rust types\n    rust_observed_data = [\n        rust_calibration.ObservedDataPoint(\n            step=point.step,\n            compartment=point.compartment,\n            value=point.value,\n            weight=point.weight,\n        )\n        for point in self.problem.observed_data\n    ]\n\n    # Convert parameters to Rust types\n    rust_parameters = [\n        rust_calibration.CalibrationParameter(\n            id=param.id,\n            parameter_type=self._to_rust_parameter_type(param.parameter_type),\n            min_bound=param.min_bound,\n            max_bound=param.max_bound,\n            initial_guess=param.initial_guess,\n        )\n        for param in self.problem.parameters\n    ]\n\n    # Convert loss config to Rust type\n    rust_loss_config = self._build_loss_config()\n\n    # Convert optimization config to Rust type\n    rust_optimization_config = self._build_optimization_config()\n\n    logger.info(\"Converted problem definition to Rust types.\")\n    logger.info(\"Running optimization...\")\n\n    # Get initial population size for initial condition fraction conversion\n    initial_population_size = self._get_initial_population_size()\n\n    # Call the Rust calibrate function\n    rust_result = rust_calibration.calibrate(\n        self._engine,\n        rust_observed_data,\n        rust_parameters,\n        rust_loss_config,\n        rust_optimization_config,\n        initial_population_size,\n    )\n\n    # Convert result back to Python CalibrationResult\n    result = CalibrationResult(\n        best_parameters=rust_result.best_parameters,\n        parameter_names=rust_result.parameter_names,\n        best_parameters_list=rust_result.best_parameters_list,\n        final_loss=rust_result.final_loss,\n        iterations=rust_result.iterations,\n        converged=rust_result.converged,\n        termination_reason=rust_result.termination_reason,\n    )\n\n    logger.info(\n        (\n            f\"Calibration finished after {result.iterations} iterations. \"\n            f\"Final loss: {result.final_loss:.6f}\"\n        )\n    )\n\n    return result\n</code></pre>"},{"location":"api/calibrator/#related-classes","title":"Related Classes","text":""},{"location":"api/calibrator/#calibrationproblem","title":"CalibrationProblem","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationProblem","title":"CalibrationProblem","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a complete calibration problem.</p> <p>This class encapsulates all the information needed to calibrate model parameters against observed data. It provides validation of the calibration setup but delegates the actual optimization to the Rust backend.</p> <p>Attributes:</p> Name Type Description <code>observed_data</code> <code>list[ObservedDataPoint]</code> <p>List of observed data points to fit against</p> <code>parameters</code> <code>list[CalibrationParameter]</code> <p>List of parameters to calibrate with their bounds</p> <code>loss_config</code> <code>LossConfig</code> <p>Configuration for the loss function</p> <code>optimization_config</code> <code>OptimizationConfig</code> <p>Configuration for the optimization algorithm</p>"},{"location":"api/calibrator/#commol.context.calibration.CalibrationProblem-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationProblem.validate_unique_parameter_ids","title":"validate_unique_parameter_ids","text":"<pre><code>validate_unique_parameter_ids() -&gt; Self\n</code></pre> <p>Ensure parameter IDs are unique.</p>"},{"location":"api/calibrator/#calibrationresult","title":"CalibrationResult","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationResult","title":"CalibrationResult","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result of a calibration run.</p> <p>This is a simple data class that holds the results returned from the Rust calibration function.</p> <p>Attributes:</p> Name Type Description <code>best_parameters</code> <code>dict[str, float]</code> <p>Dictionary mapping parameter IDs to their calibrated values</p> <code>parameter_names</code> <code>list[str]</code> <p>Ordered list of parameter names</p> <code>best_parameters_list</code> <code>list[float]</code> <p>Ordered list of parameter values (matches parameter_names order)</p> <code>final_loss</code> <code>float</code> <p>Final loss value achieved</p> <code>iterations</code> <code>int</code> <p>Number of iterations performed</p> <code>converged</code> <code>bool</code> <p>Whether the optimization converged</p> <code>termination_reason</code> <code>str</code> <p>Explanation of why optimization terminated</p>"},{"location":"api/calibrator/#commol.context.calibration.CalibrationResult-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationResult.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>String representation of calibration result.</p>"},{"location":"api/calibrator/#calibrationparameter","title":"CalibrationParameter","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationParameter","title":"CalibrationParameter","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a parameter or initial condition to be calibrated with its bounds.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Identifier (parameter ID for parameters, bin ID for initial conditions)</p> <code>parameter_type</code> <code>CalibrationParameterType</code> <p>Type of value being calibrated (default: PARAMETER)</p> <code>min_bound</code> <code>float</code> <p>Minimum allowed value for this parameter</p> <code>max_bound</code> <code>float</code> <p>Maximum allowed value for this parameter</p> <code>initial_guess</code> <code>float | None</code> <p>Optional starting value for optimization (if None, midpoint is used)</p>"},{"location":"api/calibrator/#commol.context.calibration.CalibrationParameter-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationParameter.validate_bounds","title":"validate_bounds","text":"<pre><code>validate_bounds() -&gt; Self\n</code></pre> <p>Validate that max_bound &gt; min_bound and initial_guess is within bounds.</p>"},{"location":"api/calibrator/#observeddatapoint","title":"ObservedDataPoint","text":""},{"location":"api/calibrator/#commol.context.calibration.ObservedDataPoint","title":"ObservedDataPoint","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single observed data point for calibration.</p> <p>Attributes:</p> Name Type Description <code>step</code> <code>int</code> <p>Time step of the observation</p> <code>compartment</code> <code>str</code> <p>Name of the compartment being observed</p> <code>value</code> <code>float</code> <p>Observed value</p> <code>weight</code> <code>float</code> <p>Weight for this observation in the loss function (default: 1.0)</p>"},{"location":"api/calibrator/#lossconfig","title":"LossConfig","text":""},{"location":"api/calibrator/#commol.context.calibration.LossConfig","title":"LossConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the loss function used in calibration.</p> <p>Attributes:</p> Name Type Description <code>function</code> <code>LossFunction</code> <p>The loss function to use for measuring fit quality</p>"},{"location":"api/calibrator/#optimizationconfig","title":"OptimizationConfig","text":""},{"location":"api/calibrator/#commol.context.calibration.OptimizationConfig","title":"OptimizationConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the optimization algorithm.</p> <p>Attributes:</p> Name Type Description <code>algorithm</code> <code>Literal[nelder_mead, particle_swarm]</code> <p>The optimization algorithm to use</p> <code>config</code> <code>NelderMeadConfig | ParticleSwarmConfig</code> <p>Configuration for the selected algorithm</p>"},{"location":"api/calibrator/#commol.context.calibration.OptimizationConfig-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.context.calibration.OptimizationConfig.validate_algorithm_config","title":"validate_algorithm_config","text":"<pre><code>validate_algorithm_config() -&gt; Self\n</code></pre> <p>Ensure the config type matches the selected algorithm.</p>"},{"location":"api/calibrator/#neldermeadconfig","title":"NelderMeadConfig","text":""},{"location":"api/calibrator/#commol.context.calibration.NelderMeadConfig","title":"NelderMeadConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the Nelder-Mead optimization algorithm.</p> <p>The Nelder-Mead method is a simplex-based derivative-free optimization algorithm, suitable for problems where gradients are not available.</p> <p>Attributes:</p> Name Type Description <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations (default: 1000)</p> <code>sd_tolerance</code> <code>float</code> <p>Convergence tolerance for standard deviation (default: 1e-6)</p> <code>alpha</code> <code>float | None</code> <p>Reflection coefficient (default: None, uses argmin's default)</p> <code>gamma</code> <code>float | None</code> <p>Expansion coefficient (default: None, uses argmin's default)</p> <code>rho</code> <code>float | None</code> <p>Contraction coefficient (default: None, uses argmin's default)</p> <code>sigma</code> <code>float | None</code> <p>Shrink coefficient (default: None, uses argmin's default)</p> <code>verbose</code> <code>bool</code> <p>Enable verbose output during optimization (default: False)</p> <code>header_interval</code> <code>int</code> <p>Number of iterations between table header repeats in verbose output (default: 100)</p>"},{"location":"api/calibrator/#particleswarmconfig","title":"ParticleSwarmConfig","text":""},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig","title":"ParticleSwarmConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the Particle Swarm Optimization algorithm.</p> <p>Use the constructor to create an instance, then chain builder methods to configure: - <code>.with_inertia()</code> or <code>.with_chaotic_inertia()</code> for inertia control - <code>.with_acceleration()</code> or <code>.with_tvac()</code> for acceleration coefficients - <code>.with_initialization_strategy()</code> for particle initialization - <code>.with_velocity_clamping()</code> and <code>.with_velocity_mutation()</code> for velocity control - <code>.with_mutation()</code> for mutation settings - <code>.with_seed()</code> for reproducibility</p> <p>Attributes:</p> Name Type Description <code>num_particles</code> <code>int</code> <p>Number of particles in the swarm (default: 20)</p> <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations (default: 1000)</p> <code>target_cost</code> <code>float | None</code> <p>Target cost for early stopping (default: None)</p> <code>seed</code> <code>int | None</code> <p>Random seed for reproducibility (default: None)</p> <code>verbose</code> <code>bool</code> <p>Enable verbose output (default: False)</p> <code>header_interval</code> <code>int</code> <p>Iterations between header repeats in verbose mode (default: 100)</p>"},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig.with_inertia","title":"with_inertia","text":"<pre><code>with_inertia(inertia: float) -&gt; Self\n</code></pre> <p>Set constant inertia weight factor.</p> <p>Parameters:</p> Name Type Description Default <code>inertia</code> <code>float</code> <p>Inertia weight (must be positive)</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated configuration for method chaining</p>"},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig.with_chaotic_inertia","title":"with_chaotic_inertia","text":"<pre><code>with_chaotic_inertia(w_min: float, w_max: float) -&gt; Self\n</code></pre> <p>Enable chaotic inertia weight using logistic map.</p> <p>Parameters:</p> Name Type Description Default <code>w_min</code> <code>float</code> <p>Minimum inertia weight (must be positive)</p> required <code>w_max</code> <code>float</code> <p>Maximum inertia weight (must be &gt; w_min)</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated configuration for method chaining</p>"},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig.with_acceleration","title":"with_acceleration","text":"<pre><code>with_acceleration(cognitive: float, social: float) -&gt; Self\n</code></pre> <p>Set constant cognitive and social acceleration factors.</p> <p>Parameters:</p> Name Type Description Default <code>cognitive</code> <code>float</code> <p>Attraction to personal best (must be positive)</p> required <code>social</code> <code>float</code> <p>Attraction to swarm best (must be positive)</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated configuration for method chaining</p>"},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig.with_tvac","title":"with_tvac","text":"<pre><code>with_tvac(c1_initial: float, c1_final: float, c2_initial: float, c2_final: float) -&gt; Self\n</code></pre> <p>Enable Time-Varying Acceleration Coefficients (TVAC).</p> <p>Parameters:</p> Name Type Description Default <code>c1_initial</code> <code>float</code> <p>Initial cognitive factor (must be positive)</p> required <code>c1_final</code> <code>float</code> <p>Final cognitive factor (must be positive)</p> required <code>c2_initial</code> <code>float</code> <p>Initial social factor (must be positive)</p> required <code>c2_final</code> <code>float</code> <p>Final social factor (must be positive)</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated configuration for method chaining</p>"},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig.with_initialization_strategy","title":"with_initialization_strategy","text":"<pre><code>with_initialization_strategy(strategy: str) -&gt; Self\n</code></pre> <p>Set particle initialization strategy.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>str</code> <p>One of: \"uniform\", \"latin_hypercube\", \"opposition_based\"</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated configuration for method chaining</p>"},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig.with_velocity_clamping","title":"with_velocity_clamping","text":"<pre><code>with_velocity_clamping(clamp_factor: float) -&gt; Self\n</code></pre> <p>Enable velocity clamping.</p> <p>Parameters:</p> Name Type Description Default <code>clamp_factor</code> <code>float</code> <p>Fraction of search space range (typically 0.1 to 0.2)</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated configuration for method chaining</p>"},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig.with_velocity_mutation","title":"with_velocity_mutation","text":"<pre><code>with_velocity_mutation(threshold: float) -&gt; Self\n</code></pre> <p>Enable velocity mutation when velocity approaches zero.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Velocity threshold for reinitialization (typically 0.001 to 0.01)</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated configuration for method chaining</p>"},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig.with_mutation","title":"with_mutation","text":"<pre><code>with_mutation(strategy: str, scale: float, probability: float, application: str) -&gt; Self\n</code></pre> <p>Enable mutation to help escape local optima.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>str</code> <p>Either \"gaussian\" or \"cauchy\"</p> required <code>scale</code> <code>float</code> <p>Standard deviation (gaussian) or scale parameter (cauchy)</p> required <code>probability</code> <code>float</code> <p>Mutation probability per iteration (0.0 to 1.0)</p> required <code>application</code> <code>str</code> <p>One of: \"global_best\", \"all_particles\", \"below_average\"</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated configuration for method chaining</p>"},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig.with_seed","title":"with_seed","text":"<pre><code>with_seed(seed: int) -&gt; Self\n</code></pre> <p>Set random seed for reproducibility.</p> <p>When set, the particle swarm will produce deterministic results, allowing you to reproduce the same optimization trajectory.</p> <p>Note: The seed is set via this builder method (rather than in the constructor) to allow easy modification without creating a new configuration. This is particularly useful when running multiple calibrations with different seeds while keeping other parameters constant.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>Random seed value (must be non-negative)</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated configuration for method chaining</p>"},{"location":"api/calibrator/#enumerations","title":"Enumerations","text":""},{"location":"api/calibrator/#lossfunction","title":"LossFunction","text":""},{"location":"api/calibrator/#commol.context.calibration.LossFunction","title":"LossFunction","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available loss functions for calibration.</p> <p>Attributes:</p> Name Type Description <code>SSE</code> <code>str</code> <p>Sum of Squared Errors</p> <code>RMSE</code> <code>str</code> <p>Root Mean Squared Error</p> <code>MAE</code> <code>str</code> <p>Mean Absolute Error</p> <code>WEIGHTED_SSE</code> <code>str</code> <p>Weighted Sum of Squared Errors</p>"},{"location":"api/calibrator/#commol.context.calibration.LossFunction-attributes","title":"Attributes","text":""},{"location":"api/calibrator/#commol.context.calibration.LossFunction.SSE","title":"SSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SSE = 'sum_squared_error'\n</code></pre>"},{"location":"api/calibrator/#commol.context.calibration.LossFunction.RMSE","title":"RMSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RMSE = 'root_mean_squared_error'\n</code></pre>"},{"location":"api/calibrator/#commol.context.calibration.LossFunction.MAE","title":"MAE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAE = 'mean_absolute_error'\n</code></pre>"},{"location":"api/calibrator/#commol.context.calibration.LossFunction.WEIGHTED_SSE","title":"WEIGHTED_SSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEIGHTED_SSE = 'weighted_sse'\n</code></pre>"},{"location":"api/calibrator/#optimizationalgorithm","title":"OptimizationAlgorithm","text":""},{"location":"api/calibrator/#commol.context.calibration.OptimizationAlgorithm","title":"OptimizationAlgorithm","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available optimization algorithms.</p> <p>Attributes:</p> Name Type Description <code>NELDER_MEAD</code> <code>str</code> <p>Nelder-Mead simplex algorithm</p> <code>PARTICLE_SWARM</code> <code>str</code> <p>Particle Swarm Optimization</p>"},{"location":"api/calibrator/#commol.context.calibration.OptimizationAlgorithm-attributes","title":"Attributes","text":""},{"location":"api/calibrator/#commol.context.calibration.OptimizationAlgorithm.NELDER_MEAD","title":"NELDER_MEAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NELDER_MEAD = 'nelder_mead'\n</code></pre>"},{"location":"api/calibrator/#commol.context.calibration.OptimizationAlgorithm.PARTICLE_SWARM","title":"PARTICLE_SWARM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARTICLE_SWARM = 'particle_swarm'\n</code></pre>"},{"location":"api/constants/","title":"Constants","text":""},{"location":"api/constants/#commol.constants","title":"constants","text":""},{"location":"api/model-builder/","title":"ModelBuilder API","text":""},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder","title":"ModelBuilder","text":"<p>A programmatic interface for building compartment models.</p> <p>This class provides a fluent API for constructing Model instances by progressively adding bins, stratifications, transitions, parameters, and initial conditions. It includes validation methods to ensure model consistency before building.</p> <p>Attributes:</p> Name Type Description <code>_name</code> <code>str</code> <p>The model name.</p> <code>_description</code> <code>str | None</code> <p>The model description.</p> <code>_version</code> <code>str | None</code> <p>The model version.</p> <code>_disease_states</code> <code>list[Bin]</code> <p>List of bins in the model.</p> <code>_stratifications</code> <code>list[Stratification]</code> <p>List of population stratifications.</p> <code>_transitions</code> <code>list[Transition]</code> <p>List of transitions between states.</p> <code>_parameters</code> <code>list[Parameter]</code> <p>List of model parameters.</p> <code>_initial_conditions</code> <code>InitialConditions | None</code> <p>Initial population conditions.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>class ModelBuilder:\n    \"\"\"\n    A programmatic interface for building compartment models.\n\n    This class provides a fluent API for constructing Model instances by progressively\n    adding bins, stratifications, transitions, parameters, and\n    initial conditions. It includes validation methods to ensure model consistency\n    before building.\n\n    Attributes\n    ----------\n    _name : str\n        The model name.\n    _description : str | None\n        The model description.\n    _version : str | None\n        The model version.\n    _disease_states : list[Bin]\n        List of bins in the model.\n    _stratifications : list[Stratification]\n        List of population stratifications.\n    _transitions : list[Transition]\n        List of transitions between states.\n    _parameters : list[Parameter]\n        List of model parameters.\n    _initial_conditions : InitialConditions | None\n        Initial population conditions.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str | None = None,\n        version: str | None = None,\n        bin_unit: str | None = None,\n    ):\n        \"\"\"\n        Initialize the ModelBuilder.\n\n        Parameters\n        ----------\n        name : str\n            The unique name that identifies the model.\n        description : str | None, default=None\n            A human-readable description of the model's purpose and function.\n        version : str | None, default=None\n            The version number of the model.\n        bin_unit : str | None, default=None\n            The default unit for all bins.\n            Individual bins can override this with their own unit parameter.\n            Units are optional but required for model.print_equations() and\n            model.check_unit_consistency().\n        \"\"\"\n        self._name: str = name\n        self._description: str | None = description\n        self._version: str | None = version\n        self._bin_unit: str | None = bin_unit\n\n        self._bins: list[Bin] = []\n        self._stratifications: list[Stratification] = []\n        self._transitions: list[Transition] = []\n        self._parameters: list[Parameter] = []\n        self._initial_conditions: InitialConditions | None = None\n\n        logging.info(\n            (\n                f\"Initialized ModelBuilder: name='{self._name}', \"\n                f\"version='{self._version or 'N/A'}'\"\n            )\n        )\n\n    def add_bin(self, id: str, name: str, unit: str | None = None) -&gt; Self:\n        \"\"\"\n        Add a bin to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the bin.\n        name : str\n            Human-readable name for the bin.\n        unit : str | None, default=None\n            Unit of measurement for this bin. If None, uses the model-level bin_unit.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        # Use bin-specific unit, or fall back to model-level bin_unit\n        final_unit = unit if unit is not None else self._bin_unit\n        self._bins.append(Bin(id=id, name=name, unit=final_unit))\n        logging.info(f\"Added bin: id='{id}', name='{name}', unit='{final_unit}'\")\n        return self\n\n    def add_stratification(self, id: str, categories: list[str]) -&gt; Self:\n        \"\"\"\n        Add a population stratification to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the stratification.\n        categories : list[str]\n            list of category identifiers within this stratification.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        self._stratifications.append(Stratification(id=id, categories=categories))\n        logging.info(f\"Added stratification: id='{id}', categories={categories}\")\n        return self\n\n    def add_parameter(\n        self,\n        id: str,\n        value: float | str | None,\n        description: str | None = None,\n        unit: str | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Add a global parameter to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the parameter.\n        value : float | str | None\n            Value of the parameter. Can be:\n            - float: A numerical constant value\n            - str: A mathematical formula that can reference other parameters,\n                   special variables (N, N_category, step/t, pi, e), or contain\n                   mathematical expressions (e.g., \"beta * 2\", \"N_young / N\")\n            - None: Indicates that the parameter needs to be calibrated before use\n\n            Special variables available in formulas:\n            - N: Total population (automatically calculated)\n            - N_{category}: Population in specific category (e.g., N_young, N_old)\n            - N_{cat1}_{cat2}: Population in category combinations\n            - step or t: Current simulation step\n            - pi, e: Mathematical constants\n\n        description : str | None, default=None\n            Human-readable description of the parameter.\n        unit : str | None, default=None\n            Unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\").\n            Used for unit consistency checking in equations.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        self._parameters.append(\n            Parameter(id=id, value=value, description=description, unit=unit)\n        )\n        logging.info(f\"Added parameter: id='{id}', value={value}, unit='{unit}'\")\n        return self\n\n    def add_transition(\n        self,\n        id: str,\n        source: list[str],\n        target: list[str],\n        rate: str | float | None = None,\n        stratified_rates: list[StratifiedRateDict] | None = None,\n        condition: Condition | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Add a transition between states to the model.\n\n        This method supports two distinct behaviors:\n\n        When you specify multiple sources without the $compartment placeholder,\n        a SINGLE transition is created that affects all sources simultaneously.\n        The rate is evaluated ONCE per time step, and that value is applied to\n        all source compartments at once.\n\n        Example:\n            .add_transition(\n                id=\"interaction\",\n                source=[\"S\", \"I\"],\n                target=[\"I\", \"I\"],\n                rate=\"beta * S * I\"\n            )\n\n        This creates ONE transition where:\n        - The rate \"beta * S * I\" is calculated once\n        - That rate removes from both S and I simultaneously\n        - That rate adds to I twice (once per target entry)\n        - Resulting equations:\n          dS/dt = ... - (beta*S*I)\n          dI/dt = ... - (beta*S*I) + 2*(beta*S*I) = ... + (beta*S*I)\n\n        When you use the $compartment placeholder in the rate formula with multiple\n        sources, the system automatically expands this into multiple independent\n        transitions - one for each source compartment. Each transition has its own\n        rate calculation where $compartment is replaced with the actual compartment\n        name.\n\n        Example:\n            .add_transition(\n                id=\"death\",\n                source=[\"S\", \"L\", \"I\", \"R\"],\n                target=[],\n                rate=\"d * $compartment\"\n            )\n\n        This automatically expands to FOUR separate transitions:\n        - Transition 1: S -&gt; [] with rate \"d * S\"\n        - Transition 2: L -&gt; [] with rate \"d * L\"\n        - Transition 3: I -&gt; [] with rate \"d * I\"\n        - Transition 4: R -&gt; [] with rate \"d * R\"\n\n        Each transition's rate is evaluated independently, giving per-compartment\n        dynamics. This is ideal for processes like per-capita death rates, where the\n        rate should be proportional to each compartment's population.\n\n        **$compartment Usage Rules**:\n        - Only valid when len(source) &gt; 1\n        - Target must be empty [] or have exactly one element\n        - Can be used with stratified_rates - the placeholder will be expanded in\n          both the base rate and all stratified rate expressions\n        - The placeholder $compartment will be replaced with each source compartment\n          name\n\n        **$compartment Restrictions**:\n        - Using $compartment with a single source will raise an error (use the\n          compartment name directly instead)\n        - Using $compartment with multiple targets will raise an error (ambiguous\n          which target corresponds to which source)\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the transition. When using $compartment expansion,\n            the system will append \"__&lt;compartment_name&gt;\" to create unique IDs for\n            each expanded transition (e.g., \"death__S\", \"death__L\").\n        source : list[str]\n            List of source state/category identifiers. When using $compartment in\n            the rate, each source will generate a separate transition.\n        target : list[str]\n            List of target state/category identifiers. When using $compartment,\n            target must be empty [] or have exactly one element.\n        rate : str | float | None, default=None\n            Default mathematical formula, parameter reference, or constant value for\n            the transition rate. Used when no stratified rate matches.\n            Can be:\n            - A parameter reference (e.g., \"beta\")\n            - A constant value (e.g., \"0.5\" or 0.5)\n            - A mathematical formula (e.g., \"beta * S * I / N\")\n            - A formula with $compartment placeholder (e.g., \"d * $compartment\")\n\n            Special variables available in formulas:\n            - N: Total population (automatically calculated)\n            - step or t: Current simulation step (both are equivalent)\n            - pi, e: Mathematical constants\n            - $compartment: Expands to each source compartment name (only with\n              multiple sources)\n\n        stratified_rates : list[dict] | None, default=None\n            List of stratification-specific rates. Each dict must contain:\n            - \"conditions\": List of dicts with \"stratification\" and \"category\" keys\n            - \"rate\": Rate expression string\n\n        condition : Condition| None, default=None\n            Logical conditions that must be met for the transition.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n\n        Raises\n        ------\n        ValueError\n            - If $compartment is used with only one source compartment\n            - If $compartment is used with multiple targets\n            - If rate is None when using $compartment\n\n        Examples\n        --------\n        Standard single transition affecting multiple sources:\n        &gt;&gt;&gt; builder.add_transition(\n        ...     id=\"infection\",\n        ...     source=[\"S\", \"I\"],\n        ...     target=[\"I\", \"I\"],\n        ...     rate=\"beta * S * I / N\",\n        ... )\n\n        Expanded transitions using $compartment (creates 4 separate transitions):\n        &gt;&gt;&gt; builder.add_transition(\n        ...     id=\"death\",\n        ...     source=[\"S\", \"L\", \"I\", \"R\"],\n        ...     target=[],\n        ...     rate=\"d * $compartment\",\n        ... )\n\n        Per-compartment flow with target:\n        &gt;&gt;&gt; builder.add_transition(\n        ...     id=\"treatment\",\n        ...     source=[\"I_mild\", \"I_severe\"],\n        ...     target=[\"R\"],\n        ...     rate=\"treatment_rate * $compartment\",\n        ... )\n        \"\"\"\n        # Convert rate to string if numeric\n        if isinstance(rate, int) or isinstance(rate, float):\n            rate = str(rate)\n\n        # Check for $compartment placeholder and handle expansion\n        if rate and \"$compartment\" in rate:\n            self._validate_compartment_placeholder(\n                id, source, target, rate, stratified_rates\n            )\n            self._expand_compartment_transition(\n                id, source, target, rate, stratified_rates, condition\n            )\n            return self\n\n        # Convert stratified rates dicts to Pydantic objects\n        stratified_rates_objects: list[StratifiedRate] | None = None\n        if stratified_rates:\n            stratified_rates_objects = []\n            for rate_dict in stratified_rates:\n                conditions = [\n                    StratificationCondition(**cond) for cond in rate_dict[\"conditions\"]\n                ]\n                stratified_rates_objects.append(\n                    StratifiedRate(conditions=conditions, rate=str(rate_dict[\"rate\"]))\n                )\n\n        self._transitions.append(\n            Transition(\n                id=id,\n                source=source,\n                target=target,\n                rate=rate,\n                stratified_rates=stratified_rates_objects,\n                condition=condition,\n            )\n        )\n        logging.info(\n            (\n                f\"Added transition: id='{id}', source={source}, target={target}, \"\n                f\"rate='{rate}', stratified_rates={\n                    len(stratified_rates_objects) if stratified_rates_objects else 0\n                }\"\n            )\n        )\n        return self\n\n    def _validate_compartment_placeholder(\n        self,\n        id: str,\n        source: list[str],\n        target: list[str],\n        rate: str,\n        stratified_rates: list[StratifiedRateDict] | None,\n    ) -&gt; None:\n        \"\"\"\n        Validate that $compartment placeholder is used correctly.\n\n        Parameters\n        ----------\n        id : str\n            Transition identifier (for error messages)\n        source : list[str]\n            Source compartments\n        target : list[str]\n            Target compartments\n        rate : str\n            Rate formula\n        stratified_rates : list[StratifiedRateDict] | None\n            Stratified rates\n\n        Raises\n        ------\n        ValueError\n            If $compartment usage violates any rules\n        \"\"\"\n        # Check that source has multiple compartments\n        if len(source) &lt;= 1:\n            raise ValueError(\n                (\n                    f\"Transition '{id}': $compartment placeholder requires multiple \"\n                    f\"source compartments (found {len(source)}). \"\n                    f\"If you have a single source, use the compartment name directly \"\n                    f\"in the rate formula instead of $compartment.\"\n                )\n            )\n\n        # Check that target is empty or has exactly one element\n        if len(target) &gt; 1:\n            raise ValueError(\n                (\n                    f\"Transition '{id}': $compartment placeholder cannot be used \"\n                    f\"with multiple targets (found {len(target)} targets). \"\n                    f\"Multiple targets would create ambiguous mappings between \"\n                    f\"sources and targets. Use target=[] for removal or target with \"\n                    f\"a single element for transfers.\"\n                )\n            )\n\n    def _expand_compartment_transition(\n        self,\n        id: str,\n        source: list[str],\n        target: list[str],\n        rate: str,\n        stratified_rates: list[StratifiedRateDict] | None,\n        condition: Condition | None,\n    ) -&gt; None:\n        \"\"\"\n        Expand a transition with $compartment placeholder into multiple transitions.\n\n        Parameters\n        ----------\n        id : str\n            Base transition identifier\n        source : list[str]\n            Source compartments (will create one transition per source)\n        target : list[str]\n            Target compartments\n        rate : str\n            Rate formula containing $compartment\n        stratified_rates : list[StratifiedRateDict] | None\n            Stratified rates (can contain $compartment which will be expanded)\n        condition : Condition | None\n            Transition condition\n        \"\"\"\n        logging.info(\n            (\n                f\"Expanding transition '{id}' with $compartment placeholder: \"\n                f\"{len(source)} source compartments will create \"\n                f\"{len(source)} separate transitions\"\n            )\n        )\n\n        for compartment in source:\n            # Replace $compartment with actual compartment name in base rate\n            expanded_rate = rate.replace(\"$compartment\", compartment)\n\n            # Expand stratified rates if present\n            expanded_stratified_rates: list[StratifiedRate] | None = None\n            if stratified_rates:\n                expanded_stratified_rates = []\n                for rate_dict in stratified_rates:\n                    # Replace $compartment in stratified rate expression\n                    strat_rate_value = rate_dict[\"rate\"]\n                    # Convert to string if it's a number\n                    if isinstance(strat_rate_value, (int, float)):\n                        strat_rate_str = str(strat_rate_value)\n                    else:\n                        strat_rate_str = strat_rate_value\n\n                    expanded_strat_rate = strat_rate_str.replace(\n                        \"$compartment\", compartment\n                    )\n\n                    # Convert conditions to Pydantic objects\n                    conditions = [\n                        StratificationCondition(**cond)\n                        for cond in rate_dict[\"conditions\"]\n                    ]\n\n                    expanded_stratified_rates.append(\n                        StratifiedRate(conditions=conditions, rate=expanded_strat_rate)\n                    )\n\n            # Generate unique ID for this expanded transition\n            expanded_id = f\"{id}__{compartment}\"\n\n            # Create the expanded transition\n            self._transitions.append(\n                Transition(\n                    id=expanded_id,\n                    source=[compartment],\n                    target=target,\n                    rate=expanded_rate,\n                    stratified_rates=expanded_stratified_rates,\n                    condition=condition,\n                )\n            )\n\n            strat_info = (\n                f\", {len(expanded_stratified_rates)} stratified rates\"\n                if expanded_stratified_rates\n                else \"\"\n            )\n            logging.info(\n                (\n                    f\"  Created expanded transition: id='{expanded_id}', \"\n                    f\"source=['{compartment}'], target={target}, \"\n                    f\"rate='{expanded_rate}'{strat_info}\"\n                )\n            )\n\n        logging.info(\n            f\"Successfully expanded transition '{id}' into {len(source)} transitions\"\n        )\n\n    def create_condition(\n        self,\n        logic: Literal[\"and\", \"or\"],\n        rules: list[RuleDict],\n    ) -&gt; Condition:\n        \"\"\"\n        Create a condition object for use in transitions.\n\n        Parameters\n        ----------\n        logic : Literal[\"and\", \"or\"]\n            How to combine the rules.\n        rules : List[RuleDict]\n            List of rule dictionaries with 'variable', 'operator', and 'value' keys.\n            Each dictionary must have:\n            - 'variable': str (format '&lt;prefix&gt;:&lt;variable_id&gt;')\n            - 'operator': Literal[\"eq\", \"neq\", \"gt\", \"get\", \"lt\", \"let\"]\n            - 'value': str | int | float | bool\n\n        Returns\n        -------\n        Condition\n            The created condition object.\n\n        Examples\n        --------\n        &gt;&gt;&gt; condition = builder.create_condition(\n        ...     \"and\",\n        ...     [\n        ...         {\"variable\": \"states:I\", \"operator\": \"gt\", \"value\": 0},\n        ...         {\"variable\": \"strati:age\", \"operator\": \"eq\", \"value\": \"adult\"},\n        ...     ],\n        ... )\n        \"\"\"\n        rule_objects: list[Rule] = []\n        for rule_dict in rules:\n            rule_objects.append(\n                Rule(\n                    variable=rule_dict[\"variable\"],\n                    operator=rule_dict[\"operator\"],\n                    value=rule_dict[\"value\"],\n                )\n            )\n\n        return Condition(\n            logic=cast(\n                Literal[LogicOperators.AND, LogicOperators.OR], LogicOperators(logic)\n            ),\n            rules=rule_objects,\n        )\n\n    def set_initial_conditions(\n        self,\n        population_size: int,\n        bin_fractions: list[BinFractionDict],\n        stratification_fractions: list[StratificationFractionsDict] | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Set the initial conditions for the model.\n\n        Parameters\n        ----------\n        population_size : int\n            Total population size.\n        bin_fractions : list[BinFractionDict]\n            List of bin fractions. Each item is a dictionary with:\n            - \"bin\": str (bin id)\n            - \"fraction\": float (fractional size)\n\n            Example:\n            [\n                {\"bin\": \"S\", \"fraction\": 0.99},\n                {\"bin\": \"I\", \"fraction\": 0.01},\n                {\"bin\": \"R\", \"fraction\": 0.0}\n            ]\n        stratification_fractions : list[StratificationFractionsDict] | None,\n            default=None\n            List of stratification fractions. Each item is a dictionary with:\n            - \"stratification\": str (stratification id)\n            - \"fractions\": list of dicts, each with \"category\" and \"fraction\"\n\n            Example:\n            [\n                {\n                    \"stratification\": \"age_group\",\n                    \"fractions\": [\n                        {\"category\": \"young\", \"fraction\": 0.3},\n                        {\"category\": \"adult\", \"fraction\": 0.5},\n                        {\"category\": \"elderly\", \"fraction\": 0.2}\n                    ]\n                }\n            ]\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n\n        Raises\n        ------\n        ValueError\n            If initial conditions have already been set.\n        \"\"\"\n        if self._initial_conditions is not None:\n            raise ValueError(\"Initial conditions have already been set\")\n\n        bin_fractions_list: list[BinFraction] = []\n        for bf_dict in bin_fractions:\n            bin_fractions_list.append(\n                BinFraction(\n                    bin=bf_dict[\"bin\"],\n                    fraction=bf_dict[\"fraction\"],\n                )\n            )\n\n        strat_fractions_list: list[StratificationFractions] = []\n        if stratification_fractions:\n            for strat_dict in stratification_fractions:\n                fractions_list: list[StratificationFraction] = []\n                for frac_dict in strat_dict[\"fractions\"]:\n                    fractions_list.append(\n                        StratificationFraction(\n                            category=frac_dict[\"category\"],\n                            fraction=frac_dict[\"fraction\"],\n                        )\n                    )\n                strat_fractions_list.append(\n                    StratificationFractions(\n                        stratification=strat_dict[\"stratification\"],\n                        fractions=fractions_list,\n                    )\n                )\n\n        self._initial_conditions = InitialConditions(\n            population_size=population_size,\n            bin_fractions=bin_fractions_list,\n            stratification_fractions=strat_fractions_list,\n        )\n        bin_ids = [bf[\"bin\"] for bf in bin_fractions]\n        logging.info(\n            (\n                f\"Set initial conditions: population_size={population_size}, \"\n                f\"bins={bin_ids}\"\n            )\n        )\n        return self\n\n    def get_summary(self) -&gt; dict[str, str | int | list[str] | None]:\n        \"\"\"\n        Get a summary of the current model builder state.\n\n        Returns\n        -------\n        dict[str, dict[str, str | int | list[str] | None]]\n            Dictionary containing summary information about the model being built.\n        \"\"\"\n        return {\n            \"name\": self._name,\n            \"description\": self._description,\n            \"version\": self._version,\n            \"disease_states_count\": len(self._bins),\n            \"bin_ids\": [state.id for state in self._bins],\n            \"stratifications_count\": len(self._stratifications),\n            \"stratification_ids\": [strat.id for strat in self._stratifications],\n            \"transitions_count\": len(self._transitions),\n            \"transition_ids\": [trans.id for trans in self._transitions],\n            \"parameters_count\": len(self._parameters),\n            \"parameter_ids\": [param.id for param in self._parameters],\n            \"has_initial_conditions\": self._initial_conditions is not None,\n        }\n\n    def clone(self) -&gt; Self:\n        \"\"\"\n        Create a deep copy of this ModelBuilder.\n\n        Returns\n        -------\n        ModelBuilder\n            A new ModelBuilder instance with the same configuration.\n        \"\"\"\n\n        new_builder = type(self)(self._name, self._description, self._version)\n\n        new_builder._bins = copy.deepcopy(self._bins)\n        new_builder._stratifications = copy.deepcopy(self._stratifications)\n        new_builder._transitions = copy.deepcopy(self._transitions)\n        new_builder._parameters = copy.deepcopy(self._parameters)\n        new_builder._initial_conditions = copy.deepcopy(self._initial_conditions)\n\n        return new_builder\n\n    def reset(self) -&gt; Self:\n        \"\"\"\n        Reset the builder to empty state while keeping name, description, and version.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        self._bins.clear()\n        self._stratifications.clear()\n        self._transitions.clear()\n        self._parameters.clear()\n        self._initial_conditions = None\n        return self\n\n    def build(self, typology: Literal[\"DifferenceEquations\"]) -&gt; Model:\n        \"\"\"\n        Build and return the final Model instance.\n\n        Parameters\n        ----------\n        typology : Literal[\"DifferenceEquations\"]\n            Type of the model.\n\n        Returns\n        -------\n        Model\n            The constructed compartment model.\n\n        Raises\n        ------\n        ValueError\n            If validation fails or required components are missing.\n        \"\"\"\n        if self._initial_conditions is None:\n            raise ValueError(\"Initial conditions must be set\")\n\n        population = Population(\n            bins=self._bins,\n            stratifications=self._stratifications,\n            transitions=self._transitions,\n            initial_conditions=self._initial_conditions,\n        )\n\n        dynamics = Dynamics(\n            typology=cast(\n                Literal[ModelTypes.DIFFERENCE_EQUATIONS], ModelTypes(typology)\n            ),\n            transitions=self._transitions,\n        )\n\n        model = Model(\n            name=self._name,\n            description=self._description,\n            version=self._version,\n            population=population,\n            parameters=self._parameters,\n            dynamics=dynamics,\n        )\n\n        logging.info(\n            f\"Model '{self._name}' successfully built with typology '{typology}'.\"\n        )\n\n        return model\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder-functions","title":"Functions","text":""},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.__init__","title":"__init__","text":"<pre><code>__init__(name: str, description: str | None = None, version: str | None = None, bin_unit: str | None = None)\n</code></pre> <p>Initialize the ModelBuilder.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name that identifies the model.</p> required <code>description</code> <code>str | None</code> <p>A human-readable description of the model's purpose and function.</p> <code>None</code> <code>version</code> <code>str | None</code> <p>The version number of the model.</p> <code>None</code> <code>bin_unit</code> <code>str | None</code> <p>The default unit for all bins. Individual bins can override this with their own unit parameter. Units are optional but required for model.print_equations() and model.check_unit_consistency().</p> <code>None</code> Source code in <code>commol/api/model_builder.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    description: str | None = None,\n    version: str | None = None,\n    bin_unit: str | None = None,\n):\n    \"\"\"\n    Initialize the ModelBuilder.\n\n    Parameters\n    ----------\n    name : str\n        The unique name that identifies the model.\n    description : str | None, default=None\n        A human-readable description of the model's purpose and function.\n    version : str | None, default=None\n        The version number of the model.\n    bin_unit : str | None, default=None\n        The default unit for all bins.\n        Individual bins can override this with their own unit parameter.\n        Units are optional but required for model.print_equations() and\n        model.check_unit_consistency().\n    \"\"\"\n    self._name: str = name\n    self._description: str | None = description\n    self._version: str | None = version\n    self._bin_unit: str | None = bin_unit\n\n    self._bins: list[Bin] = []\n    self._stratifications: list[Stratification] = []\n    self._transitions: list[Transition] = []\n    self._parameters: list[Parameter] = []\n    self._initial_conditions: InitialConditions | None = None\n\n    logging.info(\n        (\n            f\"Initialized ModelBuilder: name='{self._name}', \"\n            f\"version='{self._version or 'N/A'}'\"\n        )\n    )\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.add_bin","title":"add_bin","text":"<pre><code>add_bin(id: str, name: str, unit: str | None = None) -&gt; Self\n</code></pre> <p>Add a bin to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the bin.</p> required <code>name</code> <code>str</code> <p>Human-readable name for the bin.</p> required <code>unit</code> <code>str | None</code> <p>Unit of measurement for this bin. If None, uses the model-level bin_unit.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def add_bin(self, id: str, name: str, unit: str | None = None) -&gt; Self:\n    \"\"\"\n    Add a bin to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the bin.\n    name : str\n        Human-readable name for the bin.\n    unit : str | None, default=None\n        Unit of measurement for this bin. If None, uses the model-level bin_unit.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    # Use bin-specific unit, or fall back to model-level bin_unit\n    final_unit = unit if unit is not None else self._bin_unit\n    self._bins.append(Bin(id=id, name=name, unit=final_unit))\n    logging.info(f\"Added bin: id='{id}', name='{name}', unit='{final_unit}'\")\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.add_stratification","title":"add_stratification","text":"<pre><code>add_stratification(id: str, categories: list[str]) -&gt; Self\n</code></pre> <p>Add a population stratification to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the stratification.</p> required <code>categories</code> <code>list[str]</code> <p>list of category identifiers within this stratification.</p> required <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def add_stratification(self, id: str, categories: list[str]) -&gt; Self:\n    \"\"\"\n    Add a population stratification to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the stratification.\n    categories : list[str]\n        list of category identifiers within this stratification.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    self._stratifications.append(Stratification(id=id, categories=categories))\n    logging.info(f\"Added stratification: id='{id}', categories={categories}\")\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.add_parameter","title":"add_parameter","text":"<pre><code>add_parameter(id: str, value: float | str | None, description: str | None = None, unit: str | None = None) -&gt; Self\n</code></pre> <p>Add a global parameter to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the parameter.</p> required <code>value</code> <code>float | str | None</code> <p>Value of the parameter. Can be: - float: A numerical constant value - str: A mathematical formula that can reference other parameters,        special variables (N, N_category, step/t, pi, e), or contain        mathematical expressions (e.g., \"beta * 2\", \"N_young / N\") - None: Indicates that the parameter needs to be calibrated before use</p> <p>Special variables available in formulas: - N: Total population (automatically calculated) - N_{category}: Population in specific category (e.g., N_young, N_old) - N_{cat1}_{cat2}: Population in category combinations - step or t: Current simulation step - pi, e: Mathematical constants</p> required <code>description</code> <code>str | None</code> <p>Human-readable description of the parameter.</p> <code>None</code> <code>unit</code> <code>str | None</code> <p>Unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\"). Used for unit consistency checking in equations.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def add_parameter(\n    self,\n    id: str,\n    value: float | str | None,\n    description: str | None = None,\n    unit: str | None = None,\n) -&gt; Self:\n    \"\"\"\n    Add a global parameter to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the parameter.\n    value : float | str | None\n        Value of the parameter. Can be:\n        - float: A numerical constant value\n        - str: A mathematical formula that can reference other parameters,\n               special variables (N, N_category, step/t, pi, e), or contain\n               mathematical expressions (e.g., \"beta * 2\", \"N_young / N\")\n        - None: Indicates that the parameter needs to be calibrated before use\n\n        Special variables available in formulas:\n        - N: Total population (automatically calculated)\n        - N_{category}: Population in specific category (e.g., N_young, N_old)\n        - N_{cat1}_{cat2}: Population in category combinations\n        - step or t: Current simulation step\n        - pi, e: Mathematical constants\n\n    description : str | None, default=None\n        Human-readable description of the parameter.\n    unit : str | None, default=None\n        Unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\").\n        Used for unit consistency checking in equations.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    self._parameters.append(\n        Parameter(id=id, value=value, description=description, unit=unit)\n    )\n    logging.info(f\"Added parameter: id='{id}', value={value}, unit='{unit}'\")\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.add_transition","title":"add_transition","text":"<pre><code>add_transition(id: str, source: list[str], target: list[str], rate: str | float | None = None, stratified_rates: list[StratifiedRateDict] | None = None, condition: Condition | None = None) -&gt; Self\n</code></pre> <p>Add a transition between states to the model.</p> <p>This method supports two distinct behaviors:</p> <p>When you specify multiple sources without the $compartment placeholder, a SINGLE transition is created that affects all sources simultaneously. The rate is evaluated ONCE per time step, and that value is applied to all source compartments at once.</p> <p>Example:     .add_transition(         id=\"interaction\",         source=[\"S\", \"I\"],         target=[\"I\", \"I\"],         rate=\"beta * S * I\"     )</p> <p>This creates ONE transition where: - The rate \"beta * S * I\" is calculated once - That rate removes from both S and I simultaneously - That rate adds to I twice (once per target entry) - Resulting equations:   dS/dt = ... - (betaSI)   dI/dt = ... - (betaSI) + 2(betaSI) = ... + (betaS*I)</p> <p>When you use the $compartment placeholder in the rate formula with multiple sources, the system automatically expands this into multiple independent transitions - one for each source compartment. Each transition has its own rate calculation where $compartment is replaced with the actual compartment name.</p> <p>Example:     .add_transition(         id=\"death\",         source=[\"S\", \"L\", \"I\", \"R\"],         target=[],         rate=\"d * $compartment\"     )</p> <p>This automatically expands to FOUR separate transitions: - Transition 1: S -&gt; [] with rate \"d * S\" - Transition 2: L -&gt; [] with rate \"d * L\" - Transition 3: I -&gt; [] with rate \"d * I\" - Transition 4: R -&gt; [] with rate \"d * R\"</p> <p>Each transition's rate is evaluated independently, giving per-compartment dynamics. This is ideal for processes like per-capita death rates, where the rate should be proportional to each compartment's population.</p> <p>$compartment Usage Rules: - Only valid when len(source) &gt; 1 - Target must be empty [] or have exactly one element - Can be used with stratified_rates - the placeholder will be expanded in   both the base rate and all stratified rate expressions - The placeholder $compartment will be replaced with each source compartment   name</p> <p>$compartment Restrictions: - Using $compartment with a single source will raise an error (use the   compartment name directly instead) - Using $compartment with multiple targets will raise an error (ambiguous   which target corresponds to which source)</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the transition. When using $compartment expansion, the system will append \"__\" to create unique IDs for each expanded transition (e.g., \"death__S\", \"death__L\"). required <code>source</code> <code>list[str]</code> <p>List of source state/category identifiers. When using $compartment in the rate, each source will generate a separate transition.</p> required <code>target</code> <code>list[str]</code> <p>List of target state/category identifiers. When using $compartment, target must be empty [] or have exactly one element.</p> required <code>rate</code> <code>str | float | None</code> <p>Default mathematical formula, parameter reference, or constant value for the transition rate. Used when no stratified rate matches. Can be: - A parameter reference (e.g., \"beta\") - A constant value (e.g., \"0.5\" or 0.5) - A mathematical formula (e.g., \"beta * S * I / N\") - A formula with $compartment placeholder (e.g., \"d * $compartment\")</p> <p>Special variables available in formulas: - N: Total population (automatically calculated) - step or t: Current simulation step (both are equivalent) - pi, e: Mathematical constants - $compartment: Expands to each source compartment name (only with   multiple sources)</p> <code>None</code> <code>stratified_rates</code> <code>list[dict] | None</code> <p>List of stratification-specific rates. Each dict must contain: - \"conditions\": List of dicts with \"stratification\" and \"category\" keys - \"rate\": Rate expression string</p> <code>None</code> <code>condition</code> <code>Condition | None</code> <p>Logical conditions that must be met for the transition.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If $compartment is used with only one source compartment</li> <li>If $compartment is used with multiple targets</li> <li>If rate is None when using $compartment</li> </ul> <p>Examples:</p> <p>Standard single transition affecting multiple sources:</p> <pre><code>&gt;&gt;&gt; builder.add_transition(\n...     id=\"infection\",\n...     source=[\"S\", \"I\"],\n...     target=[\"I\", \"I\"],\n...     rate=\"beta * S * I / N\",\n... )\n</code></pre> <p>Expanded transitions using $compartment (creates 4 separate transitions):</p> <pre><code>&gt;&gt;&gt; builder.add_transition(\n...     id=\"death\",\n...     source=[\"S\", \"L\", \"I\", \"R\"],\n...     target=[],\n...     rate=\"d * $compartment\",\n... )\n</code></pre> <p>Per-compartment flow with target:</p> <pre><code>&gt;&gt;&gt; builder.add_transition(\n...     id=\"treatment\",\n...     source=[\"I_mild\", \"I_severe\"],\n...     target=[\"R\"],\n...     rate=\"treatment_rate * $compartment\",\n... )\n</code></pre> Source code in <code>commol/api/model_builder.py</code> <pre><code>def add_transition(\n    self,\n    id: str,\n    source: list[str],\n    target: list[str],\n    rate: str | float | None = None,\n    stratified_rates: list[StratifiedRateDict] | None = None,\n    condition: Condition | None = None,\n) -&gt; Self:\n    \"\"\"\n    Add a transition between states to the model.\n\n    This method supports two distinct behaviors:\n\n    When you specify multiple sources without the $compartment placeholder,\n    a SINGLE transition is created that affects all sources simultaneously.\n    The rate is evaluated ONCE per time step, and that value is applied to\n    all source compartments at once.\n\n    Example:\n        .add_transition(\n            id=\"interaction\",\n            source=[\"S\", \"I\"],\n            target=[\"I\", \"I\"],\n            rate=\"beta * S * I\"\n        )\n\n    This creates ONE transition where:\n    - The rate \"beta * S * I\" is calculated once\n    - That rate removes from both S and I simultaneously\n    - That rate adds to I twice (once per target entry)\n    - Resulting equations:\n      dS/dt = ... - (beta*S*I)\n      dI/dt = ... - (beta*S*I) + 2*(beta*S*I) = ... + (beta*S*I)\n\n    When you use the $compartment placeholder in the rate formula with multiple\n    sources, the system automatically expands this into multiple independent\n    transitions - one for each source compartment. Each transition has its own\n    rate calculation where $compartment is replaced with the actual compartment\n    name.\n\n    Example:\n        .add_transition(\n            id=\"death\",\n            source=[\"S\", \"L\", \"I\", \"R\"],\n            target=[],\n            rate=\"d * $compartment\"\n        )\n\n    This automatically expands to FOUR separate transitions:\n    - Transition 1: S -&gt; [] with rate \"d * S\"\n    - Transition 2: L -&gt; [] with rate \"d * L\"\n    - Transition 3: I -&gt; [] with rate \"d * I\"\n    - Transition 4: R -&gt; [] with rate \"d * R\"\n\n    Each transition's rate is evaluated independently, giving per-compartment\n    dynamics. This is ideal for processes like per-capita death rates, where the\n    rate should be proportional to each compartment's population.\n\n    **$compartment Usage Rules**:\n    - Only valid when len(source) &gt; 1\n    - Target must be empty [] or have exactly one element\n    - Can be used with stratified_rates - the placeholder will be expanded in\n      both the base rate and all stratified rate expressions\n    - The placeholder $compartment will be replaced with each source compartment\n      name\n\n    **$compartment Restrictions**:\n    - Using $compartment with a single source will raise an error (use the\n      compartment name directly instead)\n    - Using $compartment with multiple targets will raise an error (ambiguous\n      which target corresponds to which source)\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the transition. When using $compartment expansion,\n        the system will append \"__&lt;compartment_name&gt;\" to create unique IDs for\n        each expanded transition (e.g., \"death__S\", \"death__L\").\n    source : list[str]\n        List of source state/category identifiers. When using $compartment in\n        the rate, each source will generate a separate transition.\n    target : list[str]\n        List of target state/category identifiers. When using $compartment,\n        target must be empty [] or have exactly one element.\n    rate : str | float | None, default=None\n        Default mathematical formula, parameter reference, or constant value for\n        the transition rate. Used when no stratified rate matches.\n        Can be:\n        - A parameter reference (e.g., \"beta\")\n        - A constant value (e.g., \"0.5\" or 0.5)\n        - A mathematical formula (e.g., \"beta * S * I / N\")\n        - A formula with $compartment placeholder (e.g., \"d * $compartment\")\n\n        Special variables available in formulas:\n        - N: Total population (automatically calculated)\n        - step or t: Current simulation step (both are equivalent)\n        - pi, e: Mathematical constants\n        - $compartment: Expands to each source compartment name (only with\n          multiple sources)\n\n    stratified_rates : list[dict] | None, default=None\n        List of stratification-specific rates. Each dict must contain:\n        - \"conditions\": List of dicts with \"stratification\" and \"category\" keys\n        - \"rate\": Rate expression string\n\n    condition : Condition| None, default=None\n        Logical conditions that must be met for the transition.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n\n    Raises\n    ------\n    ValueError\n        - If $compartment is used with only one source compartment\n        - If $compartment is used with multiple targets\n        - If rate is None when using $compartment\n\n    Examples\n    --------\n    Standard single transition affecting multiple sources:\n    &gt;&gt;&gt; builder.add_transition(\n    ...     id=\"infection\",\n    ...     source=[\"S\", \"I\"],\n    ...     target=[\"I\", \"I\"],\n    ...     rate=\"beta * S * I / N\",\n    ... )\n\n    Expanded transitions using $compartment (creates 4 separate transitions):\n    &gt;&gt;&gt; builder.add_transition(\n    ...     id=\"death\",\n    ...     source=[\"S\", \"L\", \"I\", \"R\"],\n    ...     target=[],\n    ...     rate=\"d * $compartment\",\n    ... )\n\n    Per-compartment flow with target:\n    &gt;&gt;&gt; builder.add_transition(\n    ...     id=\"treatment\",\n    ...     source=[\"I_mild\", \"I_severe\"],\n    ...     target=[\"R\"],\n    ...     rate=\"treatment_rate * $compartment\",\n    ... )\n    \"\"\"\n    # Convert rate to string if numeric\n    if isinstance(rate, int) or isinstance(rate, float):\n        rate = str(rate)\n\n    # Check for $compartment placeholder and handle expansion\n    if rate and \"$compartment\" in rate:\n        self._validate_compartment_placeholder(\n            id, source, target, rate, stratified_rates\n        )\n        self._expand_compartment_transition(\n            id, source, target, rate, stratified_rates, condition\n        )\n        return self\n\n    # Convert stratified rates dicts to Pydantic objects\n    stratified_rates_objects: list[StratifiedRate] | None = None\n    if stratified_rates:\n        stratified_rates_objects = []\n        for rate_dict in stratified_rates:\n            conditions = [\n                StratificationCondition(**cond) for cond in rate_dict[\"conditions\"]\n            ]\n            stratified_rates_objects.append(\n                StratifiedRate(conditions=conditions, rate=str(rate_dict[\"rate\"]))\n            )\n\n    self._transitions.append(\n        Transition(\n            id=id,\n            source=source,\n            target=target,\n            rate=rate,\n            stratified_rates=stratified_rates_objects,\n            condition=condition,\n        )\n    )\n    logging.info(\n        (\n            f\"Added transition: id='{id}', source={source}, target={target}, \"\n            f\"rate='{rate}', stratified_rates={\n                len(stratified_rates_objects) if stratified_rates_objects else 0\n            }\"\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.create_condition","title":"create_condition","text":"<pre><code>create_condition(logic: Literal['and', 'or'], rules: list[RuleDict]) -&gt; Condition\n</code></pre> <p>Create a condition object for use in transitions.</p> <p>Parameters:</p> Name Type Description Default <code>logic</code> <code>Literal['and', 'or']</code> <p>How to combine the rules.</p> required <code>rules</code> <code>List[RuleDict]</code> <p>List of rule dictionaries with 'variable', 'operator', and 'value' keys. Each dictionary must have: - 'variable': str (format ':') - 'operator': Literal[\"eq\", \"neq\", \"gt\", \"get\", \"lt\", \"let\"] - 'value': str | int | float | bool required <p>Returns:</p> Type Description <code>Condition</code> <p>The created condition object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; condition = builder.create_condition(\n...     \"and\",\n...     [\n...         {\"variable\": \"states:I\", \"operator\": \"gt\", \"value\": 0},\n...         {\"variable\": \"strati:age\", \"operator\": \"eq\", \"value\": \"adult\"},\n...     ],\n... )\n</code></pre> Source code in <code>commol/api/model_builder.py</code> <pre><code>def create_condition(\n    self,\n    logic: Literal[\"and\", \"or\"],\n    rules: list[RuleDict],\n) -&gt; Condition:\n    \"\"\"\n    Create a condition object for use in transitions.\n\n    Parameters\n    ----------\n    logic : Literal[\"and\", \"or\"]\n        How to combine the rules.\n    rules : List[RuleDict]\n        List of rule dictionaries with 'variable', 'operator', and 'value' keys.\n        Each dictionary must have:\n        - 'variable': str (format '&lt;prefix&gt;:&lt;variable_id&gt;')\n        - 'operator': Literal[\"eq\", \"neq\", \"gt\", \"get\", \"lt\", \"let\"]\n        - 'value': str | int | float | bool\n\n    Returns\n    -------\n    Condition\n        The created condition object.\n\n    Examples\n    --------\n    &gt;&gt;&gt; condition = builder.create_condition(\n    ...     \"and\",\n    ...     [\n    ...         {\"variable\": \"states:I\", \"operator\": \"gt\", \"value\": 0},\n    ...         {\"variable\": \"strati:age\", \"operator\": \"eq\", \"value\": \"adult\"},\n    ...     ],\n    ... )\n    \"\"\"\n    rule_objects: list[Rule] = []\n    for rule_dict in rules:\n        rule_objects.append(\n            Rule(\n                variable=rule_dict[\"variable\"],\n                operator=rule_dict[\"operator\"],\n                value=rule_dict[\"value\"],\n            )\n        )\n\n    return Condition(\n        logic=cast(\n            Literal[LogicOperators.AND, LogicOperators.OR], LogicOperators(logic)\n        ),\n        rules=rule_objects,\n    )\n</code></pre> <p>options: show_root_heading: true show_source: true heading_level: 2 show_docstring_attributes: false</p>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.set_initial_conditions","title":"set_initial_conditions","text":"<pre><code>set_initial_conditions(population_size: int, bin_fractions: list[BinFractionDict], stratification_fractions: list[StratificationFractionsDict] | None = None) -&gt; Self\n</code></pre> <p>Set the initial conditions for the model.</p> <p>Parameters:</p> Name Type Description Default <code>population_size</code> <code>int</code> <p>Total population size.</p> required <code>bin_fractions</code> <code>list[BinFractionDict]</code> <p>List of bin fractions. Each item is a dictionary with: - \"bin\": str (bin id) - \"fraction\": float (fractional size)</p> <p>Example: [     {\"bin\": \"S\", \"fraction\": 0.99},     {\"bin\": \"I\", \"fraction\": 0.01},     {\"bin\": \"R\", \"fraction\": 0.0} ]</p> required <code>stratification_fractions</code> <code>(list[StratificationFractionsDict] | None,)</code> <p>default=None List of stratification fractions. Each item is a dictionary with: - \"stratification\": str (stratification id) - \"fractions\": list of dicts, each with \"category\" and \"fraction\"</p> <p>Example: [     {         \"stratification\": \"age_group\",         \"fractions\": [             {\"category\": \"young\", \"fraction\": 0.3},             {\"category\": \"adult\", \"fraction\": 0.5},             {\"category\": \"elderly\", \"fraction\": 0.2}         ]     } ]</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If initial conditions have already been set.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def set_initial_conditions(\n    self,\n    population_size: int,\n    bin_fractions: list[BinFractionDict],\n    stratification_fractions: list[StratificationFractionsDict] | None = None,\n) -&gt; Self:\n    \"\"\"\n    Set the initial conditions for the model.\n\n    Parameters\n    ----------\n    population_size : int\n        Total population size.\n    bin_fractions : list[BinFractionDict]\n        List of bin fractions. Each item is a dictionary with:\n        - \"bin\": str (bin id)\n        - \"fraction\": float (fractional size)\n\n        Example:\n        [\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    stratification_fractions : list[StratificationFractionsDict] | None,\n        default=None\n        List of stratification fractions. Each item is a dictionary with:\n        - \"stratification\": str (stratification id)\n        - \"fractions\": list of dicts, each with \"category\" and \"fraction\"\n\n        Example:\n        [\n            {\n                \"stratification\": \"age_group\",\n                \"fractions\": [\n                    {\"category\": \"young\", \"fraction\": 0.3},\n                    {\"category\": \"adult\", \"fraction\": 0.5},\n                    {\"category\": \"elderly\", \"fraction\": 0.2}\n                ]\n            }\n        ]\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n\n    Raises\n    ------\n    ValueError\n        If initial conditions have already been set.\n    \"\"\"\n    if self._initial_conditions is not None:\n        raise ValueError(\"Initial conditions have already been set\")\n\n    bin_fractions_list: list[BinFraction] = []\n    for bf_dict in bin_fractions:\n        bin_fractions_list.append(\n            BinFraction(\n                bin=bf_dict[\"bin\"],\n                fraction=bf_dict[\"fraction\"],\n            )\n        )\n\n    strat_fractions_list: list[StratificationFractions] = []\n    if stratification_fractions:\n        for strat_dict in stratification_fractions:\n            fractions_list: list[StratificationFraction] = []\n            for frac_dict in strat_dict[\"fractions\"]:\n                fractions_list.append(\n                    StratificationFraction(\n                        category=frac_dict[\"category\"],\n                        fraction=frac_dict[\"fraction\"],\n                    )\n                )\n            strat_fractions_list.append(\n                StratificationFractions(\n                    stratification=strat_dict[\"stratification\"],\n                    fractions=fractions_list,\n                )\n            )\n\n    self._initial_conditions = InitialConditions(\n        population_size=population_size,\n        bin_fractions=bin_fractions_list,\n        stratification_fractions=strat_fractions_list,\n    )\n    bin_ids = [bf[\"bin\"] for bf in bin_fractions]\n    logging.info(\n        (\n            f\"Set initial conditions: population_size={population_size}, \"\n            f\"bins={bin_ids}\"\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.get_summary","title":"get_summary","text":"<pre><code>get_summary() -&gt; dict[str, str | int | list[str] | None]\n</code></pre> <p>Get a summary of the current model builder state.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, str | int | list[str] | None]]</code> <p>Dictionary containing summary information about the model being built.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def get_summary(self) -&gt; dict[str, str | int | list[str] | None]:\n    \"\"\"\n    Get a summary of the current model builder state.\n\n    Returns\n    -------\n    dict[str, dict[str, str | int | list[str] | None]]\n        Dictionary containing summary information about the model being built.\n    \"\"\"\n    return {\n        \"name\": self._name,\n        \"description\": self._description,\n        \"version\": self._version,\n        \"disease_states_count\": len(self._bins),\n        \"bin_ids\": [state.id for state in self._bins],\n        \"stratifications_count\": len(self._stratifications),\n        \"stratification_ids\": [strat.id for strat in self._stratifications],\n        \"transitions_count\": len(self._transitions),\n        \"transition_ids\": [trans.id for trans in self._transitions],\n        \"parameters_count\": len(self._parameters),\n        \"parameter_ids\": [param.id for param in self._parameters],\n        \"has_initial_conditions\": self._initial_conditions is not None,\n    }\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.clone","title":"clone","text":"<pre><code>clone() -&gt; Self\n</code></pre> <p>Create a deep copy of this ModelBuilder.</p> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>A new ModelBuilder instance with the same configuration.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def clone(self) -&gt; Self:\n    \"\"\"\n    Create a deep copy of this ModelBuilder.\n\n    Returns\n    -------\n    ModelBuilder\n        A new ModelBuilder instance with the same configuration.\n    \"\"\"\n\n    new_builder = type(self)(self._name, self._description, self._version)\n\n    new_builder._bins = copy.deepcopy(self._bins)\n    new_builder._stratifications = copy.deepcopy(self._stratifications)\n    new_builder._transitions = copy.deepcopy(self._transitions)\n    new_builder._parameters = copy.deepcopy(self._parameters)\n    new_builder._initial_conditions = copy.deepcopy(self._initial_conditions)\n\n    return new_builder\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.reset","title":"reset","text":"<pre><code>reset() -&gt; Self\n</code></pre> <p>Reset the builder to empty state while keeping name, description, and version.</p> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def reset(self) -&gt; Self:\n    \"\"\"\n    Reset the builder to empty state while keeping name, description, and version.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    self._bins.clear()\n    self._stratifications.clear()\n    self._transitions.clear()\n    self._parameters.clear()\n    self._initial_conditions = None\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.build","title":"build","text":"<pre><code>build(typology: Literal['DifferenceEquations']) -&gt; Model\n</code></pre> <p>Build and return the final Model instance.</p> <p>Parameters:</p> Name Type Description Default <code>typology</code> <code>Literal['DifferenceEquations']</code> <p>Type of the model.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>The constructed compartment model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails or required components are missing.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def build(self, typology: Literal[\"DifferenceEquations\"]) -&gt; Model:\n    \"\"\"\n    Build and return the final Model instance.\n\n    Parameters\n    ----------\n    typology : Literal[\"DifferenceEquations\"]\n        Type of the model.\n\n    Returns\n    -------\n    Model\n        The constructed compartment model.\n\n    Raises\n    ------\n    ValueError\n        If validation fails or required components are missing.\n    \"\"\"\n    if self._initial_conditions is None:\n        raise ValueError(\"Initial conditions must be set\")\n\n    population = Population(\n        bins=self._bins,\n        stratifications=self._stratifications,\n        transitions=self._transitions,\n        initial_conditions=self._initial_conditions,\n    )\n\n    dynamics = Dynamics(\n        typology=cast(\n            Literal[ModelTypes.DIFFERENCE_EQUATIONS], ModelTypes(typology)\n        ),\n        transitions=self._transitions,\n    )\n\n    model = Model(\n        name=self._name,\n        description=self._description,\n        version=self._version,\n        population=population,\n        parameters=self._parameters,\n        dynamics=dynamics,\n    )\n\n    logging.info(\n        f\"Model '{self._name}' successfully built with typology '{typology}'.\"\n    )\n\n    return model\n</code></pre>"},{"location":"api/simulation/","title":"Simulation API","text":"<p>options: show_root_heading: true show_source: true heading_level: 2 show_docstring_attributes: false</p>"},{"location":"api/simulation/#commol.api.simulation.Simulation","title":"Simulation","text":"<p>A Facade for running a simulation from a defined Model.</p> Source code in <code>commol/api/simulation.py</code> <pre><code>class Simulation:\n    \"\"\"\n    A Facade for running a simulation from a defined Model.\n    \"\"\"\n\n    def __init__(self, model: Model):\n        \"\"\"\n        Initializes the simulation engine from a Pydantic Model definition.\n\n        Parameters\n        ----------\n        model : Model\n            A fully constructed and validated model object.\n            None values for parameters/initial conditions if used for calibration.\n\n        \"\"\"\n        logging.info(f\"Initializing Simulation with model: '{model.name}'\")\n        self.model_definition: Model = model\n\n        self._engine: \"DifferenceEquationsProtocol\" = self._initialize_engine()\n\n        self._compartments: list[str] = self._engine.compartments\n        logging.info(\n            f\"Simulation engine ready. Total compartments: {len(self._compartments)}\"\n        )\n\n    def _validate_all_parameters_calibrated(self, model: Model) -&gt; None:\n        \"\"\"\n        Validates that all parameters and initial conditions have values\n        (are calibrated).\n\n        Parameters\n        ----------\n        model : Model\n            The model to validate.\n\n        Raises\n        ------\n        ValueError\n            If any parameter or initial condition has a None value.\n        \"\"\"\n        uncalibrated_params = model.get_uncalibrated_parameters()\n        uncalibrated_ics = model.get_uncalibrated_initial_conditions()\n\n        errors = []\n        if uncalibrated_params:\n            errors.append(\n                f\"Parameters requiring calibration: {', '.join(uncalibrated_params)}\"\n            )\n        if uncalibrated_ics:\n            errors.append(\n                f\"Initial conditions requiring calibration: \"\n                f\"{', '.join(uncalibrated_ics)}\"\n            )\n\n        if errors:\n            raise ValueError(\n                f\"Cannot run Simulation: {'; '.join(errors)}. \"\n                f\"Please calibrate these values before running a simulation.\"\n            )\n\n    def _initialize_engine(self) -&gt; \"DifferenceEquationsProtocol\":\n        \"\"\"Internal method to set up the Rust backend.\"\"\"\n        logging.info(\"Preparing model definition for Rust serialization...\")\n        model_json = self.model_definition.model_dump_json()\n\n        rust_model_instance: \"RustModelProtocol\" = core.Model.from_json(model_json)\n        logging.info(\"Rust model instance created from JSON.\")\n\n        # This could be extended if you have more engine types\n        if self.model_definition.dynamics.typology == ModelTypes.DIFFERENCE_EQUATIONS:\n            logging.info(\"Initializing DifferenceEquations engine.\")\n            return difference.DifferenceEquations(rust_model_instance)\n\n        raise NotImplementedError(\n            (\n                f\"Engine for typology '{self.model_definition.dynamics.typology}' \"\n                f\"not implemented.\"\n            )\n        )\n\n    def _run_raw(self, num_steps: int) -&gt; list[list[float]]:\n        \"\"\"\n        Runs the simulation and returns the raw, high-performance output.\n        This is the fastest method, returning a list of lists of floats.\n        \"\"\"\n        logging.info(f\"Running raw simulation for {num_steps} steps.\")\n        start = time.time()\n        results = self._engine.run(num_steps)\n        end = time.time()\n        logging.info(f\"Raw simulation complete. It tool {end - start} seconds.\")\n        return results\n\n    @overload\n    def run(\n        self, num_steps: int, output_format: Literal[\"list_of_lists\"]\n    ) -&gt; list[list[float]]: ...\n    @overload\n    def run(\n        self, num_steps: int, output_format: Literal[\"dict_of_lists\"]\n    ) -&gt; dict[str, list[float]]: ...\n    @overload\n    def run(self, num_steps: int) -&gt; dict[str, list[float]]: ...\n    def run(\n        self,\n        num_steps: int,\n        output_format: Literal[\"dict_of_lists\", \"list_of_lists\"] = \"dict_of_lists\",\n    ) -&gt; dict[str, list[float]] | list[list[float]]:\n        \"\"\"\n        Runs the simulation and returns the output in the specified format.\n\n        Parameters\n        ----------\n        num_steps : int\n            The number of steps for the simulation.\n        output_format : {'dict_of_lists', 'list_of_lists'}, default 'dict_of_lists'\n            - 'dict_of_lists': Returns a dictionary of lists, with compartment names\n                as keys.\n            - 'list_of_lists': Returns a list of lists of floats, where the first level\n                is the step and the second level the comptarment.\n\n        Returns\n        -------\n        dict[str, list[float]] | list[list[float]]\n            The simulation results in the specified format.\n        \"\"\"\n        self._validate_all_parameters_calibrated(self.model_definition)\n        raw_results = self._run_raw(num_steps)\n        if output_format == \"list_of_lists\":\n            logging.info(\"Returning results in 'list_of_lists' format.\")\n            return raw_results\n\n        elif output_format == \"dict_of_lists\":\n            logging.info(\"Transposing raw results to 'dict_of_lists' format.\")\n            if not raw_results:\n                return {c: [] for c in self._compartments}\n            transposed_results = zip(*raw_results)\n            return {\n                compartment: list(values)\n                for compartment, values in zip(self._compartments, transposed_results)\n            }\n\n        else:\n            assert_never(output_format)\n\n    @property\n    def engine(self) -&gt; \"DifferenceEquationsProtocol\":\n        \"\"\"Get the underlying simulation engine.\"\"\"\n        return self._engine\n</code></pre>"},{"location":"api/simulation/#commol.api.simulation.Simulation-attributes","title":"Attributes","text":""},{"location":"api/simulation/#commol.api.simulation.Simulation.engine","title":"engine  <code>property</code>","text":"<pre><code>engine: DifferenceEquationsProtocol\n</code></pre> <p>Get the underlying simulation engine.</p>"},{"location":"api/simulation/#commol.api.simulation.Simulation-functions","title":"Functions","text":""},{"location":"api/simulation/#commol.api.simulation.Simulation.__init__","title":"__init__","text":"<pre><code>__init__(model: Model)\n</code></pre> <p>Initializes the simulation engine from a Pydantic Model definition.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>A fully constructed and validated model object. None values for parameters/initial conditions if used for calibration.</p> required Source code in <code>commol/api/simulation.py</code> <pre><code>def __init__(self, model: Model):\n    \"\"\"\n    Initializes the simulation engine from a Pydantic Model definition.\n\n    Parameters\n    ----------\n    model : Model\n        A fully constructed and validated model object.\n        None values for parameters/initial conditions if used for calibration.\n\n    \"\"\"\n    logging.info(f\"Initializing Simulation with model: '{model.name}'\")\n    self.model_definition: Model = model\n\n    self._engine: \"DifferenceEquationsProtocol\" = self._initialize_engine()\n\n    self._compartments: list[str] = self._engine.compartments\n    logging.info(\n        f\"Simulation engine ready. Total compartments: {len(self._compartments)}\"\n    )\n</code></pre>"},{"location":"api/simulation/#commol.api.simulation.Simulation.run","title":"run","text":"<pre><code>run(num_steps: int, output_format: Literal['list_of_lists']) -&gt; list[list[float]]\n</code></pre><pre><code>run(num_steps: int, output_format: Literal['dict_of_lists']) -&gt; dict[str, list[float]]\n</code></pre><pre><code>run(num_steps: int) -&gt; dict[str, list[float]]\n</code></pre> <pre><code>run(num_steps: int, output_format: Literal['dict_of_lists', 'list_of_lists'] = 'dict_of_lists') -&gt; dict[str, list[float]] | list[list[float]]\n</code></pre> <p>Runs the simulation and returns the output in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>The number of steps for the simulation.</p> required <code>output_format</code> <code>(dict_of_lists, list_of_lists)</code> <ul> <li>'dict_of_lists': Returns a dictionary of lists, with compartment names     as keys.</li> <li>'list_of_lists': Returns a list of lists of floats, where the first level     is the step and the second level the comptarment.</li> </ul> <code>'dict_of_lists'</code> <p>Returns:</p> Type Description <code>dict[str, list[float]] | list[list[float]]</code> <p>The simulation results in the specified format.</p> Source code in <code>commol/api/simulation.py</code> <pre><code>def run(\n    self,\n    num_steps: int,\n    output_format: Literal[\"dict_of_lists\", \"list_of_lists\"] = \"dict_of_lists\",\n) -&gt; dict[str, list[float]] | list[list[float]]:\n    \"\"\"\n    Runs the simulation and returns the output in the specified format.\n\n    Parameters\n    ----------\n    num_steps : int\n        The number of steps for the simulation.\n    output_format : {'dict_of_lists', 'list_of_lists'}, default 'dict_of_lists'\n        - 'dict_of_lists': Returns a dictionary of lists, with compartment names\n            as keys.\n        - 'list_of_lists': Returns a list of lists of floats, where the first level\n            is the step and the second level the comptarment.\n\n    Returns\n    -------\n    dict[str, list[float]] | list[list[float]]\n        The simulation results in the specified format.\n    \"\"\"\n    self._validate_all_parameters_calibrated(self.model_definition)\n    raw_results = self._run_raw(num_steps)\n    if output_format == \"list_of_lists\":\n        logging.info(\"Returning results in 'list_of_lists' format.\")\n        return raw_results\n\n    elif output_format == \"dict_of_lists\":\n        logging.info(\"Transposing raw results to 'dict_of_lists' format.\")\n        if not raw_results:\n            return {c: [] for c in self._compartments}\n        transposed_results = zip(*raw_results)\n        return {\n            compartment: list(values)\n            for compartment, values in zip(self._compartments, transposed_results)\n        }\n\n    else:\n        assert_never(output_format)\n</code></pre>"},{"location":"development/contributing/","title":"Contributing Guidelines","text":"<p>Thank you for considering contributing to EpiModel! This document provides guidelines for contributing to the project.</p>"},{"location":"development/contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"development/contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>Before creating a bug report:</p> <ul> <li>Check the issue tracker for existing reports</li> <li>Verify the bug exists in the latest version</li> </ul> <p>When creating a bug report, include:</p> <ul> <li>Clear title and description</li> <li>Steps to reproduce the issue</li> <li>Expected vs actual behavior</li> <li>Environment details (OS, Python version, EpiModel version)</li> <li>Code samples or test cases that demonstrate the problem</li> </ul>"},{"location":"development/contributing/#suggesting-features","title":"Suggesting Features","text":"<p>Feature suggestions are welcome! Please:</p> <ul> <li>Check if the feature has already been requested</li> <li>Provide a clear use case and rationale</li> <li>Describe the desired API or interface</li> <li>Consider implementation complexity vs benefit</li> </ul>"},{"location":"development/contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Keep PRs focused: One feature/fix per PR</li> <li>Write tests: All new code should have tests</li> <li>Update docs: Update README or documentation as needed</li> <li>Follow conventions: Use the project's code style</li> <li>Be descriptive: Write clear commit messages and PR descriptions</li> </ol>"},{"location":"development/contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"development/contributing/#code-style","title":"Code Style","text":""},{"location":"development/contributing/#python","title":"Python","text":"<ul> <li>Follow PEP 8</li> <li>Use type hints for all functions</li> <li>Maximum line length: 88 characters</li> <li>Use Ruff for linting and formatting</li> </ul> <pre><code>cd py-commol\npoetry run ruff check .\npoetry run ruff format .\npoetry run mypy epimodel\n</code></pre>"},{"location":"development/contributing/#rust","title":"Rust","text":"<ul> <li>Follow Rust API Guidelines</li> <li>Use <code>cargo fmt</code> for formatting</li> <li>Use <code>cargo clippy</code> for linting</li> <li>Document public APIs with rustdoc</li> </ul> <pre><code>cargo fmt --all\ncargo clippy --all-targets --all-features\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#python-tests","title":"Python Tests","text":"<ul> <li>Write tests using pytest</li> <li>Aim for &gt;95% code coverage</li> <li>Test both success and error cases</li> <li>Use descriptive test names</li> </ul> <pre><code>def test_model_builder_creates_valid_sir_model():\n    \"\"\"Test that ModelBuilder creates a valid SIR model.\"\"\"\n    model = (\n        ModelBuilder(name=\"Test SIR\")\n        .add_bin(id=\"S\", name=\"Susceptible\")\n        # ... rest of model\n        .build(ModelTypes.DIFFERENCE_EQUATIONS)\n    )\n    assert model.name == \"Test SIR\"\n</code></pre> <p>Run tests:</p> <pre><code>cd py-commol\npoetry run pytest -v --cov=epimodel\n</code></pre>"},{"location":"development/contributing/#rust-tests","title":"Rust Tests","text":"<ul> <li>Write unit tests in the same file</li> <li>Write integration tests in <code>tests/</code> directory</li> <li>Use <code>#[should_panic]</code> for error cases</li> </ul> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_model_creation() {\n        // Test implementation\n    }\n}\n</code></pre> <p>Run tests:</p> <pre><code>cargo test --workspace\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":""},{"location":"development/contributing/#python-docstrings","title":"Python Docstrings","text":"<p>Use NumPy-style docstrings:</p> <pre><code>def run(self, num_steps: int, output_format: str = \"dict_of_lists\") -&gt; dict:\n    \"\"\"\n    Runs the simulation and returns results.\n\n    Parameters\n    ----------\n    num_steps : int\n        Number of simulation steps to run.\n    output_format : str, default 'dict_of_lists'\n        Format for results ('dict_of_lists' or 'list_of_lists').\n\n    Returns\n    -------\n    dict\n        Simulation results in the specified format.\n\n    Raises\n    ------\n    ValueError\n        If num_steps is negative.\n\n    Examples\n    --------\n    &gt;&gt;&gt; sim = Simulation(model)\n    &gt;&gt;&gt; results = sim.run(num_steps=100)\n    \"\"\"\n</code></pre>"},{"location":"development/contributing/#rust-documentation","title":"Rust Documentation","text":"<p>Use rustdoc:</p> <pre><code>/// Runs the simulation for a given number of steps.\n///\n/// # Arguments\n///\n/// * `num_steps` - The number of time steps to simulate\n///\n/// # Returns\n///\n/// A vector of state vectors, one per time step\n///\n/// # Examples\n///\n/// ```\n/// let results = engine.run(100);\n/// assert_eq!(results.len(), 100);\n/// ```\npub fn run(&amp;self, num_steps: usize) -&gt; Vec&lt;Vec&lt;f64&gt;&gt; {\n    // Implementation\n}\n</code></pre>"},{"location":"development/contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow Conventional Commits:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Code style (formatting, missing semicolons, etc.)</li> <li><code>refactor</code>: Code refactoring</li> <li><code>perf</code>: Performance improvements</li> <li><code>test</code>: Adding or updating tests</li> <li><code>build</code>: Build system or dependencies</li> <li><code>ci</code>: CI/CD changes</li> <li><code>chore</code>: Other changes (releasing, etc.)</li> </ul> <p>Examples:</p> <pre><code>feat(transitions): add support for time-dependent rates\n\nImplemented mathematical expression parsing for dynamic\ntransition rates that change over time.\n\nCloses #123\n</code></pre> <pre><code>fix(simulation): prevent negative population values\n\nAdded validation to ensure compartment populations\nremain non-negative during simulation.\n</code></pre>"},{"location":"development/contributing/#code-review-process","title":"Code Review Process","text":""},{"location":"development/contributing/#for-contributors","title":"For Contributors","text":"<ol> <li>Respond to feedback promptly and professionally</li> <li>Make requested changes or discuss alternatives</li> <li>Keep the PR updated with the target branch</li> <li>Test locally before requesting re-review</li> </ol>"},{"location":"development/contributing/#for-reviewers","title":"For Reviewers","text":"<ol> <li>Be constructive and respectful</li> <li>Explain reasoning for requested changes</li> <li>Acknowledge good work when you see it</li> <li>Test the changes when possible</li> </ol>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<p>See Release Process for details on versioning and releases.</p>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check the docs</li> <li>Discussions: Use GitHub Discussions</li> <li>Issues: Report bugs via GitHub Issues</li> </ul>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors will be recognized in:</p> <ul> <li>The project's AUTHORS file</li> <li>Release notes for significant contributions</li> <li>GitHub's contributor graph</li> </ul> <p>Thank you for contributing to EpiModel! \ud83c\udf89</p>"},{"location":"development/release/","title":"Release Process","text":"<p>EpiModel follows Semantic Versioning (SemVer) for version numbering: <code>MAJOR.MINOR.PATCH</code></p>"},{"location":"development/release/#version-guidelines","title":"Version Guidelines","text":""},{"location":"development/release/#major-version-x00","title":"MAJOR version (X.0.0)","text":"<p>Incremented for incompatible API changes:</p> <ul> <li>Breaking changes to public API</li> <li>Removal of deprecated features</li> <li>Major architectural changes affecting backwards compatibility</li> <li>Example: Changing method signatures, removing public methods</li> </ul>"},{"location":"development/release/#minor-version-0x0","title":"MINOR version (0.X.0)","text":"<p>Incremented for backwards-compatible new features:</p> <ul> <li>New functionality added</li> <li>New disease states, stratifications, or transition types</li> <li>Performance improvements without API changes</li> <li>Deprecation notices (without removal)</li> <li>Example: Adding new mathematical functions, new model types</li> </ul>"},{"location":"development/release/#patch-version-00x","title":"PATCH version (0.0.X)","text":"<p>Incremented for backwards-compatible bug fixes:</p> <ul> <li>Bug fixes that don't change the API</li> <li>Documentation improvements</li> <li>Internal refactoring</li> <li>Security patches</li> <li>Example: Fixing calculation errors, typos in error messages</li> </ul>"},{"location":"development/release/#release-workflow","title":"Release Workflow","text":""},{"location":"development/release/#step-1-prepare-the-release","title":"Step 1: Prepare the Release","text":""},{"location":"development/release/#11-update-version-numbers","title":"1.1 Update Version Numbers","text":"<p>Edit the following files:</p> <ul> <li><code>py-commol/pyproject.toml</code> - Update <code>version</code> field</li> <li><code>Cargo.toml</code> - Update <code>[workspace.package]</code> version</li> </ul> <pre><code># py-commol/pyproject.toml\n[tool.poetry]\nversion = \"1.2.3\"\n\n# Cargo.toml\n[workspace.package]\nversion = \"1.2.3\"\n</code></pre>"},{"location":"development/release/#12-update-changelog-if-maintained","title":"1.2 Update CHANGELOG (if maintained)","text":"<p>Document all changes under the new version:</p> <pre><code>## [1.2.3] - 2024-12-15\n\n### Added\n\n- New mathematical functions for transition rates\n- Support for multi-compartment transitions\n\n### Changed\n\n- Improved simulation performance by 20%\n\n### Fixed\n\n- Fixed population conservation bug in stratified models\n- Corrected type hints in Simulation class\n\n### Security\n\n- Updated dependencies to patch vulnerabilities\n</code></pre>"},{"location":"development/release/#13-run-quality-checks","title":"1.3 Run Quality Checks","text":"<pre><code># Python checks\ncd py-commol\npoetry run ruff check .\npoetry run ruff format .\npoetry run mypy epimodel\npoetry run pytest\n\n# Rust checks\ncd ..\ncargo fmt --all\ncargo clippy --all-targets --all-features\ncargo test --workspace\n</code></pre>"},{"location":"development/release/#14-commit-version-changes","title":"1.4 Commit Version Changes","text":"<pre><code>git add py-commol/pyproject.toml Cargo.toml CHANGELOG.md\ngit commit -m \"chore: bump version to X.Y.Z\"\ngit push origin main\n</code></pre>"},{"location":"development/release/#step-2-create-github-release","title":"Step 2: Create GitHub Release","text":""},{"location":"development/release/#21-create-tag","title":"2.1 Create Tag","text":"<pre><code>git tag -a vX.Y.Z -m \"Release version X.Y.Z\"\ngit push origin vX.Y.Z\n</code></pre>"},{"location":"development/release/#22-create-github-release","title":"2.2 Create GitHub Release","text":"<ol> <li>Go to Releases page</li> <li>Click \"Draft a new release\"</li> <li>Select tag: <code>vX.Y.Z</code></li> <li>Set release title: <code>Version X.Y.Z</code></li> <li>Add release notes:</li> </ol> <pre><code>## What's New in X.Y.Z\n\n### New Features\n\n- Feature 1 description\n- Feature 2 description\n\n### Bug Fixes\n\n- Fix 1 description\n- Fix 2 description\n\n### Documentation\n\n- Documentation improvements\n\n### Performance\n\n- Performance improvements\n\n## Breaking Changes (for major versions)\n\n- List breaking changes\n- Migration guide\n\n## Installation\n\npip install epimodel==X.Y.Z\n\n## Full Changelog\n\nSee [CHANGELOG.md](https://github.com/MUNQU/commol/blob/main/CHANGELOG.md)\n</code></pre> <ol> <li>Click \"Publish release\"</li> </ol>"},{"location":"development/release/#step-3-automated-pypi-publication","title":"Step 3: Automated PyPI Publication","text":"<p>Once the release is published, the GitHub Actions workflow automatically:</p> <ol> <li>Builds wheels for Linux, Windows, and macOS</li> <li>Creates source distribution (sdist)</li> <li>Publishes to PyPI using trusted publishing</li> </ol> <p>Monitor progress:</p> <ul> <li>Go to Actions tab</li> <li>Watch the \"Release to PyPI\" workflow</li> </ul>"},{"location":"development/release/#step-4-verify-the-release","title":"Step 4: Verify the Release","text":""},{"location":"development/release/#41-check-pypi","title":"4.1 Check PyPI","text":"<p>Verify the package appears at: https://pypi.org/project/epimodel/</p>"},{"location":"development/release/#42-test-installation","title":"4.2 Test Installation","text":"<pre><code># Create fresh virtual environment\npython -m venv test_env\nsource test_env/bin/activate  # or test_env\\Scripts\\activate on Windows\n\n# Install the new version\npip install epimodel==X.Y.Z\n\n# Verify it works\npython -c \"from commol import ModelBuilder; print('Success!')\"\n</code></pre>"},{"location":"development/release/#43-test-functionality","title":"4.3 Test Functionality","text":"<pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n\n# Run a quick test\nmodel = (\n    ModelBuilder(name=\"Test\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"N\", value=1000.0)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsim = Simulation(model)\nresults = sim.run(num_steps=100)\nprint(f\"Final infected: {results['I'][-1]:.0f}\")\n</code></pre>"},{"location":"development/release/#step-5-sync-branches","title":"Step 5: Sync Branches","text":"<pre><code># Merge main back to develop\ngit checkout develop\ngit merge main\ngit push origin develop\n</code></pre>"},{"location":"development/release/#pre-release-versions","title":"Pre-release Versions","text":"<p>For testing before official release:</p>"},{"location":"development/release/#alpha-releases","title":"Alpha Releases","text":"<pre><code># Version: X.Y.Z-alpha.N\ngit tag -a v1.3.0-alpha.1 -m \"Alpha release for testing\"\ngit push origin v1.3.0-alpha.1\n</code></pre>"},{"location":"development/release/#beta-releases","title":"Beta Releases","text":"<pre><code># Version: X.Y.Z-beta.N\ngit tag -a v1.3.0-beta.1 -m \"Beta release for testing\"\ngit push origin v1.3.0-beta.1\n</code></pre>"},{"location":"development/release/#release-candidates","title":"Release Candidates","text":"<pre><code># Version: X.Y.Z-rc.N\ngit tag -a v1.3.0-rc.1 -m \"Release candidate\"\ngit push origin v1.3.0-rc.1\n</code></pre> <p>Important: Mark GitHub releases as \"pre-release\" to prevent automatic PyPI publication.</p>"},{"location":"development/release/#version-support-policy","title":"Version Support Policy","text":"<ul> <li>Latest version: Fully supported with new features and bug fixes</li> <li>Older versions: No support, users encouraged to upgrade</li> </ul>"},{"location":"development/release/#pypi-trusted-publishing-setup","title":"PyPI Trusted Publishing Setup","text":"<p>To enable automated PyPI publishing, configure trusted publishing:</p> <ol> <li>Go to PyPI and log in</li> <li>Go to your project settings</li> <li>Navigate to \"Publishing\" section</li> <li>Add GitHub as a trusted publisher:</li> <li>Owner: MUNQU</li> <li>Repository: epimodel</li> <li>Workflow: release.yml</li> <li>Environment: pypi</li> </ol> <p>This allows GitHub Actions to publish without API tokens.</p>"},{"location":"development/release/#release-checklist","title":"Release Checklist","text":"<ul> <li>[ ] Version updated in <code>pyproject.toml</code></li> <li>[ ] Version updated in <code>Cargo.toml</code></li> <li>[ ] CHANGELOG updated with all changes</li> <li>[ ] All tests passing locally</li> <li>[ ] Version committed and pushed to main</li> <li>[ ] Git tag created and pushed</li> <li>[ ] GitHub release created with notes</li> <li>[ ] CI/CD pipeline completed successfully</li> <li>[ ] Package verified on PyPI</li> <li>[ ] Installation tested in clean environment</li> <li>[ ] Main merged back to develop</li> <li>[ ] Release announced (if applicable)</li> </ul>"},{"location":"development/release/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/release/#pypi-upload-fails","title":"PyPI Upload Fails","text":"<ol> <li>Check GitHub Actions logs</li> <li>Verify trusted publishing is configured</li> <li>Ensure version number is unique (not already on PyPI)</li> <li>Check for artifact build errors</li> </ol>"},{"location":"development/release/#wheel-build-fails","title":"Wheel Build Fails","text":"<ol> <li>Check that Rust code compiles on all platforms</li> <li>Verify maturin configuration is correct</li> <li>Check for platform-specific dependencies</li> </ol>"},{"location":"development/release/#version-conflicts","title":"Version Conflicts","text":"<ol> <li>Ensure version is updated in all required files</li> <li>Use <code>git tag -d vX.Y.Z</code> to delete incorrect tags locally</li> <li>Use <code>git push origin :refs/tags/vX.Y.Z</code> to delete remote tags</li> </ol>"},{"location":"development/workflow/","title":"Development Workflow","text":""},{"location":"development/workflow/#development-setup","title":"Development Setup","text":"<p>EpiModel is built with Rust and Python. To set up your development environment:</p>"},{"location":"development/workflow/#1-install-prerequisites","title":"1. Install Prerequisites","text":"<pre><code># Install Rust toolchain\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Install Python 3.11 or higher\n# (use your system's package manager)\n\n# Install Poetry\ncurl -sSL https://install.python-poetry.org | python3 -\n</code></pre>"},{"location":"development/workflow/#2-clone-and-setup","title":"2. Clone and Setup","text":"<pre><code>git clone https://github.com/MUNQU/commol.git\ncd epimodel\n\n# Install Python dependencies\ncd py-commol\npoetry install --with dev\n\n# Install pre-commit hooks (optional but recommended)\npoetry run pre-commit install\n</code></pre>"},{"location":"development/workflow/#3-build-the-project","title":"3. Build the Project","text":"<pre><code># Build Rust workspace\ncargo build --workspace\n\n# Build Python extension\ncd py-commol\nmaturin develop --release\n</code></pre>"},{"location":"development/workflow/#branching-strategy","title":"Branching Strategy","text":"<p>We use a simplified Git Flow approach:</p> <ul> <li><code>main</code>: Production-ready code. Protected branch.</li> <li><code>develop</code>: Integration branch for features. Used for staging releases.</li> <li><code>feature/*</code>: New features, refactoring, or significant changes (e.g., <code>feature/add-stochastic-model</code>)</li> <li><code>fix/*</code>: Bug fixes (e.g., <code>fix/calculation-error</code>)</li> <li><code>docs/*</code>: Documentation-only changes (e.g., <code>docs/update-api-reference</code>)</li> <li><code>test/*</code>: Test additions or improvements (e.g., <code>test/add-sir-model-tests</code>)</li> <li><code>chore/*</code>: Maintenance tasks, dependencies (e.g., <code>chore/update-dependencies</code>)</li> </ul>"},{"location":"development/workflow/#development-process","title":"Development Process","text":""},{"location":"development/workflow/#1-starting-new-work","title":"1. Starting New Work","text":"<pre><code># Always start from the latest develop branch\ngit checkout develop\ngit pull origin develop\n\n# Create a feature branch\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/workflow/#2-making-changes","title":"2. Making Changes","text":"<pre><code># Make your changes to the code\n\n# Run quality checks before committing\ncd py-commol\npoetry run ruff check . --fix         # Auto-fix Python linting issues\npoetry run ruff format .              # Format Python code\npoetry run mypy epimodel              # Type checking\n\ncd ..\ncargo fmt --all                       # Format Rust code\ncargo clippy --all-targets --fix      # Fix Rust linting issues\n</code></pre>"},{"location":"development/workflow/#3-testing-your-changes","title":"3. Testing Your Changes","text":"<pre><code># Run Python tests\ncd py-commol\npoetry run pytest -v\n\n# Run Rust tests\ncd ..\ncargo test --workspace\n</code></pre>"},{"location":"development/workflow/#4-committing-changes","title":"4. Committing Changes","text":"<p>We follow Conventional Commits for commit messages:</p> <pre><code># Commit format: &lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\ngit add .\ngit commit -m \"feat(transitions): add support for time-varying rates\"\ngit commit -m \"fix(simulation): correct population calculation\"\ngit commit -m \"docs(readme): update installation instructions\"\ngit commit -m \"test(models): add tests for stratified models\"\n</code></pre> <p>Commit Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation only</li> <li><code>style</code>: Code style changes (formatting)</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Adding or updating tests</li> <li><code>chore</code>: Maintenance tasks, dependencies</li> <li><code>perf</code>: Performance improvements</li> <li><code>ci</code>: CI/CD changes</li> <li><code>build</code>: Build system changes</li> </ul> <p>Branch vs Commit Type:</p> <p>The branch name indicates the primary purpose of the work, while commit types describe individual changes:</p> <ul> <li>A <code>feature/refactor-api</code> branch may have <code>refactor</code>, <code>test</code>, and <code>docs</code> commits</li> <li>A <code>test/*</code> branch primarily adds tests but may have <code>fix</code> commits too</li> <li>A <code>docs/*</code> branch is documentation-only, so all commits should use <code>docs</code> type</li> </ul>"},{"location":"development/workflow/#5-pushing-and-creating-pull-requests","title":"5. Pushing and Creating Pull Requests","text":"<pre><code># Push your branch\ngit push origin feature/your-feature-name\n\n# Create a Pull Request on GitHub\n# - Target the 'develop' branch\n# - Fill in the PR template with:\n#   - Description of changes\n#   - Related issues\n#   - Testing performed\n#   - Screenshots (if UI changes)\n</code></pre>"},{"location":"development/workflow/#6-code-review-and-ci","title":"6. Code Review and CI","text":"<p>When you create a PR, automated checks run:</p> <ul> <li>Code Quality Pipeline: Linting, formatting, type checking for both Python and Rust</li> <li>Build Pipeline: Builds on Ubuntu, Windows, and macOS with Python versions</li> <li>Test Coverage: Runs all tests and reports coverage</li> </ul> <p>PR Requirements:</p> <ul> <li>All CI checks must pass</li> <li>At least one approving review</li> <li>No merge conflicts with target branch</li> <li>Code coverage should be &gt;95%</li> </ul>"},{"location":"development/workflow/#7-merging-to-develop","title":"7. Merging to Develop","text":"<p>Once approved:</p> <pre><code># Merge using \"Squash and merge\" or \"Rebase and merge\" on GitHub\n# Delete the feature branch after merging\n</code></pre>"},{"location":"development/workflow/#continuous-integration-pipelines","title":"Continuous Integration Pipelines","text":"<p>The project uses three main CI/CD pipelines:</p>"},{"location":"development/workflow/#1-code-quality-on-every-pushpr","title":"1. Code Quality (on every push/PR)","text":"<ul> <li>Python: Ruff (linting/formatting), MyPy (type checking), Pytest (testing)</li> <li>Rust: rustfmt (formatting), Clippy (linting), cargo test</li> <li>Runs on: Ubuntu</li> <li>Purpose: Ensure code quality standards</li> </ul>"},{"location":"development/workflow/#2-build-on-every-pushpr","title":"2. Build (on every push/PR)","text":"<ul> <li>Builds on: Ubuntu, Windows, macOS</li> <li>Python versions: 3.11, 3.12</li> <li>Tests: Full test suite on all platforms</li> <li>Artifacts: Wheel files for each platform</li> <li>Purpose: Ensure cross-platform compatibility</li> </ul>"},{"location":"development/workflow/#3-release-on-github-release","title":"3. Release (on GitHub release)","text":"<ul> <li>Builds wheels for all platforms</li> <li>Creates source distribution</li> <li>Publishes to PyPI using trusted publishing</li> <li>Purpose: Automated deployment</li> </ul>"},{"location":"development/workflow/#local-development-tips","title":"Local Development Tips","text":""},{"location":"development/workflow/#quick-commands","title":"Quick Commands","text":"<pre><code># Run all quality checks (Python)\ncd py-commol &amp;&amp; poetry run ruff check . &amp;&amp; poetry run ruff format . &amp;&amp; poetry run mypy epimodel &amp;&amp; poetry run pytest\n\n# Run all quality checks (Rust)\ncargo fmt --all &amp;&amp; cargo clippy --all-targets &amp;&amp; cargo test --workspace\n\n# Build and test the Python package locally\ncd py-commol\nmaturin develop --release\npoetry run pytest\n</code></pre>"},{"location":"development/workflow/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Install pre-commit hooks to automatically check code before committing:</p> <pre><code>cd py-commol\npoetry run pre-commit install\n</code></pre> <p>This runs:</p> <ul> <li>Ruff linting and formatting</li> <li>MyPy type checking</li> <li>Trailing whitespace removal</li> <li>End-of-file fixing</li> <li>Poetry lock file validation</li> <li>Ensures <code>poetry.lock</code> stays in sync with <code>pyproject.toml</code></li> </ul>"},{"location":"development/workflow/#keeping-poetrylock-in-sync","title":"Keeping poetry.lock in Sync","text":"<p>Important: Always ensure <code>poetry.lock</code> is synchronized with <code>pyproject.toml</code> before committing.</p>"},{"location":"development/workflow/#automatic-recommended","title":"Automatic (Recommended)","text":"<p>Pre-commit hooks handle this automatically:</p> <pre><code>cd py-commol\npoetry run pre-commit install  # One-time setup\n\n# Now git commit automatically updates poetry.lock if needed\ngit add pyproject.toml\ngit commit -m \"chore: update dependencies\"\n</code></pre>"},{"location":"development/workflow/#manual","title":"Manual","text":"<p>If not using pre-commit hooks:</p> <pre><code>cd py-commol\npoetry check  # Check if lock file is in sync\npoetry lock   # Update lock file without changing versions\ngit add poetry.lock\ngit commit -m \"chore: update poetry.lock\"\n</code></pre> <p>Why this matters: Out-of-sync lock files cause CI/CD pipeline failures. The pre-commit hook prevents this automatically.</p>"},{"location":"development/workflow/#debugging-rust-from-python","title":"Debugging Rust from Python","text":"<pre><code># Build with debug symbols\nmaturin develop\n\n# Run Python\ncd py-commol\npoetry run python -m your_test_script.py\n</code></pre>"},{"location":"development/workflow/#building-documentation","title":"Building Documentation","text":"<p>The project uses MkDocs Material for documentation with multi-version support via Mike:</p> <pre><code># Install documentation dependencies\ncd py-commol\npoetry install --with docs\n\n# Serve documentation locally\npoetry run mkdocs serve\n\n# Build documentation\npoetry run mkdocs build\n</code></pre> <p>Visit http://127.0.0.1:8000 to view the documentation locally.</p>"},{"location":"development/workflow/#documentation-versioning","title":"Documentation Versioning","text":"<p>EpiModel maintains two documentation versions:</p> <ul> <li><code>latest</code>: Documentation for the current stable release from the <code>main</code> branch</li> <li><code>dev</code>: Development documentation from the <code>develop</code> branch</li> </ul>"},{"location":"development/workflow/#automatic-deployment","title":"Automatic Deployment","text":"<p>Documentation is automatically deployed when pushing to tracked branches:</p> <ul> <li>Push to <code>main</code>: Deploys to <code>latest</code> version</li> <li>Push to <code>develop</code>: Deploys to <code>dev</code> version</li> <li>Pull requests: Build and validate documentation without deploying</li> </ul> <p>Users can switch between versions using the version selector in the documentation site.</p>"},{"location":"development/workflow/#manual-deployment-if-needed","title":"Manual Deployment (if needed)","text":"<p>If you need to manually deploy documentation:</p> <pre><code># Deploy latest version (from main branch)\ncd py-commol\npoetry run mike deploy --push --update-aliases latest\npoetry run mike set-default --push latest\n\n# Deploy dev version (from develop branch)\ncd py-commol\npoetry run mike deploy --push dev\n\n# List all deployed versions\npoetry run mike list\n\n# Delete a version\npoetry run mike delete &lt;version-name&gt; --push\n</code></pre>"},{"location":"development/workflow/#version-management-tips","title":"Version Management Tips","text":"<ul> <li>The version selector appears in the top-right of the documentation site</li> <li>Each version is completely isolated with its own search index</li> <li>Old versions remain accessible even after new deployments</li> <li>Use <code>mike list</code> to see all deployed versions and aliases</li> </ul>"},{"location":"development/workflow/#next-steps","title":"Next Steps","text":"<ul> <li>Contributing Guidelines - Best practices for contributions</li> <li>Release Process - How releases are managed</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>Rust toolchain (for building from source)</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>Once published, you can install Commol directly from PyPI:</p> <pre><code>pip install commol\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>To install the latest development version:</p>"},{"location":"getting-started/installation/#1-install-prerequisites","title":"1. Install Prerequisites","text":""},{"location":"getting-started/installation/#install-rust","title":"Install Rust","text":"<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre>"},{"location":"getting-started/installation/#install-poetry-optional-for-development","title":"Install Poetry (optional, for development)","text":"<pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre>"},{"location":"getting-started/installation/#2-clone-the-repository","title":"2. Clone the Repository","text":"<pre><code>git clone https://github.com/MUNQU/commol.git\ncd commol\n</code></pre>"},{"location":"getting-started/installation/#3-install-with-pip","title":"3. Install with pip","text":"<pre><code>pip install maturin\ncd py-commol\nmaturin develop --release\n</code></pre>"},{"location":"getting-started/installation/#4-install-with-poetry-for-development","title":"4. Install with Poetry (for development)","text":"<pre><code>cd py-commol\npoetry install\nmaturin develop --release\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test that Commol is correctly installed:</p> <pre><code>from commol import ModelBuilder\nfrom commol.constants import ModelTypes\n\nprint(\"Commol installed successfully!\")\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first model</li> <li>Core Concepts - Understand Commol fundamentals</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will help you build and run your first compartment model with Commol.</p>"},{"location":"getting-started/quickstart/#your-first-sir-model","title":"Your First SIR Model","text":"<p>Let's create a basic SIR (Susceptible-Infected-Recovered) model:</p> <pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n\n# Build the model\nmodel = (\n    ModelBuilder(name=\"Basic SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)   # Transmission rate\n    .add_parameter(id=\"gamma\", value=0.1)  # Recovery rate\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"  # Mathematical formula\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run simulation\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n\n# Display results\nprint(f\"Susceptible at day 100: {results['S'][-1]:.0f}\")\nprint(f\"Infected at day 100: {results['I'][-1]:.0f}\")\nprint(f\"Recovered at day 100: {results['R'][-1]:.0f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"getting-started/quickstart/#1-import-required-classes","title":"1. Import Required Classes","text":"<pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n</code></pre> <ul> <li><code>ModelBuilder</code>: Fluent API for constructing models</li> <li><code>Simulation</code>: Runs the model simulation</li> <li><code>ModelTypes</code>: Enumeration of available model types</li> </ul>"},{"location":"getting-started/quickstart/#2-define-disease-states","title":"2. Define Disease States","text":"<pre><code>.add_bin(id=\"S\", name=\"Susceptible\")\n.add_bin(id=\"I\", name=\"Infected\")\n.add_bin(id=\"R\", name=\"Recovered\")\n</code></pre> <p>Disease states represent compartments in your model.</p>"},{"location":"getting-started/quickstart/#3-add-parameters","title":"3. Add Parameters","text":"<pre><code>.add_parameter(id=\"beta\", value=0.3)   # Transmission rate\n.add_parameter(id=\"gamma\", value=0.1)  # Recovery rate\n</code></pre> <p>Parameters are constants used in transition rate formulas.</p>"},{"location":"getting-started/quickstart/#4-define-transitions","title":"4. Define Transitions","text":"<pre><code>.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"\n)\n</code></pre> <p>Transitions move populations between states using mathematical formulas.</p>"},{"location":"getting-started/quickstart/#5-set-initial-conditions","title":"5. Set Initial Conditions","text":"<pre><code>.set_initial_conditions(\n    population_size=1000,\n    bin_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n)\n</code></pre> <p>Define the starting population distribution.</p>"},{"location":"getting-started/quickstart/#6-build-and-run","title":"6. Build and Run","text":"<pre><code>model = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"getting-started/quickstart/#adding-unit-checking","title":"Adding Unit Checking","text":"<p>Improve model safety by adding units to your parameters:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR with Units\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.5, unit=\"1/day\")    # Rate per day\n    .add_parameter(id=\"gamma\", value=0.1, unit=\"1/day\")   # Rate per day\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma * I\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Validate dimensional consistency\nmodel.check_unit_consistency()\n</code></pre> <p>Benefits:</p> <ul> <li>Catches unit errors before simulation (e.g., mixing days and weeks)</li> <li>Validates mathematical functions receive correct dimensional arguments</li> <li>Documents the physical meaning of parameters</li> </ul> <p>See the Unit Checking section for details.</p>"},{"location":"getting-started/quickstart/#calibrating-model-parameters","title":"Calibrating Model Parameters","text":"<p>When parameters are unknown, set them to <code>None</code> and calibrate them to match observed data:</p> <pre><code>from commol import (\n    ModelBuilder,\n    Simulation,\n    Calibrator,\n    CalibrationProblem,\n    CalibrationParameter,\n    CalibrationParameterType,\n    ObservedDataPoint,\n    LossConfig,\n    LossFunction,\n    OptimizationConfig,\n    OptimizationAlgorithm,\n    ParticleSwarmConfig,\n)\nfrom commol.constants import ModelTypes\n\n# Build model with unknown parameters\ncalibration_model = (\n    ModelBuilder(name=\"SIR Calibration\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=None)   # To be calibrated\n    .add_parameter(id=\"gamma\", value=None)  # To be calibrated\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma * I\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Observed infected counts at different time steps\nobserved_data = [\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5),\n    ObservedDataPoint(step=30, compartment=\"I\", value=62.3),\n    ObservedDataPoint(step=40, compartment=\"I\", value=38.1),\n]\n\n# Create simulation (allowed with None values for calibration)\ncal_simulation = Simulation(calibration_model)\n\n# Define parameters to calibrate with bounds and initial guesses\nparameters = [\n    CalibrationParameter(\n        id=\"beta\",\n        parameter_type=CalibrationParameterType.PARAMETER,\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.3\n    ),\n    CalibrationParameter(\n        id=\"gamma\",\n        parameter_type=CalibrationParameterType.PARAMETER,\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.1\n    ),\n]\n\n# Configure the calibration problem\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=parameters,\n    loss_config=LossConfig(function=LossFunction.SSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n        config=ParticleSwarmConfig.create(max_iterations=300, verbose=False),\n    ),\n)\n\n# Run calibration\ncalibrator = Calibrator(cal_simulation, problem)\nresult = calibrator.run()\n\n# Display and apply calibrated parameters\nprint(f\"Calibrated beta: {result.best_parameters['beta']:.4f}\")\nprint(f\"Calibrated gamma: {result.best_parameters['gamma']:.4f}\")\nprint(f\"Final loss: {result.final_loss:.6f}\")\n\n# Update model with calibrated values\ncalibration_model.update_parameters(result.best_parameters)\n\n# Now run simulation with calibrated model\nfinal_sim = Simulation(calibration_model)\nfinal_results = final_sim.run(num_steps=100)\n</code></pre> <p>Key concepts:</p> <ul> <li><code>ObservedDataPoint</code>: Real-world measurements to fit against</li> <li><code>CalibrationParameter</code>: Parameters to optimize with bounds</li> <li><code>LossFunction</code>: How to measure fit quality (SSE, RMSE, MAE, etc.)</li> <li><code>OptimizationAlgorithm</code>: Optimization method (Particle Swarm or Nelder-Mead)</li> </ul> <p>See the Calibration Guide for advanced techniques.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've built your first model, explore:</p> <ul> <li>Core Concepts - Deep dive into EpiModel concepts</li> <li>Building Models - Advanced model construction</li> <li>Mathematical Expressions - Complex rate formulas</li> <li>Model Calibration - Comprehensive calibration guide</li> <li>Examples - More complete examples</li> </ul>"},{"location":"guide/building-models/","title":"Building Models","text":"<p>The <code>ModelBuilder</code> class provides a fluent API for constructing compartment models.</p>"},{"location":"guide/building-models/#modelbuilder-basics","title":"ModelBuilder Basics","text":""},{"location":"guide/building-models/#creating-a-builder","title":"Creating a Builder","text":"<pre><code>from commol import ModelBuilder\n\nbuilder = ModelBuilder(\n    name=\"My Model\",\n    version=\"1.0\",\n    description=\"Optional description\",\n    bin_unit=\"person\"  # Optional: default unit for all bins\n)\n</code></pre>"},{"location":"guide/building-models/#parameters","title":"Parameters","text":"<ul> <li><code>name</code> (required): Unique identifier for your model</li> <li><code>version</code> (optional): Version string for tracking model changes</li> <li><code>description</code> (optional): Human-readable description of the model</li> <li><code>bin_unit</code> (optional): Default unit for all bins (disease states). When specified, this enables:</li> <li>Automatic unit assignment to bins, predefined population variables (<code>N</code>, <code>N_young</code>, etc.), and stratification categories</li> <li>Unit checking via <code>model.check_unit_consistency()</code></li> <li>Unit annotations in <code>model.print_equations()</code> output</li> </ul> <p>Common values: <code>\"person\"</code>, <code>\"individual\"</code>, or any custom population unit.</p> <p>Note: Individual bins can override this with their own <code>unit</code> parameter in <code>add_bin()</code>.</p>"},{"location":"guide/building-models/#chaining-methods","title":"Chaining Methods","text":"<p>The builder uses method chaining for a clean, readable API:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR Model\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .build(ModelTypes.DIFFERENCE_EQUATIONS)\n)\n</code></pre>"},{"location":"guide/building-models/#adding-disease-states","title":"Adding Disease States","text":"<pre><code>builder.add_bin(\n    id=\"S\",                    # Required: Unique identifier\n    name=\"Susceptible\",        # Required: Display name\n    description=\"Population susceptible to infection\"  # Optional\n)\n</code></pre>"},{"location":"guide/building-models/#best-practices","title":"Best Practices","text":"<ul> <li>Use short, clear IDs (S, I, R, E, etc.)</li> <li>Provide descriptive names</li> </ul>"},{"location":"guide/building-models/#adding-stratifications","title":"Adding Stratifications","text":"<p>Stratifications create population subgroups:</p> <pre><code>builder.add_stratification(\n    id=\"age_group\",\n    categories=[\"0-17\", \"18-64\", \"65+\"],\n    description=\"Age-based stratification\"\n)\n</code></pre>"},{"location":"guide/building-models/#multiple-stratifications","title":"Multiple Stratifications","text":"<pre><code>builder.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\nbuilder.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n</code></pre> <p>This creates compartments: <code>S_young_urban</code>, <code>S_young_rural</code>, <code>S_old_urban</code>, <code>S_old_rural</code>, etc.</p>"},{"location":"guide/building-models/#adding-parameters","title":"Adding Parameters","text":"<p>Parameters are global constants used in formulas:</p> <pre><code>builder.add_parameter(\n    id=\"beta\",\n    value=0.3,\n    description=\"Transmission rate per contact per day\"\n)\n</code></pre>"},{"location":"guide/building-models/#parameters-with-units","title":"Parameters with Units","text":"<p>You can specify units for automatic dimensional analysis and validation:</p> <pre><code>builder.add_parameter(\n    id=\"beta\",\n    value=0.5,\n    description=\"Transmission rate\",\n    unit=\"1/day\"  # Rate unit\n)\n\nbuilder.add_parameter(\n    id=\"seasonal_amplitude\",\n    value=0.2,\n    description=\"Seasonal variation amplitude\",\n    unit=\"dimensionless\"  # Pure number\n)\n</code></pre> <p>When all parameters have units, the model will automatically validate dimensional consistency. See Unit Checking below.</p> <p>Tip: To mark a parameter as unitless (dimensionless) for unit checking, use <code>unit=\"dimensionless\"</code>. This is useful for ratios, fractions, scaling factors, and amplitudes. Dimensionless parameters are also required as arguments to mathematical functions like <code>sin()</code>, <code>cos()</code>, <code>exp()</code>, <code>sqrt()</code>, <code>pow()</code>, etc.</p>"},{"location":"guide/building-models/#parameter-guidelines","title":"Parameter Guidelines","text":"<ul> <li>Use meaningful IDs (beta, gamma, R0, etc.)</li> <li>Document units and meaning</li> <li>Ensure values are realistic for your model</li> <li>Specify units for automatic validation (recommended)</li> </ul>"},{"location":"guide/building-models/#adding-transitions","title":"Adding Transitions","text":"<p>Transitions move populations between states.</p>"},{"location":"guide/building-models/#understanding-transition-rates","title":"Understanding Transition Rates","text":"<p>The <code>rate</code> parameter accepts mathematical expressions that can include:</p> <ul> <li>Parameters: Reference parameter IDs (e.g., <code>\"gamma\"</code>)</li> <li>Disease states: Use state populations (e.g., <code>\"S\"</code>, <code>\"I\"</code>)</li> <li>Special variables: <code>N</code> (total population), <code>step</code> or <code>t</code> (current time step), <code>pi</code>, <code>e</code></li> <li>Mathematical operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> (power)</li> <li>Functions: <code>sin()</code>, <code>cos()</code>, <code>exp()</code>, <code>log()</code>, <code>sqrt()</code>, <code>max()</code>, <code>min()</code>, etc.</li> </ul> <p>For the complete list of functions and advanced examples, see Mathematical Expressions.</p>"},{"location":"guide/building-models/#simple-parameter-based-rates","title":"Simple Parameter-Based Rates","text":"<pre><code>builder.add_transition(\n    id=\"recovery\",\n    source=[\"I\"],\n    target=[\"R\"],\n    rate=\"gamma\"  # References parameter id\n)\n</code></pre>"},{"location":"guide/building-models/#formula-based-rates","title":"Formula-Based Rates","text":"<pre><code>builder.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"  # Mathematical expression\n)\n</code></pre>"},{"location":"guide/building-models/#constant-rates","title":"Constant Rates","text":"<pre><code>builder.add_transition(\n    id=\"birth\",\n    source=[],      # Empty = enters system\n    target=[\"S\"],\n    rate=\"0.001\"    # Fixed rate\n)\n</code></pre>"},{"location":"guide/building-models/#time-dependent-rates","title":"Time-Dependent Rates","text":"<pre><code>builder.add_transition(\n    id=\"seasonal_infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * (1 + 0.3 * sin(2 * pi * t / 365)) * S * I / N\"\n)\n</code></pre> <p>See Mathematical Expressions for more complex rate formulas.</p>"},{"location":"guide/building-models/#multi-state-transitions","title":"Multi-State Transitions","text":"<pre><code># Death from any compartment\nbuilder.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],  # Empty = leaves system\n    rate=\"mu\"\n)\n</code></pre>"},{"location":"guide/building-models/#using-compartment-placeholder-for-per-compartment-rates","title":"Using <code>$compartment</code> Placeholder for Per-Compartment Rates","text":"<p>When applying the same type of transition to multiple compartments with per-compartment rates (like per-capita death rates), use the <code>$compartment</code> placeholder to avoid repetitive code:</p> <pre><code># Instead of writing 4 separate transitions:\n# .add_transition(\"death_S\", [\"S\"], [], rate=\"d * S\")\n# .add_transition(\"death_L\", [\"L\"], [], rate=\"d * L\")\n# .add_transition(\"death_I\", [\"I\"], [], rate=\"d * I\")\n# .add_transition(\"death_R\", [\"R\"], [], rate=\"d * R\")\n\n# Write one transition that automatically expands:\nbuilder.add_transition(\n    id=\"death\",\n    source=[\"S\", \"L\", \"I\", \"R\"],\n    target=[],\n    rate=\"d * $compartment\"  # $compartment gets replaced with S, L, I, R\n)\n</code></pre> <p>How it works:</p> <ul> <li>The system detects <code>$compartment</code> in the rate formula</li> <li>Automatically creates one transition per source compartment</li> <li>Replaces <code>$compartment</code> with the actual compartment name in each transition</li> <li>Generated transition IDs use the pattern: <code>{id}__{compartment}</code> (e.g., <code>death__S</code>, <code>death__L</code>)</li> </ul> <p>Complex formulas with multiple occurrences:</p> <pre><code>builder.add_transition(\n    id=\"nonlinear_death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],\n    rate=\"d * $compartment * (1 + 0.1 * $compartment / N)\"\n)\n# Expands to:\n# death__S: rate = \"d * S * (1 + 0.1 * S / N)\"\n# death__I: rate = \"d * I * (1 + 0.1 * I / N)\"\n# death__R: rate = \"d * R * (1 + 0.1 * R / N)\"\n</code></pre> <p>With single target (transfers):</p> <pre><code>builder.add_transition(\n    id=\"treatment\",\n    source=[\"I_mild\", \"I_severe\"],\n    target=[\"R\"],  # All recover to same compartment\n    rate=\"treatment_rate * $compartment\"\n)\n</code></pre> <p>With stratified rates:</p> <pre><code>builder.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n\nbuilder.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],\n    rate=\"d_base * $compartment\",  # Fallback rate\n    stratified_rates=[\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"young\"}],\n            \"rate\": \"d_young * $compartment\"  # Lower death rate for young\n        },\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"old\"}],\n            \"rate\": \"d_old * $compartment\"  # Higher death rate for old\n        }\n    ]\n)\n# Expands to death__S, death__I, death__R, each with their own stratified rates\n</code></pre> <p>Restrictions:</p> <ul> <li>Only valid with multiple source compartments (2 or more)</li> <li>Target must be empty <code>[]</code> or contain exactly one compartment</li> <li>Cannot be used if you want different targets for different sources</li> </ul> <p>Comparison with standard multi-source transitions:</p> <p>Standard multi-source transitions (without <code>$compartment</code>) create a single transition that affects all sources simultaneously:</p> <pre><code># This creates ONE transition\n.add_transition(\n    id=\"interaction\",\n    source=[\"S\", \"I\"],\n    target=[\"I\", \"I\"],\n    rate=\"beta * S * I\"\n)\n# Resulting equations:\n# dS/dt = ... - (beta*S*I)\n# dI/dt = ... - (beta*S*I) + 2*(beta*S*I) = ... + (beta*S*I)\n</code></pre> <p>With <code>$compartment</code>, you create multiple independent transitions:</p> <pre><code># This creates TWO separate transitions\n.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\"],\n    target=[],\n    rate=\"d * $compartment\"\n)\n# Resulting equations:\n# dS/dt = ... - (d*S)\n# dI/dt = ... - (d*I)\n</code></pre>"},{"location":"guide/building-models/#stratified-transitions","title":"Stratified Transitions","text":"<p>When a model includes stratifications, you often need different transition rates for different subgroups. The <code>add_transition</code> method supports this via the <code>stratified_rates</code> parameter.</p> <p>This parameter takes a list of dictionaries, where each dictionary defines a rate for a specific combination of stratification categories.</p>"},{"location":"guide/building-models/#single-stratification","title":"Single Stratification","text":"<p>Let's define different recovery rates for different age groups.</p> <pre><code>builder.add_stratification(id=\"age\", categories=[\"child\", \"adult\", \"elderly\"])\nbuilder.add_parameter(id=\"gamma_child\", value=0.15)\nbuilder.add_parameter(id=\"gamma_adult\", value=0.1)\nbuilder.add_parameter(id=\"gamma_elderly\", value=0.08)\n\nbuilder.add_transition(\n    id=\"recovery\",\n    source=[\"I\"],\n    target=[\"R\"],\n    stratified_rates=[\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"child\"}],\n            \"rate\": \"gamma_child\"\n        },\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"adult\"}],\n            \"rate\": \"gamma_adult\"\n        },\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"elderly\"}],\n            \"rate\": \"gamma_elderly\"\n        },\n    ]\n)\n</code></pre>"},{"location":"guide/building-models/#multi-stratification-transitions","title":"Multi-Stratification Transitions","text":"<p>To define rates for intersections of multiple stratifications, add multiple conditions to a single rate entry.</p> <p>For example, let's model different infection rates for high-risk adults in urban areas.</p> <pre><code>builder.add_stratification(id=\"age\", categories=[\"child\", \"adult\"])\nbuilder.add_stratification(id=\"risk\", categories=[\"low\", \"high\"])\nbuilder.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n\nbuilder.add_parameter(id=\"beta_urban_adult_high_risk\", value=0.8)\nbuilder.add_parameter(id=\"beta_default\", value=0.3)\n\nbuilder.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta_default * S * I / N\",  # Fallback rate\n    stratified_rates=[\n        {\n            \"conditions\": [\n                {\"stratification\": \"age\", \"category\": \"adult\"},\n                {\"stratification\": \"risk\", \"category\": \"high\"},\n                {\"stratification\": \"location\", \"category\": \"urban\"},\n            ],\n            \"rate\": \"beta_urban_adult_high_risk * S * I / N\"\n        }\n    ]\n)\n</code></pre> <p>In this example:</p> <ul> <li>The <code>rate</code> parameter acts as a fallback for any compartment that doesn't match a specific stratified rate.</li> <li>The <code>stratified_rates</code> entry defines a high infection rate that only applies to compartments matching all three conditions (e.g., <code>S_adult_high_urban</code>).</li> </ul>"},{"location":"guide/building-models/#setting-initial-conditions","title":"Setting Initial Conditions","text":""},{"location":"guide/building-models/#basic-setup","title":"Basic Setup","text":"<pre><code>builder.set_initial_conditions(\n    population_size=1000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},\n        {\"bin\": \"I\", \"fraction\": 0.01},\n        {\"bin\": \"R\", \"fraction\": 0.0}\n    ]\n)\n</code></pre>"},{"location":"guide/building-models/#with-stratifications","title":"With Stratifications","text":"<pre><code>builder.set_initial_conditions(\n    population_size=10000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},\n        {\"bin\": \"I\", \"fraction\": 0.01},\n        {\"bin\": \"R\", \"fraction\": 0.0}\n    ],\n    stratification_fractions=[\n        {\n            \"stratification\": \"age_group\",\n            \"fractions\": [\n                {\"category\": \"young\", \"fraction\": 0.3},\n                {\"category\": \"adult\", \"fraction\": 0.5},\n                {\"category\": \"elderly\", \"fraction\": 0.2}\n            ]\n        },\n        {\n            \"stratification\": \"risk\",\n            \"fractions\": [\n                {\"category\": \"low\", \"fraction\": 0.8},\n                {\"category\": \"high\", \"fraction\": 0.2}\n            ]\n        }\n    ]\n)\n</code></pre>"},{"location":"guide/building-models/#building-the-model","title":"Building the Model","text":"<p>Once all components are added, build the model:</p> <pre><code>from commol.constants import ModelTypes\n\nmodel = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n</code></pre>"},{"location":"guide/building-models/#validation","title":"Validation","text":"<p>The build process validates:</p> <ul> <li>All disease state fractions sum to 1.0</li> <li>All stratification fractions sum to 1.0</li> <li>Transition sources/targets reference valid states</li> <li>Mathematical expressions are syntactically correct</li> <li>No security issues in formulas</li> </ul> <p>If validation fails, a descriptive error is raised.</p>"},{"location":"guide/building-models/#unit-checking","title":"Unit Checking","text":"<p>EpiModel provides automatic dimensional analysis to catch unit errors in your model equations. This validates that rate expressions produce the correct units and that mathematical functions receive dimensionally correct arguments.</p>"},{"location":"guide/building-models/#enabling-unit-checking","title":"Enabling Unit Checking","text":"<p>Unit checking is enabled when all parameters have units:</p> <pre><code># Build model with units\nbuilder = ModelBuilder(name=\"SIR with Units\", version=\"1.0\")\n\nbuilder.add_bin(\"S\", \"Susceptible\")\nbuilder.add_bin(\"I\", \"Infected\")\nbuilder.add_bin(\"R\", \"Recovered\")\n\n# Specify units for all parameters\nbuilder.add_parameter(\"beta\", 0.5, \"Transmission rate\", unit=\"1/day\")\nbuilder.add_parameter(\"gamma\", 0.1, \"Recovery rate\", unit=\"1/day\")\n\nbuilder.add_transition(\n    \"infection\", [\"S\"], [\"I\"],\n    rate=\"beta * S * I / N\"\n)\nbuilder.add_transition(\"recovery\", [\"I\"], [\"R\"], rate=\"gamma * I\")\n\nbuilder.set_initial_conditions(\n    population_size=1000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},\n        {\"bin\": \"I\", \"fraction\": 0.01},\n        {\"bin\": \"R\", \"fraction\": 0.0},\n    ],\n)\n\nmodel = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n\n# Validate dimensional consistency\nmodel.check_unit_consistency()  # Raises error if units are inconsistent\n</code></pre>"},{"location":"guide/building-models/#common-units","title":"Common Units","text":"<pre><code># Rate units\nunit=\"1/day\"         # Per-day rates\nunit=\"1/week\"        # Per-week rates\n\n# Population units (automatically assigned to disease states)\nunit=\"person\"        # Population count\n\n# Dimensionless quantities\nunit=\"dimensionless\" # Ratios, fractions, amplitudes\n</code></pre>"},{"location":"guide/building-models/#mathematical-functions","title":"Mathematical Functions","text":"<p>All standard math functions work with unit checking and validate their arguments:</p> <pre><code># Seasonal forcing (sin requires dimensionless argument)\nbuilder.add_parameter(\"beta_avg\", 0.5, unit=\"1/day\")\nbuilder.add_parameter(\"seasonal_amp\", 0.2, unit=\"dimensionless\")\n\nbuilder.add_transition(\n    \"infection\", [\"S\"], [\"I\"],\n    rate=\"beta_avg * (1 + seasonal_amp * sin(2 * pi * step / 365)) * S * I / N\"\n)\n\n# Exponential decay (exp requires dimensionless argument)\nbuilder.add_parameter(\"beta_0\", 0.5, unit=\"1/day\")\nbuilder.add_parameter(\"decay_rate\", 0.01, unit=\"dimensionless\")\n\nbuilder.add_transition(\n    \"infection\", [\"S\"], [\"I\"],\n    rate=\"beta_0 * exp(-decay_rate * step) * S * I / N\"\n)\n</code></pre> <p>Supported functions: <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>exp</code>, <code>log</code>, <code>sqrt</code>, <code>pow</code>, <code>min</code>, <code>max</code>, <code>abs</code>, and more.</p>"},{"location":"guide/building-models/#automatic-unit-assignment","title":"Automatic Unit Assignment","text":"<p>The system automatically assigns units to:</p> <ul> <li>Disease states: All have units of <code>person</code> (S, I, R, etc.)</li> <li>Population variables: <code>N</code>, <code>N_young</code>, <code>N_urban</code>, etc. have units of <code>person</code></li> <li>Time variables: <code>t</code> and <code>step</code> are dimensionless</li> <li>Constants: <code>pi</code> and <code>e</code> are dimensionless</li> </ul>"},{"location":"guide/building-models/#error-detection","title":"Error Detection","text":"<p>Unit checking catches common errors:</p> <pre><code># Wrong parameter units\nbuilder.add_parameter(\"beta\", 0.5, unit=\"day\")  # Should be \"1/day\"!\n# Error: Unit mismatch: equation has unit 'day * person' but expected 'person/day'\n\n# Dimensional argument to math function\nrate=\"beta * sin(I) * S\"  # I has units of person!\n# Error: Cannot convert from 'person' to 'dimensionless'\n\n# Incompatible units in operations\nrate=\"min(beta, threshold) * S\"  # beta is 1/day, threshold is person\n# Error: Cannot compare incompatible units\n</code></pre>"},{"location":"guide/building-models/#best-practices_1","title":"Best Practices","text":"<ol> <li>Always specify units for physical quantities</li> <li>Use \"dimensionless\" for ratios and fractions</li> <li>Ensure math function arguments are dimensionless (divide by appropriate quantities)</li> <li>Use consistent time units throughout your model</li> </ol>"},{"location":"guide/building-models/#unit-display-in-equations","title":"Unit Display in Equations","text":"<p>When you print equations using <code>model.print_equations()</code>, unit annotations are displayed based on unit completeness:</p> <pre><code># Model with complete units - shows annotations\nmodel = (\n    ModelBuilder(name=\"SIR\", bin_unit=\"person\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_parameter(id=\"beta\", value=0.5, unit=\"1/day\")\n    .add_parameter(id=\"gamma\", value=0.1, unit=\"1/day\")\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .build()\n)\n\nmodel.print_equations()\n# Output:\n#   S -&gt; I: beta(1/day) * S(person) * I(person) / N(person) [person/day]\n\n# Model without units - no annotations\nmodel = (\n    ModelBuilder(name=\"SIR\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_parameter(id=\"beta\", value=0.5)\n    .build()\n)\n\nmodel.print_equations()\n# Output:\n#   S -&gt; I: beta * S * I / N\n</code></pre>"},{"location":"guide/building-models/#partial-unit-definitions","title":"Partial Unit Definitions","text":"<p>Important: You must define units for ALL parameters and bins, or for NONE. Partial unit definitions will raise a <code>ValueError</code>:</p> <pre><code># This will raise an error!\nmodel = (\n    ModelBuilder(name=\"SIR\", bin_unit=\"person\")\n    .add_parameter(id=\"beta\", value=0.5, unit=\"1/day\")  # Has unit\n    .add_parameter(id=\"gamma\", value=0.1)  # No unit - INCONSISTENT!\n    .build()\n)\n\nmodel.print_equations()  # ValueError: Some parameters have units but not all\n</code></pre> <p>This prevents accidentally mixing unit systems or forgetting to specify units for some parameters.</p>"},{"location":"guide/building-models/#advanced-conditional-transitions","title":"Advanced: Conditional Transitions","text":"<p>Create transitions that only occur under certain conditions:</p> <pre><code># Create a condition\ncondition = builder.create_condition(\n    logic=\"and\",\n    rules=[\n        {\"variable\": \"state:I\", \"operator\": \"gt\", \"value\": 100},\n        {\"variable\": \"step\", \"operator\": \"gt\", \"value\": 30}\n    ]\n)\n\n# Add conditional transition\nbuilder.add_transition(\n    id=\"intervention\",\n    source=[\"S\"],\n    target=[\"S\"],\n    rate=\"0.5 * beta\",  # Reduced transmission\n    condition=condition\n)\n</code></pre>"},{"location":"guide/building-models/#loading-from-json","title":"Loading from JSON","text":"<p>Load pre-defined models from JSON files:</p> <pre><code>from commol import ModelLoader\n\nmodel = ModelLoader.from_json(\"path/to/model.json\")\n</code></pre>"},{"location":"guide/building-models/#json-structure","title":"JSON Structure","text":"<pre><code>{\n  \"name\": \"SIR Model\",\n  \"version\": \"1.0\",\n  \"population\": {\n    \"disease_states\": [\n      { \"id\": \"S\", \"name\": \"Susceptible\" },\n      { \"id\": \"I\", \"name\": \"Infected\" },\n      { \"id\": \"R\", \"name\": \"Recovered\" }\n    ]\n  },\n  \"parameters\": [\n    { \"id\": \"beta\", \"value\": 0.3 },\n    { \"id\": \"gamma\", \"value\": 0.1 }\n  ],\n  \"dynamics\": {\n    \"typology\": \"difference_equations\",\n    \"transitions\": [\n      {\n        \"id\": \"infection\",\n        \"source\": [\"S\"],\n        \"target\": [\"I\"],\n        \"rate\": \"beta * S * I / N\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"guide/building-models/#complete-example","title":"Complete Example","text":"<pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n\n# Build SEIR model\nmodel = (\n    ModelBuilder(name=\"SEIR Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"E\", name=\"Exposed\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4, description=\"Transmission rate\")\n    .add_parameter(id=\"sigma\", value=0.2, description=\"Incubation rate\")\n    .add_parameter(id=\"gamma\", value=0.1, description=\"Recovery rate\")\n    .add_transition(id=\"exposure\", source=[\"S\"], target=[\"E\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"infection\", source=[\"E\"], target=[\"I\"], rate=\"sigma\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.999},\n            {\"bin\": \"E\", \"fraction\": 0.0},\n            {\"bin\": \"I\", \"fraction\": 0.001},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run simulation\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=200)\n</code></pre>"},{"location":"guide/building-models/#next-steps","title":"Next Steps","text":"<ul> <li>Mathematical Expressions - Advanced formulas</li> <li>Simulations - Running and analyzing models</li> <li>Examples - Complete model examples</li> </ul>"},{"location":"guide/calibration/","title":"Model Calibration","text":"<p>Calibration is the process of adjusting model parameters to match observed data. Commol provides a calibration framework that uses optimization algorithms to find the best parameter values that minimize the difference between model predictions and real-world observations.</p>"},{"location":"guide/calibration/#overview","title":"Overview","text":"<p>The calibration process involves:</p> <ol> <li>Defining observed data: Real-world measurements at specific time steps</li> <li>Selecting parameters to calibrate: Which model parameters or initial conditions to optimize</li> <li>Choosing a loss function: How to measure fit quality (SSE, RMSE, MAE, etc.)</li> <li>Selecting an optimization algorithm: Nelder-Mead or Particle Swarm</li> <li>Running the calibration: Finding optimal parameter values</li> <li>Updating the model: Applying calibrated values to your model</li> </ol> <p>Working with Uncalibrated Parameters</p> <p>Parameters and initial conditions can be set to <code>None</code> to indicate they need calibration. A <code>Simulation</code> can be created with <code>None</code> values for calibration purposes, but attempting to call <code>run()</code> on a simulation with uncalibrated values will raise a <code>ValueError</code>. After calibration, use <code>model.update_parameters(result.best_parameters)</code> or <code>model.update_initial_conditions(result.best_parameters)</code> to update your model with the calibrated values.</p>"},{"location":"guide/calibration/#basic-example","title":"Basic Example","text":"<p>Here's a simple calibration of an SIR model's transmission and recovery rates. Parameters to be calibrated should be set to <code>None</code>, and initial guesses are provided in the <code>CalibrationParameter</code> configuration:</p> <pre><code>from commol import (\n    ModelBuilder,\n    Simulation,\n    Calibrator,\n    CalibrationProblem,\n    CalibrationParameter,\n    CalibrationParameterType,\n    ObservedDataPoint,\n    LossConfig,\n    LossFunction,\n    OptimizationConfig,\n    OptimizationAlgorithm,\n    ParticleSwarmConfig,\n    NelderMeadConfig,\n)\nfrom commol.constants import ModelTypes\n\n# Build model with parameters to be calibrated set to None\nmodel = (\n    ModelBuilder(name=\"SIR Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=None)   # To be calibrated\n    .add_parameter(id=\"gamma\", value=None)  # To be calibrated\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma * I\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Define observed data (e.g., from real outbreak data)\nobserved_data = [\n    ObservedDataPoint(step=0, compartment=\"I\", value=10.0),\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5),\n    ObservedDataPoint(step=30, compartment=\"I\", value=62.3),\n    ObservedDataPoint(step=40, compartment=\"I\", value=38.1),\n    ObservedDataPoint(step=50, compartment=\"I\", value=18.7),\n]\n\n# Simulation can be created with None values for calibration\nsimulation = Simulation(model)\n\n# But attempting to run without calibrated values raises an error\ntry:\n    simulation.run(100)\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Cannot run Simulation: Parameters requiring calibration...\n\n# Define parameters to calibrate with bounds and initial guesses\nparameters = [\n    CalibrationParameter(\n        id=\"beta\",\n        parameter_type=CalibrationParameterType.PARAMETER,\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.3  # Starting point for optimization\n    ),\n    CalibrationParameter(\n        id=\"gamma\",\n        parameter_type=CalibrationParameterType.PARAMETER,\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.1\n    ),\n]\n\n# Configure the calibration problem with Particle Swarm Optimization\n# Use the builder pattern for clearer configuration\npso_config = ParticleSwarmConfig.create(\n    num_particles=30,\n    max_iterations=500,\n    verbose=True  # Show optimization progress\n)\n\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=parameters,\n    loss_config=LossConfig(function=LossFunction.SSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n        config=pso_config,\n    ),\n)\n\n# Run calibration\ncalibrator = Calibrator(simulation, problem)\nresult = calibrator.run()\n\n# Display results\nprint(result)\nprint(f\"Calibrated beta: {result.best_parameters['beta']:.4f}\")\nprint(f\"Calibrated gamma: {result.best_parameters['gamma']:.4f}\")\n\n# Update model with calibrated parameters\nmodel.update_parameters(result.best_parameters)\n\n# Create new simulation with calibrated model for predictions\ncalibrated_simulation = Simulation(model)\nprediction_results = calibrated_simulation.run(num_steps=200)\nprint(f\"Predicted infections at day 200: {prediction_results['I'][-1]:.0f}\")\n</code></pre>"},{"location":"guide/calibration/#calibrating-initial-conditions","title":"Calibrating Initial Conditions","text":"<p>You can also calibrate initial population fractions:</p> <pre><code># Build model with unknown initial infected fraction\nmodel = (\n    ModelBuilder(name=\"SIR Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma * I\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.98},\n            {\"bin\": \"I\", \"fraction\": None},  # Unknown - to be calibrated\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Calibrate initial infected fraction\nparameters = [\n    CalibrationParameter(\n        id=\"I\",\n        parameter_type=CalibrationParameterType.INITIAL_CONDITION,\n        min_bound=0.0,\n        max_bound=0.1,\n        initial_guess=0.02  # Starting point for optimization\n    )\n]\n\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=parameters,\n    loss_config=LossConfig(function=LossFunction.SSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.NELDER_MEAD,\n        config=NelderMeadConfig(max_iterations=1000),\n    ),\n)\n\n# Simulation works with None initial conditions for calibration\nsimulation = Simulation(model)\ncalibrator = Calibrator(simulation, problem)\nresult = calibrator.run()\n\n# Update initial conditions with calibrated values\nmodel.update_initial_conditions(result.best_parameters)\n\n# Now create final simulation\nfinal_simulation = Simulation(model)\nresults = final_simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/calibration/#loss-functions","title":"Loss Functions","text":"<p>Commol supports multiple loss functions for measuring fit quality:</p>"},{"location":"guide/calibration/#sum-of-squared-errors-sse","title":"Sum of Squared Errors (SSE)","text":"<p>Default loss function. Minimizes the sum of squared differences:</p> <pre><code>loss_config = LossConfig(function=LossFunction.SSE)\n</code></pre> <p>$$\\text{SSE} = \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2$$</p>"},{"location":"guide/calibration/#root-mean-squared-error-rmse","title":"Root Mean Squared Error (RMSE)","text":"<p>Provides error in the same units as the data:</p> <pre><code>loss_config = LossConfig(function=LossFunction.RMSE)\n</code></pre> <p>$$\\text{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2}$$</p>"},{"location":"guide/calibration/#mean-absolute-error-mae","title":"Mean Absolute Error (MAE)","text":"<p>Less sensitive to outliers:</p> <pre><code>loss_config = LossConfig(function=LossFunction.MAE)\n</code></pre> <p>$$\\text{MAE} = \\frac{1}{n}\\sum_{i=1}^{n} |y_i - \\hat{y}_i|$$</p>"},{"location":"guide/calibration/#weighted-sse","title":"Weighted SSE","text":"<p>Allows different importance for different observations:</p> <pre><code># Give more weight to early observations\nobserved_data = [\n    ObservedDataPoint(step=0, compartment=\"I\", value=10.0, weight=2.0),\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2, weight=1.5),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5, weight=1.0),\n]\n\nloss_config = LossConfig(function=LossFunction.WEIGHTED_SSE)\n</code></pre> <p>$$\\text{WSSE} = \\sum_{i=1}^{n} w_i (y_i - \\hat{y}_i)^2$$</p>"},{"location":"guide/calibration/#optimization-algorithms","title":"Optimization Algorithms","text":""},{"location":"guide/calibration/#particle-swarm-optimization-pso","title":"Particle Swarm Optimization (PSO)","text":"<p>Population-based algorithm inspired by social behavior. Good for global optimization.</p> <p>Basic Configuration:</p> <p>Use the <code>create()</code> factory method and builder methods for clear configuration:</p> <pre><code>from commol import ParticleSwarmConfig, OptimizationConfig, OptimizationAlgorithm\n\n# Basic PSO configuration\npso_config = ParticleSwarmConfig.create(\n    num_particles=40,        # Number of particles in swarm\n    max_iterations=1000,     # Maximum iterations\n    target_cost=0.01,        # Stop if loss below this (optional)\n    verbose=True,            # Print progress\n    header_interval=50       # Print header every N iterations\n)\n\noptimization_config = OptimizationConfig(\n    algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n    config=pso_config,\n)\n</code></pre> <p>Advanced Configuration with Builder Methods:</p> <pre><code># PSO with chaotic inertia and TVAC\npso_config = (\n    ParticleSwarmConfig.create(num_particles=40, max_iterations=1000, verbose=True)\n    .with_chaotic_inertia(w_min=0.4, w_max=0.9)  # Dynamic inertia weight\n    .with_tvac(c1_initial=2.5, c1_final=0.5,     # Time-varying acceleration\n               c2_initial=0.5, c2_final=2.5)\n    .with_initialization_strategy(\"latin_hypercube\")  # Better initial distribution\n)\n\n# PSO with mutation to escape local optima\npso_config = (\n    ParticleSwarmConfig.create(num_particles=50, max_iterations=2000)\n    .with_acceleration(cognitive=2.0, social=2.0)  # Constant acceleration\n    .with_velocity_clamping(0.2)  # Prevent explosive velocities\n    .with_mutation(\n        strategy=\"gaussian\",      # Gaussian mutation\n        scale=0.1,               # Mutation intensity\n        probability=0.05,        # 5% mutation chance per iteration\n        application=\"global_best\"  # Apply to best particle only\n    )\n)\n</code></pre> <p>Builder Methods:</p> <ul> <li><code>.with_inertia(factor)</code> - Set constant inertia weight</li> <li><code>.with_chaotic_inertia(w_min, w_max)</code> - Enable chaotic inertia (conflicts with <code>with_inertia</code>)</li> <li><code>.with_acceleration(cognitive, social)</code> - Set constant acceleration factors</li> <li><code>.with_tvac(c1_i, c1_f, c2_i, c2_f)</code> - Time-varying acceleration (conflicts with <code>with_acceleration</code>)</li> <li><code>.with_initialization_strategy(strategy)</code> - \"uniform\", \"latin_hypercube\", or \"opposition_based\"</li> <li><code>.with_velocity_clamping(factor)</code> - Clamp velocities (typically 0.1-0.2)</li> <li><code>.with_velocity_mutation(threshold)</code> - Reinitialize near-zero velocities</li> <li><code>.with_mutation(strategy, scale, probability, application)</code> - Enable mutation</li> </ul> <p>When to use PSO:</p> <ul> <li>Multiple local minima expected</li> <li>Robust global search needed</li> <li>Multiple parameters to calibrate</li> <li>Complex parameter landscapes</li> </ul>"},{"location":"guide/calibration/#nelder-mead-simplex","title":"Nelder-Mead Simplex","text":"<p>Derivative-free simplex algorithm. Fast convergence for smooth problems:</p> <pre><code>from commol import NelderMeadConfig, OptimizationConfig, OptimizationAlgorithm\n\noptimization_config = OptimizationConfig(\n    algorithm=OptimizationAlgorithm.NELDER_MEAD,\n    config=NelderMeadConfig(\n        max_iterations=1000,     # Maximum iterations\n        sd_tolerance=1e-6,       # Convergence tolerance\n        alpha=1.0,               # Reflection coefficient (optional)\n        gamma=2.0,               # Expansion coefficient (optional)\n        rho=0.5,                 # Contraction coefficient (optional)\n        sigma=0.5,               # Shrink coefficient (optional)\n        verbose=True,            # Print progress\n        header_interval=50       # Print header every N iterations\n    ),\n)\n</code></pre> <p>When to use:</p> <ul> <li>Smooth, unimodal objective function</li> <li>Few parameters (&lt; 10)</li> <li>Fast convergence desired</li> </ul>"},{"location":"guide/calibration/#advanced-examples","title":"Advanced Examples","text":""},{"location":"guide/calibration/#multi-compartment-calibration","title":"Multi-Compartment Calibration","text":"<p>Calibrate against observations from multiple compartments:</p> <pre><code># Build model with parameters to calibrate\nmodel = (\n    ModelBuilder(name=\"SIR Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=None)   # To be calibrated\n    .add_parameter(id=\"gamma\", value=None)  # To be calibrated\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma * I\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Observed data from both infected and recovered compartments\nobserved_data = [\n    # Infected observations\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5),\n    ObservedDataPoint(step=30, compartment=\"I\", value=62.3),\n    # Recovered observations\n    ObservedDataPoint(step=10, compartment=\"R\", value=12.5),\n    ObservedDataPoint(step=20, compartment=\"R\", value=35.8),\n    ObservedDataPoint(step=30, compartment=\"R\", value=68.2),\n]\n\nsimulation = Simulation(model)\n\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=[\n        CalibrationParameter(\n            id=\"beta\",\n            parameter_type=CalibrationParameterType.PARAMETER,\n            min_bound=0.0,\n            max_bound=1.0,\n            initial_guess=0.3\n        ),\n        CalibrationParameter(\n            id=\"gamma\",\n            parameter_type=CalibrationParameterType.PARAMETER,\n            min_bound=0.0,\n            max_bound=1.0,\n            initial_guess=0.1\n        ),\n    ],\n    loss_config=LossConfig(function=LossFunction.RMSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n        config=ParticleSwarmConfig.create(max_iterations=500, verbose=False),\n    ),\n)\n\ncalibrator = Calibrator(simulation, problem)\nresult = calibrator.run()\n\n# Update model with calibrated values\nmodel.update_parameters(result.best_parameters)\n</code></pre>"},{"location":"guide/calibration/#calibrating-stratified-models","title":"Calibrating Stratified Models","text":"<p>Calibrate parameters specific to age groups or other stratifications:</p> <pre><code># Build age-stratified model with parameters to calibrate\nmodel = (\n    ModelBuilder(name=\"Age-Stratified SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n    .add_parameter(id=\"beta\", value=None)          # To be calibrated\n    .add_parameter(id=\"gamma_young\", value=None)   # To be calibrated\n    .add_parameter(id=\"gamma_old\", value=None)     # To be calibrated\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        stratified_rates=[\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"young\"}],\n                \"rate\": \"gamma_young * I\"\n            },\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"old\"}],\n                \"rate\": \"gamma_old * I\"\n            },\n        ]\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ],\n        stratification_fractions=[\n            {\n                \"stratification\": \"age\",\n                \"fractions\": [\n                    {\"category\": \"young\", \"fraction\": 0.6},\n                    {\"category\": \"old\", \"fraction\": 0.4}\n                ]\n            }\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Note: Observed data uses stratified compartment names like \"I_young\", \"I_old\"\nobserved_data = [\n    ObservedDataPoint(step=10, compartment=\"I_young\", value=30.5),\n    ObservedDataPoint(step=10, compartment=\"I_old\", value=15.2),\n    ObservedDataPoint(step=20, compartment=\"I_young\", value=52.3),\n    ObservedDataPoint(step=20, compartment=\"I_old\", value=26.1),\n]\n\nsimulation = Simulation(model)\n\n# Calibrate stratification-specific parameters\nparameters = [\n    CalibrationParameter(\n        id=\"beta\",\n        parameter_type=CalibrationParameterType.PARAMETER,\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.3\n    ),\n    CalibrationParameter(\n        id=\"gamma_young\",\n        parameter_type=CalibrationParameterType.PARAMETER,\n        min_bound=0.05,\n        max_bound=0.2,\n        initial_guess=0.12\n    ),\n    CalibrationParameter(\n        id=\"gamma_old\",\n        parameter_type=CalibrationParameterType.PARAMETER,\n        min_bound=0.05,\n        max_bound=0.2,\n        initial_guess=0.08\n    ),\n]\n\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=parameters,\n    loss_config=LossConfig(function=LossFunction.SSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n        config=ParticleSwarmConfig.create(max_iterations=500, verbose=False),\n    ),\n)\n\ncalibrator = Calibrator(simulation, problem)\nresult = calibrator.run()\n\n# Update model with calibrated values\nmodel.update_parameters(result.best_parameters)\n</code></pre>"},{"location":"guide/calibration/#using-calibration-results","title":"Using Calibration Results","text":"<p>Once calibrated, update your model with the fitted parameters and create a new simulation:</p> <pre><code># Run calibration\nresult = Calibrator(simulation, problem).run()\n\n# Check if calibration converged\nif result.converged:\n    print(f\"Calibration converged after {result.iterations} iterations\")\n    print(f\"Final loss: {result.final_loss:.6f}\")\n    print(f\"Calibrated parameters: {result.best_parameters}\")\n\n    # Update the existing model with calibrated parameters\n    model.update_parameters(result.best_parameters)\n\n    # Create a new simulation with the updated model\n    calibrated_simulation = Simulation(model)\n    prediction_results = calibrated_simulation.run(num_steps=200)\n\n    print(f\"Predicted infections at day 200: {prediction_results['I'][-1]:.0f}\")\nelse:\n    print(f\"Calibration did not converge: {result.termination_reason}\")\n</code></pre> <p>Important: The <code>Calibrator</code> returns a <code>CalibrationResult</code> object containing the optimized parameter values, but does not automatically update your model. Use <code>model.update_parameters(result.best_parameters)</code> to update the model in place, then create a new <code>Simulation</code> object to run predictions with the calibrated parameters.</p>"},{"location":"guide/calibration/#best-practices","title":"Best Practices","text":""},{"location":"guide/calibration/#1-choose-appropriate-bounds","title":"1. Choose Appropriate Bounds","text":"<p>Set realistic bounds based on biological knowledge:</p> <pre><code># Too wide: allows unrealistic values\nCalibrationParameter(id=\"beta\", min_bound=0.0, max_bound=100.0)  # Bad\n\n# Reasonable: based on disease characteristics\nCalibrationParameter(id=\"beta\", min_bound=0.1, max_bound=0.8)    # Good\n</code></pre>"},{"location":"guide/calibration/#2-provide-good-initial-guesses","title":"2. Provide Good Initial Guesses","text":"<p>Initial guesses can speed up convergence:</p> <pre><code># Without initial guess - optimizer uses midpoint\nCalibrationParameter(\n    id=\"beta\",\n    parameter_type=CalibrationParameterType.PARAMETER,\n    min_bound=0.1,\n    max_bound=0.8\n)\n\n# Provide informed starting point (recommended)\nCalibrationParameter(\n    id=\"beta\",\n    parameter_type=CalibrationParameterType.PARAMETER,\n    min_bound=0.1,\n    max_bound=0.8,\n    initial_guess=0.4  # Based on literature\n)\n</code></pre>"},{"location":"guide/calibration/#3-use-appropriate-loss-functions","title":"3. Use Appropriate Loss Functions","text":"<ul> <li>SSE/RMSE: When all observations equally important</li> <li>MAE: When outliers present in data</li> <li>Weighted SSE: When some observations more reliable</li> </ul>"},{"location":"guide/calibration/#4-choose-the-right-algorithm","title":"4. Choose the Right Algorithm","text":"<ul> <li>Particle Swarm: Complex landscapes, global search, multiple parameters</li> <li>Nelder-Mead: Smooth problems, fewer parameters, faster convergence</li> </ul>"},{"location":"guide/calibration/#5-validate-results","title":"5. Validate Results","text":"<p>Always check biological plausibility:</p> <pre><code>result = calibrator.run()\n\n# Check parameter values make sense\nif result.best_parameters['beta'] &gt; 1.0:\n    print(\"Warning: Unusually high transmission rate\")\n\n# Check final loss\nif result.final_loss &gt; 1000:\n    print(\"Warning: Poor fit quality\")\n\n# Verify convergence\nif not result.converged:\n    print(f\"Warning: Did not converge - {result.termination_reason}\")\n</code></pre>"},{"location":"guide/calibration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/calibration/#calibration-not-converging","title":"Calibration Not Converging","text":"<ul> <li>Increase <code>max_iterations</code></li> <li>Widen parameter bounds</li> <li>Try different optimization algorithm</li> <li>Check if model can actually produce observed patterns</li> </ul>"},{"location":"guide/calibration/#poor-fit-quality","title":"Poor Fit Quality","text":"<ul> <li>Verify observed data is correct</li> <li>Check model structure matches reality</li> <li>Add more parameters if underfitting</li> <li>Use weighted loss to prioritize important observations</li> </ul>"},{"location":"guide/calibration/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete Calibrator API documentation</li> <li>Examples - Additional calibration examples</li> <li>Simulation - Running model simulations</li> </ul>"},{"location":"guide/core-concepts/","title":"Core Concepts","text":"<p>Commol is built around several key concepts that work together to create compartment models.</p>"},{"location":"guide/core-concepts/#disease-states","title":"Disease States","text":"<p>Disease states (also called compartments) represent different stages of infection in your population.</p> <pre><code>builder.add_bin(id=\"S\", name=\"Susceptible\")\nbuilder.add_bin(id=\"E\", name=\"Exposed\")\nbuilder.add_bin(id=\"I\", name=\"Infected\")\nbuilder.add_bin(id=\"R\", name=\"Recovered\")\n</code></pre>"},{"location":"guide/core-concepts/#common-disease-states","title":"Common Disease States","text":"ID Name Description S Susceptible Individuals who can become infected E Exposed Infected but not yet infectious I Infected Actively infected and infectious R Recovered No longer infectious, immune D Dead Deceased from disease"},{"location":"guide/core-concepts/#stratifications","title":"Stratifications","text":"<p>Stratifications allow you to model population subgroups (age, location, risk factors, etc.):</p> <pre><code># Age stratification\nbuilder.add_stratification(\n    id=\"age_group\",\n    categories=[\"young\", \"adult\", \"elderly\"]\n)\n\n# Location stratification\nbuilder.add_stratification(\n    id=\"region\",\n    categories=[\"urban\", \"rural\"]\n)\n</code></pre>"},{"location":"guide/core-concepts/#initial-conditions-with-stratifications","title":"Initial Conditions with Stratifications","text":"<pre><code>builder.set_initial_conditions(\n    population_size=10000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},\n        {\"bin\": \"I\", \"fraction\": 0.01},\n        {\"bin\": \"R\", \"fraction\": 0.0}\n    ],\n    stratification_fractions=[\n        {\n            \"stratification\": \"age_group\",\n            \"fractions\": [\n                {\"category\": \"young\", \"fraction\": 0.3},\n                {\"category\": \"adult\", \"fraction\": 0.5},\n                {\"category\": \"elderly\", \"fraction\": 0.2}\n            ]\n        }\n    ]\n)\n</code></pre> <p>This creates compartments: <code>S_young</code>, <code>S_adult</code>, <code>S_elderly</code>, <code>I_young</code>, etc.</p>"},{"location":"guide/core-concepts/#parameters","title":"Parameters","text":"<p>Parameters are global constants used throughout your model:</p> <pre><code>builder.add_parameter(\n    id=\"beta\",\n    value=0.3,\n    description=\"Transmission rate per contact\"\n)\n\nbuilder.add_parameter(\n    id=\"gamma\",\n    value=0.1,\n    description=\"Recovery rate (1/infectious_period)\"\n)\n</code></pre>"},{"location":"guide/core-concepts/#common-parameters","title":"Common Parameters","text":"Parameter Meaning Typical Range <code>beta</code> Transmission rate 0.1 - 1.0 <code>gamma</code> Recovery rate 0.05 - 0.5 <code>sigma</code> Incubation rate (1/incubation_period) 0.1 - 0.5 <code>mu</code> Birth/death rate 0.0001 - 0.001 <code>R0</code> Basic reproduction number 1.0 - 10.0"},{"location":"guide/core-concepts/#transitions","title":"Transitions","text":"<p>Transitions define how populations move between disease states:</p>"},{"location":"guide/core-concepts/#simple-transitions","title":"Simple Transitions","text":"<pre><code># Recovery: I \u2192 R\nbuilder.add_transition(\n    id=\"recovery\",\n    source=[\"I\"],\n    target=[\"R\"],\n    rate=\"gamma\"\n)\n</code></pre>"},{"location":"guide/core-concepts/#formula-based-transitions","title":"Formula-Based Transitions","text":"<pre><code># Infection: S \u2192 I (with force of infection)\nbuilder.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"\n)\n</code></pre>"},{"location":"guide/core-concepts/#multi-source-transitions","title":"Multi-Source Transitions","text":"<pre><code># Natural death from any state\nbuilder.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],  # Empty = removal from system\n    rate=\"0.000027\"  # Daily death rate\n)\n</code></pre>"},{"location":"guide/core-concepts/#initial-conditions","title":"Initial Conditions","text":"<p>Initial conditions define the starting state of your model:</p> <pre><code>builder.set_initial_conditions(\n    population_size=1000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},  # 99% susceptible\n        {\"bin\": \"I\", \"fraction\": 0.01},  # 1% infected\n        {\"bin\": \"R\", \"fraction\": 0.0}    # 0% recovered\n    ]\n)\n</code></pre>"},{"location":"guide/core-concepts/#validation-rules","title":"Validation Rules","text":"<ul> <li>Disease state fractions must sum to 1.0</li> <li>Stratification fractions must sum to 1.0 for each stratification</li> <li>Population size must be positive</li> <li>All disease states must have initial fractions defined</li> </ul>"},{"location":"guide/core-concepts/#model-types","title":"Model Types","text":"<p>EpiModel currently supports:</p> <pre><code>from commol.constants import ModelTypes\n\nmodel = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n</code></pre>"},{"location":"guide/core-concepts/#difference-equations","title":"Difference Equations","text":"<ul> <li>Discrete time steps</li> <li>Deterministic dynamics</li> <li>Fast computation</li> <li>Best for: Population-level modeling, policy analysis</li> </ul>"},{"location":"guide/core-concepts/#the-model-building-process","title":"The Model Building Process","text":"<p>A typical workflow:</p> <ol> <li>Define disease states - What compartments exist?</li> <li>Add stratifications (optional) - What subgroups matter?</li> <li>Define parameters - What rates and constants?</li> <li>Create transitions - How do populations flow?</li> <li>Set initial conditions - What's the starting state?</li> <li>Build the model - Validate and construct</li> <li>Run simulation - Execute and analyze</li> </ol>"},{"location":"guide/core-concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Building Models - Detailed ModelBuilder API</li> <li>Mathematical Expressions - Advanced formulas</li> <li>Examples - Complete model examples</li> </ul>"},{"location":"guide/examples/","title":"Examples","text":"<p>Complete examples demonstrating different modeling scenarios.</p>"},{"location":"guide/examples/#example-1-basic-sir-model","title":"Example 1: Basic SIR Model","text":"<p>Classic Susceptible-Infected-Recovered model:</p> <pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\nimport matplotlib.pyplot as plt\n\n# Build model\nmodel = (\n    ModelBuilder(name=\"Basic SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Simulate\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-2-seir-model","title":"Example 2: SEIR Model","text":"<p>Adding an exposed (incubation) period:</p> <pre><code>model = (\n    ModelBuilder(name=\"SEIR Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"E\", name=\"Exposed\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4, description=\"Transmission rate\")\n    .add_parameter(id=\"sigma\", value=0.2, description=\"Incubation rate\")\n    .add_parameter(id=\"gamma\", value=0.1, description=\"Recovery rate\")\n    .add_transition(id=\"exposure\", source=[\"S\"], target=[\"E\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"infection\", source=[\"E\"], target=[\"I\"], rate=\"sigma\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.999},\n            {\"bin\": \"E\", \"fraction\": 0.0},\n            {\"bin\": \"I\", \"fraction\": 0.001},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-3-seasonal-transmission","title":"Example 3: Seasonal Transmission","text":"<p>Modeling seasonal variation in transmission:</p> <pre><code>model = (\n    ModelBuilder(name=\"Seasonal SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta_mean\", value=0.3)\n    .add_parameter(id=\"beta_amp\", value=0.2)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(\n        id=\"seasonal_infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        # Seasonal forcing: peaks in winter (day 0, 365, ...)\n        rate=\"beta_mean * (1 + beta_amp * sin(2 * pi * step / 365)) * S * I / N\"\n    )\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run for 3 years to see seasonal pattern\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=365 * 3)\n</code></pre>"},{"location":"guide/examples/#example-4-age-stratified-model","title":"Example 4: Age-Stratified Model","text":"<p>Different age groups with varying recovery rates:</p> <pre><code>model = (\n    ModelBuilder(name=\"Age-Stratified SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_stratification(id=\"age\", categories=[\"child\", \"adult\", \"elderly\"])\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma_child\", value=0.15)\n    .add_parameter(id=\"gamma_adult\", value=0.12)\n    .add_parameter(id=\"gamma_elderly\", value=0.08)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        stratified_rates=[\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"child\"}],\n                \"rate\": \"gamma_child\"\n            },\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"adult\"}],\n                \"rate\": \"gamma_adult\"\n            },\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"elderly\"}],\n                \"rate\": \"gamma_elderly\"\n            },\n        ]\n    )\n    .set_initial_conditions(\n        population_size=10000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ],\n        stratification_fractions=[\n            {\n                \"stratification\": \"age\",\n                \"fractions\": [\n                    {\"category\": \"child\", \"fraction\": 0.25},\n                    {\"category\": \"adult\", \"fraction\": 0.55},\n                    {\"category\": \"elderly\", \"fraction\": 0.20}\n                ]\n            }\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-5-vaccination-campaign","title":"Example 5: Vaccination Campaign","text":"<p>Adding vaccination to an SIR model:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR with Vaccination\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"vax_rate\", value=0.01)  # 1% per day\n    .add_parameter(id=\"vax_eff\", value=0.9)     # 90% effective\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .add_transition(\n        id=\"vaccination\",\n        source=[\"S\"],\n        target=[\"R\"],\n        rate=\"vax_rate * vax_eff\"  # Effective vaccination rate\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Compare with and without vaccination\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-6-healthcare-capacity","title":"Example 6: Healthcare Capacity","text":"<p>Modeling reduced recovery when hospitals are overwhelmed:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR with Healthcare Capacity\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.5)\n    .add_parameter(id=\"gamma_max\", value=0.15)\n    .add_parameter(id=\"hospital_cap\", value=100.0)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(\n        id=\"recovery_saturated\",\n        source=[\"I\"],\n        target=[\"R\"],\n        # Recovery slows as infections approach hospital capacity\n        rate=\"gamma_max * (1 - max(0, (I - hospital_cap) / hospital_cap))\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.95},\n            {\"bin\": \"I\", \"fraction\": 0.05},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-7-waning-immunity","title":"Example 7: Waning Immunity","text":"<p>Recovered individuals gradually become susceptible again:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIRS Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"omega\", value=0.01)  # Waning immunity rate\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .add_transition(id=\"waning\", source=[\"R\"], target=[\"S\"], rate=\"omega\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run for longer to see endemic equilibrium\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=1000)\n</code></pre>"},{"location":"guide/examples/#example-8-multi-stratified-model","title":"Example 8: Multi-Stratified Model","text":"<p>This example demonstrates a model with multiple stratifications (age and risk) and defines a transition rate for a specific intersection of these stratifications.</p> <pre><code>import numpy as np\n\n# Build model\nmodel = (\n    ModelBuilder(name=\"Multi-Stratified SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n    .add_stratification(id=\"risk\", categories=[\"low\", \"high\"])\n    .add_parameter(id=\"beta_low\", value=0.3)\n    .add_parameter(id=\"beta_high\", value=0.6)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta_low * S * I / N\", # Default rate\n        stratified_rates=[\n            {\n                \"conditions\": [{\"stratification\": \"risk\", \"category\": \"high\"}],\n                \"rate\": \"beta_high * S * I / N\"\n            }\n        ]\n    )\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ],\n        stratification_fractions=[\n            {\n                \"stratification\": \"age\",\n                \"fractions\": [\n                    {\"category\": \"young\", \"fraction\": 0.6},\n                    {\"category\": \"old\", \"fraction\": 0.4}\n                ]\n            },\n            {\n                \"stratification\": \"risk\",\n                \"fractions\": [\n                    {\"category\": \"low\", \"fraction\": 0.8},\n                    {\"category\": \"high\", \"fraction\": 0.2}\n                ]\n            }\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Simulate\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-9-subpopulation-dependent-transmission","title":"Example 9: Subpopulation-Dependent Transmission","text":"<p>This example shows how to model frequency-dependent transmission within a specific subpopulation using the automatically calculated <code>N_{category}</code> variable. The infection rate for the <code>young</code> category is normalized by the total <code>young</code> population (<code>N_young</code>), while the <code>old</code> category uses the global population <code>N</code>.</p> <pre><code># Build model\nmodel = (\n    ModelBuilder(name=\"Subpopulation-Dependent SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n    .add_parameter(id=\"beta\", value=0.4)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\", # Default rate for old\n        stratified_rates=[\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"young\"}],\n                \"rate\": \"beta * S * I / N_young\" # Rate normalized by subpopulation\n            }\n        ]\n    )\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ],\n        stratification_fractions=[\n            {\n                \"stratification\": \"age\",\n                \"fractions\": [\n                    {\"category\": \"young\", \"fraction\": 0.5},\n                    {\"category\": \"old\", \"fraction\": 0.5}\n                ]\n            }\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Simulate\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-10-parameter-calibration","title":"Example 10: Parameter Calibration","text":"<p>Calibrate model parameters to match observed data:</p> <pre><code>from commol import (\n    ModelBuilder,\n    Simulation,\n    Calibrator,\n    CalibrationProblem,\n    CalibrationParameter,\n    CalibrationParameterType,\n    ObservedDataPoint,\n    LossConfig,\n    LossFunction,\n    OptimizationConfig,\n    OptimizationAlgorithm,\n    ParticleSwarmConfig,\n)\nfrom commol.constants import ModelTypes\n\n# Build SIR model with parameters to be calibrated\nmodel = (\n    ModelBuilder(name=\"SIR for Calibration\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=None)   # To be calibrated\n    .add_parameter(id=\"gamma\", value=None)  # To be calibrated\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma * I\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Define observed data (e.g., from real outbreak surveillance)\nobserved_data = [\n    ObservedDataPoint(step=0, compartment=\"I\", value=10.0),\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5),\n    ObservedDataPoint(step=30, compartment=\"I\", value=62.3),\n    ObservedDataPoint(step=40, compartment=\"I\", value=38.1),\n    ObservedDataPoint(step=50, compartment=\"I\", value=18.7),\n    ObservedDataPoint(step=60, compartment=\"I\", value=8.2),\n]\n\n# Create simulation (can be created with None values for calibration)\nsimulation = Simulation(model)\n\n# Define parameters to calibrate with initial guesses\nparameters = [\n    CalibrationParameter(\n        id=\"beta\",\n        parameter_type=CalibrationParameterType.PARAMETER,\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.3\n    ),\n    CalibrationParameter(\n        id=\"gamma\",\n        parameter_type=CalibrationParameterType.PARAMETER,\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.1\n    ),\n]\n\n# Configure calibration problem\npso_config = ParticleSwarmConfig.create(\n    num_particles=30,\n    max_iterations=500,\n    verbose=True\n)\n\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=parameters,\n    loss_config=LossConfig(function=LossFunction.SSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n        config=pso_config,\n    ),\n)\n\n# Run calibration\ncalibrator = Calibrator(simulation, problem)\nresult = calibrator.run()\n\n# Display results\nprint(\"\\n=== Calibration Results ===\")\nprint(f\"Converged: {result.converged}\")\nprint(f\"Iterations: {result.iterations}\")\nprint(f\"Final loss: {result.final_loss:.6f}\")\nprint(f\"Calibrated beta: {result.best_parameters['beta']:.6f}\")\nprint(f\"Calibrated gamma: {result.best_parameters['gamma']:.6f}\")\nprint(f\"Termination reason: {result.termination_reason}\")\n\n# Update model with calibrated parameters\nmodel.update_parameters(result.best_parameters)\n\n# Now create a new simulation with calibrated model\ncalibrated_simulation = Simulation(model)\nresults = calibrated_simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Calibration Guide - Comprehensive calibration documentation</li> <li>Mathematical Expressions - Advanced formulas</li> <li>Contributing - Build your own examples</li> </ul>"},{"location":"guide/mathematical-expressions/","title":"Mathematical Expressions","text":"<p>EpiModel supports rich mathematical expressions in transition rates, enabling complex and realistic disease dynamics.</p>"},{"location":"guide/mathematical-expressions/#basic-syntax","title":"Basic Syntax","text":"<p>Transition rates are specified as string expressions that are evaluated during simulation:</p> <pre><code>.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"  # Mathematical expression as a string\n)\n</code></pre>"},{"location":"guide/mathematical-expressions/#arithmetic-operations","title":"Arithmetic Operations","text":""},{"location":"guide/mathematical-expressions/#basic-operations","title":"Basic Operations","text":"Operation Operator Example Description Addition <code>+</code> <code>\"alpha + beta\"</code> Sum of two values Subtraction <code>-</code> <code>\"alpha - beta\"</code> Difference Multiplication <code>*</code> <code>\"beta * S\"</code> Product Division <code>/</code> <code>\"I / N\"</code> Division Exponentiation <code>**</code> <code>\"beta ** 2\"</code> Power Parentheses <code>()</code> <code>\"(alpha + beta) * I\"</code> Grouping"},{"location":"guide/mathematical-expressions/#examples","title":"Examples","text":"<pre><code>rate = \"beta * S * I\"           # Multiply transmission rate by populations\nrate = \"gamma + delta\"          # Add two parameters\nrate = \"beta / N\"               # Divide by total population\nrate = \"(beta + gamma) / 2\"     # Average with parentheses\nrate = \"beta ** 2\"              # Square a value\n</code></pre>"},{"location":"guide/mathematical-expressions/#available-variables","title":"Available Variables","text":""},{"location":"guide/mathematical-expressions/#disease-state-variables","title":"Disease State Variables","text":"<p>Reference any disease state by its ID:</p> <pre><code># In a model with states S, I, R\nrate = \"beta * S * I\"    # Use S and I populations\nrate = \"gamma * I\"       # Use I population\nrate = \"0.01 * R\"        # Use R population\n</code></pre>"},{"location":"guide/mathematical-expressions/#special-variables","title":"Special Variables","text":"Variable Type Description <code>N</code> float Total population (automatic sum of all compartments) <code>N_{category}</code> float Total population for a specific stratification category (e.g., <code>N_young</code>) <code>N_{cat1_cat2}</code> float Total population for an intersection of categories (e.g., <code>N_young_urban</code>) <code>step</code> int Current simulation step (0, 1, 2, ...) <code>t</code> int Alias for <code>step</code> <code>$compartment</code> str Placeholder that expands to each source compartment name (see below) <p>Examples:</p> <pre><code>rate = \"beta * I / N\"              # Frequency-dependent transmission\nrate = \"beta * sin(2 * pi * t)\"    # Periodic variation\nrate = \"gamma * exp(-0.01 * step)\" # Exponential decay over time\n</code></pre>"},{"location":"guide/mathematical-expressions/#the-compartment-placeholder","title":"The <code>$compartment</code> Placeholder","text":"<p>The <code>$compartment</code> special variable is a template placeholder that automatically expands multi-compartment transitions into individual per-compartment transitions:</p> <pre><code># Instead of writing repetitive code:\n.add_transition(\"death_S\", [\"S\"], [], rate=\"d * S\")\n.add_transition(\"death_I\", [\"I\"], [], rate=\"d * I\")\n.add_transition(\"death_R\", [\"R\"], [], rate=\"d * R\")\n\n# Use $compartment to write it once:\n.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],\n    rate=\"d * $compartment\"  # Automatically expands\n)\n</code></pre> <p>How it works:</p> <ol> <li>System detects <code>$compartment</code> in the rate formula</li> <li>Creates one transition per source compartment</li> <li>Replaces <code>$compartment</code> with the actual compartment name in each formula</li> </ol> <p>Generated transitions:</p> <ul> <li><code>death__S</code>: <code>rate = \"d * S\"</code></li> <li><code>death__I</code>: <code>rate = \"d * I\"</code></li> <li><code>death__R</code>: <code>rate = \"d * R\"</code></li> </ul> <p>Multiple occurrences in complex formulas:</p> <pre><code>rate = \"d * $compartment * (1 + 0.1 * $compartment / N)\"\n\n# Expands to:\n# death__S: \"d * S * (1 + 0.1 * S / N)\"\n# death__I: \"d * I * (1 + 0.1 * I / N)\"\n# death__R: \"d * R * (1 + 0.1 * R / N)\"\n</code></pre> <p>With stratified rates:</p> <pre><code>.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],\n    rate=\"d_base * $compartment\",\n    stratified_rates=[\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"young\"}],\n            \"rate\": \"d_young * $compartment\"\n        },\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"old\"}],\n            \"rate\": \"d_old * $compartment\"\n        }\n    ]\n)\n</code></pre> <p>When to use:</p> <ul> <li>Per-capita rates that apply to multiple compartments (deaths, emigration)</li> <li>Treatment transitions from multiple disease states to recovery</li> <li>Any time you need the same formula pattern applied to different compartments</li> </ul> <p>When NOT to use:</p> <ul> <li>Standard multi-compartment interactions (use regular syntax)</li> <li>Single source compartment (use compartment name directly)</li> <li>Different formulas for different compartments (write separate transitions)</li> </ul> <p>See Building Models - Using $compartment Placeholder for more details.</p>"},{"location":"guide/mathematical-expressions/#parameter-references","title":"Parameter References","text":"<p>Reference any parameter by its ID:</p> <pre><code>.add_parameter(id=\"beta\", value=0.3)\n.add_parameter(id=\"gamma\", value=0.1)\n\n.add_transition(rate=\"beta * S * I / N\")  # Uses beta parameter\n.add_transition(rate=\"gamma\")             # Uses gamma parameter\n</code></pre>"},{"location":"guide/mathematical-expressions/#mathematical-functions","title":"Mathematical Functions","text":""},{"location":"guide/mathematical-expressions/#trigonometric-functions","title":"Trigonometric Functions","text":"Function Description Example <code>sin(x)</code> Sine <code>sin(2 * pi * t / 365)</code> <code>cos(x)</code> Cosine <code>cos(t)</code> <code>tan(x)</code> Tangent <code>tan(x)</code> <code>asin(x)</code> Arc sine <code>asin(x)</code> <code>acos(x)</code> Arc cosine <code>acos(x)</code> <code>atan(x)</code> Arc tangent <code>atan(x)</code> <code>atan2(y, x)</code> Two-argument arc tangent <code>atan2(y, x)</code> <p>Example:</p> <pre><code># Seasonal variation (peaks annually)\nrate = \"beta * sin(2 * pi * step / 365)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#exponential-and-logarithmic","title":"Exponential and Logarithmic","text":"Function Description Example <code>exp(x)</code> Exponential (e^x) <code>exp(-0.01 * t)</code> <code>log(x)</code> Natural logarithm <code>log(I + 1)</code> <code>ln(x)</code> Alias for <code>log</code> <code>ln(I + 1)</code> <code>log10(x)</code> Base-10 logarithm <code>log10(I)</code> <code>log2(x)</code> Base-2 logarithm <code>log2(I)</code> <p>Example:</p> <pre><code># Exponential decay over time\nrate = \"gamma * exp(-0.01 * step)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#power-and-root","title":"Power and Root","text":"Function Description Example <code>sqrt(x)</code> Square root <code>sqrt(I)</code> <code>pow(x, y)</code> Power (x^y) <code>pow(I, 2)</code> <code>x ** y</code> Power operator <code>I ** 2</code> <p>Example:</p> <pre><code># Square root relationship\nrate = \"beta * sqrt(I)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#comparison-functions","title":"Comparison Functions","text":"Function Description Example <code>max(a, b)</code> Maximum of two values <code>max(0, beta - 0.01)</code> <code>min(a, b)</code> Minimum of two values <code>min(gamma, 0.5)</code> <code>abs(x)</code> Absolute value <code>abs(x)</code> <p>Example:</p> <pre><code># Ensure rate stays positive\nrate = \"max(0, beta - 0.001 * step)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#rounding-functions","title":"Rounding Functions","text":"Function Description Example <code>floor(x)</code> Round down <code>floor(beta * I)</code> <code>ceil(x)</code> Round up <code>ceil(gamma * I)</code> <code>round(x)</code> Round to nearest <code>round(alpha * I)</code>"},{"location":"guide/mathematical-expressions/#hyperbolic-functions","title":"Hyperbolic Functions","text":"Function Description Example <code>sinh(x)</code> Hyperbolic sine <code>sinh(x)</code> <code>cosh(x)</code> Hyperbolic cosine <code>cosh(x)</code> <code>tanh(x)</code> Hyperbolic tangent <code>tanh(x)</code>"},{"location":"guide/mathematical-expressions/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/mathematical-expressions/#time-dependent-rates","title":"Time-Dependent Rates","text":"<p>Use <code>step</code> or <code>t</code> for time-varying rates:</p> <pre><code># Linear increase\nrate = \"0.1 + 0.001 * step\"\n\n# Exponential decay\nrate = \"beta * exp(-0.01 * t)\"\n\n# Seasonal pattern (annual cycle)\nrate = \"beta * (1 + 0.3 * sin(2 * pi * step / 365))\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#population-dependent-rates","title":"Population-Dependent Rates","text":"<pre><code># Standard mass action\nrate = \"beta * S * I\"\n\n# Frequency-dependent (normalized by population)\nrate = \"beta * S * I / N\"\n\n# Saturation effect\nrate = \"beta * I / (1 + I)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#threshold-effects","title":"Threshold Effects","text":"<pre><code># Activate when condition is met\nrate = \"max(0, beta) * (I &gt; 100)\"  # Only when I &gt; 100\n\n# Reduce transmission above threshold\nrate = \"beta * min(1, 100 / I)\"    # Reduces when I &gt; 100\n</code></pre>"},{"location":"guide/mathematical-expressions/#composite-expressions","title":"Composite Expressions","text":"<p>Combine multiple effects:</p> <pre><code># Seasonal transmission with saturation\nrate = \"beta * (1 + 0.3 * sin(2 * pi * t / 365)) * S * I / (N + I)\"\n\n# Time-varying intervention\nrate = \"beta * max(0.2, 1 - 0.01 * step) * S * I / N\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#operator-precedence","title":"Operator Precedence","text":"<p>From highest to lowest priority:</p> <ol> <li>Parentheses: <code>()</code></li> <li>Exponentiation: <code>**</code></li> <li>Multiplication/Division: <code>*</code>, <code>/</code></li> <li>Addition/Subtraction: <code>+</code>, <code>-</code></li> </ol> <p>Examples:</p> <pre><code>rate = \"2 + 3 * 4\"        # = 14 (multiplication first)\nrate = \"(2 + 3) * 4\"      # = 20 (parentheses first)\nrate = \"2 ** 3 * 4\"       # = 32 (exponentiation first)\nrate = \"2 * 3 ** 4\"       # = 162 (exponentiation before multiplication)\n</code></pre>"},{"location":"guide/mathematical-expressions/#best-practices","title":"Best Practices","text":""},{"location":"guide/mathematical-expressions/#1-use-meaningful-parameters","title":"1. Use Meaningful Parameters","text":"<pre><code># Good: Clear parameter names\n.add_parameter(id=\"beta\", value=0.3)\nrate = \"beta * S * I / N\"\n\n# Avoid: Magic numbers\nrate = \"0.3 * S * I / N\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#2-prevent-division-by-zero","title":"2. Prevent Division by Zero","text":"<pre><code># Good: Add small constant\nrate = \"beta * I / (N + 1)\"\n\n# Good: Use max\nrate = \"beta * I / max(N, 1)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#3-keep-expressions-simple","title":"3. Keep Expressions Simple","text":"<pre><code># Good: Simple and readable\nrate = \"beta * S * I / N\"\n\n# Acceptable but complex:\nrate = \"beta * (1 + 0.3 * sin(2 * pi * t / 365)) * S * I / N\"\n\n# Better: Split into parameters\n.add_parameter(id=\"seasonal_beta\", value=\"beta * (1 + 0.3 * sin(2 * pi * t / 365))\")\nrate = \"seasonal_beta * S * I / N\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#4-document-complex-expressions","title":"4. Document Complex Expressions","text":"<pre><code>.add_transition(\n    id=\"seasonal_infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * (1 + 0.3 * sin(2 * pi * step / 365)) * S * I / N\",\n    description=\"Infection with 30% seasonal amplitude, annual cycle\"\n)\n</code></pre>"},{"location":"guide/mathematical-expressions/#security-features","title":"Security Features","text":"<p>EpiModel validates all expressions for security:</p>"},{"location":"guide/mathematical-expressions/#safe-operations","title":"Safe Operations","text":"<pre><code>rate = \"beta * S * I / N\"                    # Mathematical operations\nrate = \"sin(2 * pi * t)\"                     # Mathematical functions\nrate = \"max(0, gamma - 0.01 * step)\"        # Built-in functions\n</code></pre>"},{"location":"guide/mathematical-expressions/#blocked-operations","title":"Blocked Operations","text":"<pre><code>rate = \"__import__('os')\"                    # Python imports\nrate = \"eval('code')\"                        # Code evaluation\nrate = \"exec('code')\"                        # Code execution\nrate = \"open('file')\"                        # File operations\n</code></pre> <p>The parser:</p> <ul> <li>Only allows mathematical operations and approved functions</li> <li>Blocks all Python/Rust code execution</li> <li>Validates syntax before simulation</li> <li>Prevents code injection attacks</li> </ul>"},{"location":"guide/mathematical-expressions/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/mathematical-expressions/#expression-complexity","title":"Expression Complexity","text":"<ul> <li>Fast: <code>\"gamma\"</code> (parameter lookup)</li> <li>Fast: <code>\"beta * I\"</code> (simple arithmetic)</li> <li>Medium: <code>\"beta * S * I / N\"</code> (multiple operations)</li> <li>Slower: <code>\"beta * exp(-0.01 * step) * sin(2 * pi * t / 365)\"</code> (functions + operations)</li> </ul>"},{"location":"guide/mathematical-expressions/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use parameters for constants:</li> </ol> <pre><code># Slower: recalculates each step\nrate = \"0.3 * S * I / 1000\"\n\n# Faster: parameter lookup\n.add_parameter(id=\"beta\", value=0.3)\nrate = \"beta * S * I / N\"\n</code></pre> <ol> <li>Simplify when possible:</li> </ol> <pre><code># Complex\nrate = \"beta * I / N + gamma * I / N\"\n\n# Simplified\nrate = \"(beta + gamma) * I / N\"\n</code></pre> <ol> <li>Profile complex models: Use <code>time</code> module to measure performance with different expressions.</li> </ol>"},{"location":"guide/mathematical-expressions/#complete-function-reference","title":"Complete Function Reference","text":""},{"location":"guide/mathematical-expressions/#all-available-functions","title":"All Available Functions","text":"Category Functions Trigonometric <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>asin</code>, <code>acos</code>, <code>atan</code>, <code>atan2</code> Exponential/Log <code>exp</code>, <code>log</code>, <code>ln</code>, <code>log10</code>, <code>log2</code> Power/Root <code>sqrt</code>, <code>pow</code> Comparison <code>max</code>, <code>min</code>, <code>abs</code> Rounding <code>floor</code>, <code>ceil</code>, <code>round</code> Hyperbolic <code>sinh</code>, <code>cosh</code>, <code>tanh</code>"},{"location":"guide/mathematical-expressions/#all-available-variables","title":"All Available Variables","text":"Variable Type Description Disease states float Any state ID (S, I, R, etc.) Parameters float Any parameter ID <code>N</code> float Total population <code>step</code> int Current time step <code>t</code> int Alias for step <code>pi</code> float \u03c0 constant <code>e</code> float e constant"},{"location":"guide/mathematical-expressions/#all-operators","title":"All Operators","text":"Operator Description <code>+</code> Addition <code>-</code> Subtraction <code>*</code> Multiplication <code>/</code> Division <code>**</code> Exponentiation <code>()</code> Grouping"},{"location":"guide/mathematical-expressions/#next-steps","title":"Next Steps","text":"<ul> <li>Building Models - Use expressions in transitions</li> <li>Simulations - Run models with mathematical expressions</li> <li>Examples - See complex expressions in complete models</li> </ul>"},{"location":"guide/simulations/","title":"Running Simulations","text":"<p>Once you've built a model, use the <code>Simulation</code> class to run it and analyze results.</p>"},{"location":"guide/simulations/#basic-simulation","title":"Basic Simulation","text":"<pre><code>from commol import Simulation\n\n# Create simulation from model\nsimulation = Simulation(model)\n\n# Run for 100 time steps\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/simulations/#output-formats","title":"Output Formats","text":"<p>EpiModel supports two output formats for simulation results.</p>"},{"location":"guide/simulations/#dictionary-of-lists-default","title":"Dictionary of Lists (Default)","text":"<p>Each disease state maps to a list of values over time:</p> <pre><code>results = simulation.run(num_steps=100, output_format=\"dict_of_lists\")\n\n# Access results\nsusceptible = results[\"S\"]  # [990, 985, 978, ...]\ninfected = results[\"I\"]     # [10, 15, 22, ...]\nrecovered = results[\"R\"]    # [0, 0, 0, ...]\n\n# Get final values\nfinal_S = results[\"S\"][-1]\nfinal_I = results[\"I\"][-1]\nfinal_R = results[\"R\"][-1]\n\nprint(f\"Final state: S={final_S:.0f}, I={final_I:.0f}, R={final_R:.0f}\")\n</code></pre> <p>Best for: Plotting, time series analysis, accessing specific compartments</p>"},{"location":"guide/simulations/#list-of-lists","title":"List of Lists","text":"<p>Each time step is a list of all compartment values:</p> <pre><code>results = simulation.run(num_steps=100, output_format=\"list_of_lists\")\n\n# results[time][compartment_index]\ninitial_state = results[0]     # [990, 10, 0]\nmidpoint_state = results[50]   # [450, 200, 350]\nfinal_state = results[-1]      # [340, 50, 610]\n\n# Iterate over time steps\nfor t, state in enumerate(results):\n    total = sum(state)\n    print(f\"Step {t}: Total population = {total}\")\n</code></pre> <p>Best for: Matrix operations, comparing states, exporting to CSV</p>"},{"location":"guide/simulations/#working-with-stratifications","title":"Working with Stratifications","text":"<p>Stratifications create multiple compartments by combining disease states with stratification categories. Understanding how to access and analyze stratified results is crucial for complex models.</p>"},{"location":"guide/simulations/#understanding-stratified-compartment-names","title":"Understanding Stratified Compartment Names","text":"<p>When you add stratifications, EpiModel creates compartments by combining disease state IDs with stratification category names using underscore notation:</p> <p>Pattern: <code>{disease_state}_{category1}_{category2}_...</code></p> <pre><code># Model with one stratification (age)\n.add_bin(id=\"S\", name=\"Susceptible\")\n.add_bin(id=\"I\", name=\"Infected\")\n.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n\n# Creates compartments: S_young, S_old, I_young, I_old\n</code></pre> <pre><code># Model with two stratifications (age and location)\n.add_bin(id=\"I\", name=\"Infected\")\n.add_stratification(id=\"age\", categories=[\"child\", \"adult\"])\n.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n\n# Creates compartments:\n# I_child_urban, I_child_rural, I_adult_urban, I_adult_rural\n</code></pre>"},{"location":"guide/simulations/#accessing-stratified-results","title":"Accessing Stratified Results","text":""},{"location":"guide/simulations/#1-list-all-compartments","title":"1. List All Compartments","text":"<pre><code>results = simulation.run(num_steps=100)\n\n# See all compartment names\nprint(\"All compartments:\", list(results.keys()))\n# Output: ['S_young', 'S_old', 'I_young', 'I_old', 'R_young', 'R_old']\n\n# Count compartments\nprint(f\"Total compartments: {len(results)}\")\n</code></pre>"},{"location":"guide/simulations/#2-access-specific-strata","title":"2. Access Specific Strata","text":"<pre><code># Access specific age groups\nyoung_infected = results[\"I_young\"]\nold_infected = results[\"I_old\"]\n\n# Access specific combinations (multiple stratifications)\nurban_child_infected = results[\"I_child_urban\"]\nrural_adult_infected = results[\"I_adult_rural\"]\n</code></pre>"},{"location":"guide/simulations/#3-filter-compartments-by-pattern","title":"3. Filter Compartments by Pattern","text":"<pre><code># Get all infected compartments\ninfected_keys = [key for key in results.keys() if key.startswith(\"I_\")]\nprint(\"Infected compartments:\", infected_keys)\n\n# Get all young compartments\nyoung_keys = [key for key in results.keys() if \"_young\" in key]\nprint(\"Young compartments:\", young_keys)\n\n# Get all urban compartments (multi-stratification)\nurban_keys = [key for key in results.keys() if \"_urban\" in key]\n</code></pre>"},{"location":"guide/simulations/#aggregating-stratified-results","title":"Aggregating Stratified Results","text":""},{"location":"guide/simulations/#sum-across-one-stratification","title":"Sum Across One Stratification","text":"<pre><code># Total infected across all age groups\ntotal_infected = np.array(results[\"I_young\"]) + np.array(results[\"I_old\"])\n\n# Or using list comprehension\ntotal_infected = [y + o for y, o in zip(results[\"I_young\"], results[\"I_old\"])]\n</code></pre>"},{"location":"guide/simulations/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/simulations/#1-case-sensitivity","title":"1. Case Sensitivity","text":"<pre><code># Compartment names use exact category names\n.add_stratification(id=\"age\", categories=[\"Young\", \"Old\"])  # Capital Y and O\n# Access with: results[\"I_Young\"], results[\"I_Old\"]\n</code></pre>"},{"location":"guide/simulations/#2-order-of-stratifications","title":"2. Order of Stratifications","text":"<pre><code># Categories combine in the order stratifications are added\n.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n\n# Creates: I_young_urban, I_young_rural, I_old_urban, I_old_rural\n# NOT: I_urban_young, I_rural_young, etc.\n</code></pre>"},{"location":"guide/simulations/#3-missing-compartments","title":"3. Missing Compartments","text":"<pre><code># Always check compartments exist before accessing\nkey = \"I_young\"\nif key in results:\n    data = results[key]\nelse:\n    print(f\"Compartment {key} not found. Available: {list(results.keys())}\")\n</code></pre>"},{"location":"guide/simulations/#visualizing-results","title":"Visualizing Results","text":"<p>Commol provides the <code>SimulationPlotter</code> class for visualizing simulation results with automatic subplot organization and Seaborn styling.</p>"},{"location":"guide/simulations/#basic-plotting","title":"Basic Plotting","text":"<pre><code>from commol import SimulationPlotter\n\n# After running simulation\nresults = simulation.run(num_steps=100)\n\n# Create plotter\nplotter = SimulationPlotter(simulation, results)\n\n# Plot time series (one subplot per compartment)\nplotter.plot_series(output_file=\"results.png\")\n\n# Plot cumulative results\nplotter.plot_cumulative(output_file=\"cumulative.png\")\n</code></pre>"},{"location":"guide/simulations/#customizing-plots","title":"Customizing Plots","text":"<pre><code>from commol import PlotConfig, SeabornStyleConfig\n\n# Custom configuration\nconfig = PlotConfig(\n    figsize=(16, 10),\n    dpi=150,\n    layout=(2, 2),  # 2x2 subplot grid\n    seaborn=SeabornStyleConfig(\n        style=\"darkgrid\",      # darkgrid, whitegrid, dark, white, ticks\n        palette=\"Set2\",        # Color palette\n        context=\"talk\"         # paper, notebook, talk, poster\n    )\n)\n\nplotter.plot_series(\n    output_file=\"custom.png\",\n    config=config,\n    bins=[\"I\", \"R\"],  # Only plot specific compartments\n    linewidth=2.5,\n    alpha=0.8\n)\n</code></pre>"},{"location":"guide/simulations/#overlaying-observed-data","title":"Overlaying Observed Data","text":"<pre><code>from commol import ObservedDataPoint\n\nobserved_data = [\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5),\n    ObservedDataPoint(step=30, compartment=\"I\", value=62.3),\n]\n\nplotter.plot_series(\n    output_file=\"with_data.png\",\n    observed_data=observed_data\n)\n</code></pre>"},{"location":"guide/simulations/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - Complete model examples with analysis</li> <li>API Reference - Detailed Simulation API</li> <li>Mathematical Expressions - Advanced formulas</li> </ul>"}]}