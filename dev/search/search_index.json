{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Commol","text":"<p>A high-performance compartment modelling library for mathematical modeling using difference equations. Commol provides a clean Python API backed by a fast Rust engine for numerical computations.</p> <p>Alpha Stage - API Unstable</p> <p>Commol is currently in alpha development. The API is not yet stable and may change between versions without backward compatibility guarantees.</p> <pre><code>- Breaking changes may occur in any release\n- Not recommended for production use yet\n- API will stabilize in version 1.0.0\n\nWe welcome feedback and contributions as we work toward a stable release!\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Intuitive Model Building: Fluent API for constructing compartment models</li> <li>Mathematical Expressions: Support for complex mathematical formulas in transition rates</li> <li>High Performance: Rust-powered simulation engine for fast computations</li> <li>Flexible Architecture: Support for stratified populations and conditional transitions</li> <li>Type Safety: Comprehensive validation using Pydantic models</li> <li>Multiple Output Formats: Get results as dictionaries or lists for easy analysis</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n\n# Build a simple SIR model\nmodel = (\n    ModelBuilder(name=\"Basic SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"N\", value=1000.0)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run simulation\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide - Install Commol</li> <li>Quick Start - Build your first model</li> <li>Core Concepts - Understand the fundamentals</li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#user-guide","title":"User Guide","text":"<p>Learn how to build and run compartment models:</p> <ul> <li>Core Concepts - Disease states, stratifications, parameters</li> <li>Building Models - Using the ModelBuilder API</li> <li>Mathematical Expressions - Advanced rate formulas</li> <li>Running Simulations - Execute models and analyze results</li> <li>Model Calibration - Fit models to observed data</li> <li>Examples - Complete model examples (SIR, SEIR, stratified)</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<p>Complete API documentation for all public interfaces:</p> <ul> <li>Model Builder - ModelBuilder class documentation</li> <li>Simulation - Simulation runner</li> <li>Calibrator - Parameter calibration and optimization</li> <li>Constants - Model types and enumerations</li> </ul>"},{"location":"#development","title":"Development","text":"<p>Contributing to Commol:</p> <ul> <li>Development Workflow - Setup, branching, CI/CD</li> <li>Contributing Guidelines - How to contribute</li> <li>Release Process - Version management and releases</li> </ul>"},{"location":"#license","title":"License","text":"<p>Commol is licensed under the MIT License. See License for details.</p>"},{"location":"#authors","title":"Authors","text":"<p>MUNQU Team</p> <ul> <li>Rafael J. Villanueva Mic\u00f3</li> <li>Carlos Andreu Vilarroig</li> <li>David Mart\u00ednez Rodr\u00edguez</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to Commol will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>GitHub Actions CI/CD pipelines for code quality, building, and PyPI releases</li> <li>MkDocs Material documentation site</li> <li>Comprehensive development workflow documentation</li> <li>Contributing guidelines and release process documentation</li> </ul>"},{"location":"about/changelog/#001-2025","title":"[0.0.1] - 2025","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of Commol</li> <li>ModelBuilder fluent API for constructing compartment models</li> <li>Support for difference equations models</li> <li>Disease states and stratifications</li> <li>Mathematical expression support in transition rates</li> <li>Rust-powered simulation engine</li> <li>Python API with Pydantic validation</li> <li>Basic SIR, SEIR model support</li> <li>Initial conditions and parameter management</li> <li>Simulation runner with multiple output formats</li> </ul>"},{"location":"about/changelog/#security","title":"Security","text":"<ul> <li>Expression validation to prevent code injection</li> <li>Input sanitization for mathematical formulas</li> </ul>"},{"location":"about/changelog/#version-history","title":"Version History","text":"<ul> <li>0.0.1 - Initial release with core functionality</li> <li>Unreleased - Current development version</li> </ul> <p>For detailed information about each release, see the GitHub Releases page.</p>"},{"location":"about/license/","title":"License","text":"<p>EpiModel is licensed under the MIT License.</p>"},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2025 MUNQU Team</p> <ul> <li>Rafael J. Villanueva Mic\u00f3</li> <li>Carlos Andreu Vilarroig</li> <li>David Mart\u00ednez Rodr\u00edguez</li> </ul> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>EpiModel uses the following open-source libraries:</p>"},{"location":"about/license/#python-dependencies","title":"Python Dependencies","text":"<ul> <li>Pydantic - MIT License</li> <li>cffi - MIT License</li> </ul>"},{"location":"about/license/#rust-dependencies","title":"Rust Dependencies","text":"<ul> <li>pyo3 - Apache-2.0 OR MIT License</li> <li>serde - Apache-2.0 OR MIT License</li> </ul> <p>For a complete list of dependencies and their licenses, see the project's <code>Cargo.toml</code> and <code>pyproject.toml</code> files.</p>"},{"location":"advanced/model-structure/","title":"Model Structure (Advanced)","text":"<p>For Advanced Users</p> <p>This section documents the internal structure of the <code>Model</code> class and its components.</p> <pre><code>**Most users don't need this** - use `ModelBuilder` instead to create models.\n\nThis is useful for:\n- Understanding the internal model representation\n- Working with `ModelLoader.from_json()`\n- Contributing to the library\n- Debugging complex models\n</code></pre>"},{"location":"advanced/model-structure/#model","title":"Model","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.model.Model","title":"Model","text":"<p>               Bases: <code>BaseModel</code></p> <p>Root class of compartment model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A unique name that identifies the model.</p> <code>description</code> <code>str | None</code> <p>A human-readable description of the model's purpose and function.</p> <code>version</code> <code>str | None</code> <p>The version number of the model.</p> <code>population</code> <code>Population</code> <p>Population details, subpopulations, stratifications and initial conditions.</p> <code>parameters</code> <code>list[Parameter]</code> <p>A list of global model parameters.</p> <code>dynamics</code> <code>Dynamics</code> <p>The rules that govern system evolution.</p> Source code in <code>commol/context/model.py</code> <pre><code>class Model(BaseModel):\n    \"\"\"\n    Root class of compartment model.\n\n    Attributes\n    ----------\n    name : str\n        A unique name that identifies the model.\n    description : str | None\n        A human-readable description of the model's purpose and function.\n    version : str | None\n        The version number of the model.\n    population : Population\n        Population details, subpopulations, stratifications and initial conditions.\n    parameters : list[Parameter]\n        A list of global model parameters.\n    dynamics : Dynamics\n        The rules that govern system evolution.\n    \"\"\"\n\n    name: str = Field(..., description=\"Name which identifies the model.\")\n    description: str | None = Field(\n        None,\n        description=\"Human-readable description of the model's purpose and function.\",\n    )\n    version: str | None = Field(None, description=\"Version number of the model.\")\n\n    population: Population\n    parameters: list[Parameter]\n    dynamics: Dynamics\n\n    @model_validator(mode=\"after\")\n    def validate_unique_parameter_ids(self) -&gt; Self:\n        \"\"\"\n        Validates that parameter IDs are unique.\n        \"\"\"\n        parameter_ids = [p.id for p in self.parameters]\n        if len(parameter_ids) != len(set(parameter_ids)):\n            duplicates = [\n                item for item in set(parameter_ids) if parameter_ids.count(item) &gt; 1\n            ]\n            raise ValueError(f\"Duplicate parameter IDs found: {duplicates}\")\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_formula_variables(self) -&gt; Self:\n        \"\"\"\n        Validate that all variables in rate expressions are defined.\n        This is done by gathering all valid identifiers and checking each\n        transition's rate expressions against them.\n        \"\"\"\n        valid_identifiers = self._get_valid_identifiers()\n\n        for transition in self.dynamics.transitions:\n            self._validate_transition_rates(transition, valid_identifiers)\n        return self\n\n    def _get_valid_identifiers(self) -&gt; set[str]:\n        \"\"\"Gathers all valid identifiers for use in rate expressions.\"\"\"\n        special_vars = {\"N\", \"step\", \"pi\", \"e\", \"t\"}\n        param_ids = {param.id for param in self.parameters}\n        bin_ids = {bin_item.id for bin_item in self.population.bins}\n\n        strat_category_ids: set[str] = {\n            cat for strat in self.population.stratifications for cat in strat.categories\n        }\n\n        subpopulation_n_vars = self._get_subpopulation_n_vars()\n\n        return (\n            param_ids\n            | bin_ids\n            | strat_category_ids\n            | special_vars\n            | subpopulation_n_vars\n        )\n\n    def _get_subpopulation_n_vars(self) -&gt; set[str]:\n        \"\"\"Generates all possible N_{category...} variable names.\"\"\"\n        if not self.population.stratifications:\n            return set()\n\n        subpopulation_n_vars: set[str] = set()\n        category_groups = [s.categories for s in self.population.stratifications]\n\n        # All possible combinations of categories across different stratifications\n        full_category_combos = product(*category_groups)\n\n        for combo_tuple in full_category_combos:\n            # For each combo, find all non-empty subsets\n            for i in range(1, len(combo_tuple) + 1):\n                for subset in combinations(combo_tuple, i):\n                    var_name = f\"N_{'_'.join(subset)}\"\n                    subpopulation_n_vars.add(var_name)\n\n        return subpopulation_n_vars\n\n    def _validate_transition_rates(\n        self, transition: Transition, valid_identifiers: set[str]\n    ) -&gt; None:\n        \"\"\"Validates the rate expressions for a single transition.\"\"\"\n        if transition.rate:\n            self._validate_rate_expression(\n                transition.rate, transition.id, \"rate\", valid_identifiers\n            )\n\n        if transition.stratified_rates:\n            for sr in transition.stratified_rates:\n                self._validate_rate_expression(\n                    sr.rate, transition.id, \"stratified_rate\", valid_identifiers\n                )\n\n    def _validate_rate_expression(\n        self, rate: str, transition_id: str, context: str, valid_identifiers: set[str]\n    ) -&gt; None:\n        \"\"\"Validates variables in a single rate expression.\"\"\"\n        variables = get_expression_variables(rate)\n        undefined_vars = [var for var in variables if var not in valid_identifiers]\n        if undefined_vars:\n            param_ids = {param.id for param in self.parameters}\n            bin_ids = {bin_item.id for bin_item in self.population.bins}\n            raise ValueError(\n                (\n                    f\"Undefined variables in transition '{transition_id}' \"\n                    f\"{context} '{rate}': {', '.join(undefined_vars)}. \"\n                    f\"Available parameters: \"\n                    f\"{', '.join(sorted(param_ids)) if param_ids else 'none'}. \"\n                    f\"Available bins: \"\n                    f\"{', '.join(sorted(bin_ids)) if bin_ids else 'none'}.\"\n                )\n            )\n\n    @model_validator(mode=\"after\")\n    def validate_transition_ids(self) -&gt; Self:\n        \"\"\"\n        Validates that transition ids (source/target) are consistent in type\n        and match the defined Bin IDs or Stratification Categories\n        in the Population instance.\n        \"\"\"\n\n        bin_ids = {bin_item.id for bin_item in self.population.bins}\n        categories_ids = {\n            cat for strat in self.population.stratifications for cat in strat.categories\n        }\n        bin_and_categories_ids = bin_ids.union(categories_ids)\n\n        for transition in self.dynamics.transitions:\n            source = set(transition.source)\n            target = set(transition.target)\n            transition_ids = source.union(target)\n\n            if not transition_ids.issubset(bin_and_categories_ids):\n                invalid_ids = transition_ids - bin_and_categories_ids\n                raise ValueError(\n                    (\n                        f\"Transition '{transition.id}' contains invalid ids: \"\n                        f\"{invalid_ids}. Ids must be defined in Bin ids \"\n                        f\"or Stratification Categories.\"\n                    )\n                )\n\n            is_bin_flow = transition_ids.issubset(bin_ids)\n            is_stratification_flow = transition_ids.issubset(categories_ids)\n\n            if (not is_bin_flow) and (not is_stratification_flow):\n                bin_elements = transition_ids.intersection(bin_ids)\n                categories_elements = transition_ids.intersection(categories_ids)\n                raise ValueError(\n                    (\n                        f\"Transition '{transition.id}' mixes id types. \"\n                        f\"Found Bin ids ({bin_elements}) and \"\n                        f\"Stratification Categories ids ({categories_elements}). \"\n                        \"Transitions must be purely Bin flow or purely \"\n                        f\"Stratification flow.\"\n                    )\n                )\n\n            if is_stratification_flow:\n                category_to_stratification_map = {\n                    cat: strat.id\n                    for strat in self.population.stratifications\n                    for cat in strat.categories\n                }\n                parent_stratification_ids = {\n                    category_to_stratification_map[cat_id] for cat_id in transition_ids\n                }\n                if len(parent_stratification_ids) &gt; 1:\n                    mixed_strats = \", \".join(parent_stratification_ids)\n                    raise ValueError(\n                        (\n                            f\"Transition '{transition.id}' is a Stratification flow \"\n                            f\"but involves categories from multiple stratifications: \"\n                            f\"{mixed_strats}. A single transition must only move \"\n                            f\"between categories belonging to the same parent \"\n                            f\"stratification.\"\n                        )\n                    )\n\n        return self\n\n    def print_equations(self, output_file: str | None = None) -&gt; None:\n        \"\"\"\n        Prints the difference equations of the model in mathematical form.\n\n        Displays model metadata and the system of difference equations in both\n        compact (mathematical notation) and expanded (individual equations) forms.\n\n        Parameters\n        ----------\n        output_file : str | None\n            If provided, writes the equations to this file path instead of printing\n            to console. If None, prints to console.\n\n        Raises\n        ------\n        ValueError\n            If the model is not a DifferenceEquations model.\n        \"\"\"\n\n        if self.dynamics.typology != ModelTypes.DIFFERENCE_EQUATIONS:\n            raise ValueError(\n                (\n                    f\"print_equations only supports DifferenceEquations models. \"\n                    f\"Current model type: {self.dynamics.typology}\"\n                )\n            )\n\n        lines = self._generate_model_header()\n\n        # Always generate both compact and expanded forms\n        lines.extend(self._generate_compact_form())\n        lines.append(\"\")\n        lines.extend(self._generate_expanded_form())\n\n        output = \"\\n\".join(lines)\n        self._write_output(output, output_file)\n\n    def _generate_model_header(self) -&gt; list[str]:\n        \"\"\"Generate the header lines with model metadata.\"\"\"\n        lines: list[str] = []\n        lines.append(\"=\" * 40)\n        lines.append(\"MODEL INFORMATION\")\n        lines.append(\"=\" * 40)\n        lines.append(f\"Model: {self.name}\")\n        lines.append(f\"Model Type: {self.dynamics.typology}\")\n        lines.append(f\"Number of Bins: {len(self.population.bins)}\")\n        lines.append(\n            f\"Number of Stratifications: {len(self.population.stratifications)}\"\n        )\n        lines.append(f\"Number of Parameters: {len(self.parameters)}\")\n        lines.append(f\"Number of Transitions: {len(self.dynamics.transitions)}\")\n\n        # List bins\n        bin_ids = [bin_item.id for bin_item in self.population.bins]\n        lines.append(f\"Bins: {', '.join(bin_ids)}\")\n\n        # List stratifications\n        if self.population.stratifications:\n            lines.append(\"Stratifications:\")\n            for strat in self.population.stratifications:\n                categories = \", \".join(strat.categories)\n                lines.append(f\"  - {strat.id}: [{categories}]\")\n\n        lines.append(\"\")\n        return lines\n\n    def _collect_bin_and_category_ids(self) -&gt; set[str]:\n        \"\"\"Collect all IDs from bins and stratification categories.\"\"\"\n        all_ids = {bin_item.id for bin_item in self.population.bins}\n        for strat in self.population.stratifications:\n            all_ids.update(strat.categories)\n        return all_ids\n\n    def _build_flow_equations(\n        self, bin_and_category_ids: set[str]\n    ) -&gt; dict[str, dict[str, list[str]]]:\n        \"\"\"Build a mapping of bins and categories to their inflows and outflows.\"\"\"\n        equations: dict[str, dict[str, list[str]]] = {\n            id_: {\"inflows\": [], \"outflows\": []} for id_ in bin_and_category_ids\n        }\n        for transition in self.dynamics.transitions:\n            rate = transition.rate if transition.rate else \"\"\n            source_counts = {\n                state: transition.source.count(state)\n                for state in set(transition.source)\n            }\n            target_counts = {\n                state: transition.target.count(state)\n                for state in set(transition.target)\n            }\n            all_states = set(transition.source) | set(transition.target)\n            for state in all_states:\n                net_change = target_counts.get(state, 0) - source_counts.get(state, 0)\n                if net_change &gt; 0:\n                    equations[state][\"inflows\"].append(rate)\n                elif net_change &lt; 0:\n                    equations[state][\"outflows\"].append(rate)\n\n        return equations\n\n    def _format_bin_equation(self, flows: dict[str, list[str]]) -&gt; str:\n        \"\"\"Format the equation for a single bin or category from its flows.\"\"\"\n        terms: list[str] = []\n\n        for inflow in flows[\"inflows\"]:\n            if inflow:  # Only add if not empty\n                terms.append(f\"+ ({inflow})\")\n\n        for outflow in flows[\"outflows\"]:\n            if outflow:  # Only add if not empty\n                terms.append(f\"- ({outflow})\")\n\n        if not terms:\n            return \"0\"\n\n        result = \" \".join(terms)\n        # Remove leading + sign and space if present\n        if result.startswith(\"+ \"):\n            result = result[2:]\n        return result\n\n    def _generate_compact_form(self) -&gt; list[str]:\n        \"\"\"Generate compact mathematical notation form for stratified models.\"\"\"\n        lines: list[str] = []\n        lines.append(\"=\" * 40)\n        lines.append(\"COMPACT FORM\")\n        lines.append(\"=\" * 40)\n        lines.append(\"\")\n\n        bin_ids = [bin_item.id for bin_item in self.population.bins]\n        bin_transitions, stratification_transitions = (\n            self._separate_transitions_by_type()\n        )\n\n        compartments = self._generate_compartments()\n\n        lines.extend(\n            self._format_bin_transitions_compact_stratified(\n                bin_transitions, compartments\n            )\n        )\n        lines.extend(\n            self._format_stratification_transitions_compact_stratified(\n                stratification_transitions, bin_ids\n            )\n        )\n        lines.extend(self._format_total_system_size(bin_ids))\n\n        return lines\n\n    def _generate_compartments(self) -&gt; list[tuple[str, ...]]:\n        \"\"\"\n        Generate all compartment combinations from bins and stratifications.\n        \"\"\"\n        bin_ids = [state.id for state in self.population.bins]\n\n        if not self.population.stratifications:\n            return [(state,) for state in bin_ids]\n\n        strat_categories = [\n            strat.categories for strat in self.population.stratifications\n        ]\n\n        compartments: list[tuple[str, ...]] = []\n        for bin_id in bin_ids:\n            for strat_combo in product(*strat_categories):\n                compartments.append((bin_id,) + strat_combo)\n\n        return compartments\n\n    def _compartment_to_string(self, compartment: tuple[str, ...]) -&gt; str:\n        \"\"\"Convert compartment tuple to string like 'S_young_urban'.\"\"\"\n        return \"_\".join(compartment)\n\n    def _get_rate_for_compartment(\n        self, transition: Transition, compartment: tuple[str, ...]\n    ) -&gt; str | None:\n        \"\"\"Get the appropriate rate for a compartment, considering stratified rates.\"\"\"\n        if not transition.stratified_rates or len(compartment) == 1:\n            return transition.rate\n\n        compartment_strat_map: dict[str, str] = {}\n        for i, strat in enumerate(self.population.stratifications):\n            compartment_strat_map[strat.id] = compartment[i + 1]\n\n        for strat_rate in transition.stratified_rates:\n            matches = True\n            for condition in strat_rate.conditions:\n                if (\n                    compartment_strat_map.get(condition.stratification)\n                    != condition.category\n                ):\n                    matches = False\n                    break\n            if matches:\n                return strat_rate.rate\n\n        # No stratified rate matched, use fallback\n        return transition.rate\n\n    def _separate_transitions_by_type(\n        self,\n    ) -&gt; tuple[list[Transition], list[Transition]]:\n        \"\"\"Separate transitions into bin and stratification types.\"\"\"\n        bin_ids = [bin_item.id for bin_item in self.population.bins]\n        bin_id_set = set(bin_ids)\n\n        bin_transitions: list[Transition] = []\n        stratification_transitions: list[Transition] = []\n\n        for transition in self.dynamics.transitions:\n            transition_ids = set(transition.source) | set(transition.target)\n            if transition_ids.issubset(bin_id_set):\n                bin_transitions.append(transition)\n            else:\n                stratification_transitions.append(transition)\n\n        return bin_transitions, stratification_transitions\n\n    def _format_stratification_transitions_compact(\n        self, bin_ids: list[str], stratification_transitions: list[Transition]\n    ) -&gt; list[str]:\n        \"\"\"Format stratification transitions in compact form.\"\"\"\n        lines: list[str] = []\n        strat_by_id = self._group_transitions_by_stratification(\n            stratification_transitions\n        )\n\n        for strat in self.population.stratifications:\n            if strat_by_id[strat.id]:\n                lines.append(f\"Stratification Transitions ({strat.id}):\")\n                disease_states_str = \", \".join(bin_ids)\n                lines.append(f\"For each bin X in {{{disease_states_str}}}:\")\n\n                for category in strat.categories:\n                    equation = self._build_category_equation(\n                        category, strat_by_id[strat.id]\n                    )\n                    if equation:\n                        lines.append(f\"  dX_{category}/dt: {equation}\")\n\n                lines.append(\"\")\n\n        return lines\n\n    def _group_transitions_by_stratification(\n        self, transitions: list[Transition]\n    ) -&gt; dict[str, list[Transition]]:\n        \"\"\"Group stratification transitions by their stratification ID.\"\"\"\n        strat_by_id: dict[str, list[Transition]] = {}\n        for strat in self.population.stratifications:\n            strat_by_id[strat.id] = []\n            for transition in transitions:\n                transition_states = set(transition.source) | set(transition.target)\n                if transition_states.issubset(set(strat.categories)):\n                    strat_by_id[strat.id].append(transition)\n        return strat_by_id\n\n    def _build_category_equation(\n        self, category: str, transitions: list[Transition]\n    ) -&gt; str:\n        \"\"\"Build equation for a stratification category.\"\"\"\n        inflows: list[str] = []\n        outflows: list[str] = []\n\n        for transition in transitions:\n            if not transition.rate:\n                continue\n\n            source_count = transition.source.count(category)\n            target_count = transition.target.count(category)\n            net_change = target_count - source_count\n\n            if net_change &gt; 0:\n                inflows.append(f\"+ ({transition.rate} * X)\")\n            elif net_change &lt; 0:\n                outflows.append(f\"- ({transition.rate} * X)\")\n\n        terms = inflows + outflows\n        if not terms:\n            return \"\"\n\n        result = \" \".join(terms)\n        # Remove leading + sign if present\n        if result.startswith(\"+\"):\n            result = result[1:]\n        return result\n\n    def _format_bin_transitions_compact(\n        self, bin_ids: list[str], bin_transitions: list[Transition]\n    ) -&gt; list[str]:\n        \"\"\"Format bin transitions in compact form.\"\"\"\n        lines: list[str] = []\n\n        if not bin_transitions:\n            return lines\n\n        lines.append(\"Bin Transitions:\")\n\n        if self.population.stratifications:\n            all_categories = [\n                cat\n                for strat in self.population.stratifications\n                for cat in strat.categories\n            ]\n            categories_str = \", \".join(all_categories)\n            lines.append(f\"For each stratification s in {{{categories_str}}}:\")\n\n        for bin_id in bin_ids:\n            equation = self._build_bin_equation_from_transitions(\n                bin_id, bin_transitions\n            )\n            if equation:\n                suffix = \"_s\" if self.population.stratifications else \"\"\n                lines.append(f\"  d{bin_id}{suffix}/dt: {equation}\")\n\n        lines.append(\"\")\n        return lines\n\n    def _build_bin_equation_from_transitions(\n        self, bin_id: str, transitions: list[Transition]\n    ) -&gt; str:\n        \"\"\"Build equation for a bin.\"\"\"\n        inflows: list[str] = []\n        outflows: list[str] = []\n\n        for transition in transitions:\n            if not transition.rate:\n                continue\n\n            source_count = transition.source.count(bin_id)\n            target_count = transition.target.count(bin_id)\n            net_change = target_count - source_count\n\n            if net_change &gt; 0:\n                inflows.append(f\"+ ({transition.rate})\")\n            elif net_change &lt; 0:\n                outflows.append(f\"- ({transition.rate})\")\n\n        terms = inflows + outflows\n        if not terms:\n            return \"\"\n\n        result = \" \".join(terms)\n        # Remove leading + sign if present\n        if result.startswith(\"+\"):\n            result = result[1:]\n        return result\n\n    def _format_total_system_size(self, bin_ids: list[str]) -&gt; list[str]:\n        \"\"\"Format the total system size information.\"\"\"\n        lines: list[str] = []\n\n        num_disease_states = len(bin_ids)\n        if not self.population.stratifications:\n            total_equations = num_disease_states\n            lines.append(\n                (\n                    f\"Total System: {total_equations} coupled equations \"\n                    f\"({num_disease_states} bins)\"\n                )\n            )\n            return lines\n\n        num_strat_combinations = 1\n        strat_details: list[str] = []\n        for strat in self.population.stratifications:\n            num_cat = len(strat.categories)\n            num_strat_combinations *= num_cat\n            strat_details.append(f\"{num_cat} {strat.id}\")\n\n        total_equations = num_disease_states * num_strat_combinations\n\n        lines.append(\n            (\n                f\"Total System: {total_equations} coupled equations \"\n                f\"({num_disease_states} bins \u00d7 {' \u00d7 '.join(strat_details)})\"\n            )\n        )\n\n        return lines\n\n    def _format_bin_transitions_compact_stratified(\n        self, bin_transitions: list[Transition], compartments: list[tuple[str, ...]]\n    ) -&gt; list[str]:\n        \"\"\"Format bin transitions showing specific compartments and rates.\"\"\"\n        lines: list[str] = []\n\n        if not bin_transitions:\n            return lines\n\n        lines.append(\"Bin Transitions:\")\n\n        for transition in bin_transitions:\n            source_bins = transition.source\n            target_bins = transition.target\n\n            source_str = \", \".join(sorted(set(source_bins))) if source_bins else \"none\"\n            target_str = \", \".join(sorted(set(target_bins))) if target_bins else \"none\"\n            lines.append(\n                f\"{transition.id.capitalize()} ({source_str} -&gt; {target_str}):\"\n            )\n\n            for compartment in compartments:\n                bin_id = compartment[0]\n\n                if bin_id in source_bins:\n                    source_compartment_str = self._compartment_to_string(compartment)\n\n                    if target_bins:\n                        target_bin = target_bins[0]\n                        target_compartment_str = source_compartment_str.replace(\n                            bin_id, target_bin, 1\n                        )\n                    else:\n                        target_compartment_str = \"none\"\n\n                    rate = self._get_rate_for_compartment(transition, compartment)\n\n                    lines.append(\n                        (\n                            f\"  {source_compartment_str} -&gt; \"\n                            f\"{target_compartment_str}: {rate}\"\n                        )\n                    )\n\n            lines.append(\"\")\n\n        return lines\n\n    def _build_stratified_for_each_line(\n        self, bin_ids: list[str], other_strats: list[\"Stratification\"]\n    ) -&gt; str:\n        if other_strats:\n            other_strats_strs = [\n                f\"each {s.id} in {{{', '.join(s.categories)}}}\" for s in other_strats\n            ]\n            return (\n                f\"For each bin X in {{{', '.join(bin_ids)}}} \"\n                f\"and {', '.join(other_strats_strs)}:\"\n            )\n        return f\"For each bin X in {{{', '.join(bin_ids)}}}:\"\n\n    def _build_stratified_transition_line(\n        self,\n        trans: Transition,\n        strat_idx: int,\n        combo: tuple[str, ...],\n    ) -&gt; str:\n        src_cat = trans.source[0]\n        tgt_cat = trans.target[0]\n\n        source_parts = [\"\"] * len(self.population.stratifications)\n        target_parts = [\"\"] * len(self.population.stratifications)\n        source_parts[strat_idx] = src_cat\n        target_parts[strat_idx] = tgt_cat\n\n        combo_idx = 0\n        for i in range(len(self.population.stratifications)):\n            if i != strat_idx:\n                source_parts[i] = combo[combo_idx]\n                target_parts[i] = combo[combo_idx]\n                combo_idx += 1\n\n        source_comp = f\"X_{'_'.join(source_parts)}\"\n        target_comp = f\"X_{'_'.join(target_parts)}\"\n\n        sample_compartment = (\"X\",) + tuple(source_parts)\n        rate = self._get_rate_for_compartment(trans, sample_compartment)\n        rate_expr = (\n            f\"{rate} * {source_comp}\" if rate else f\"{trans.rate} * {source_comp}\"\n        )\n\n        return f\"  {source_comp} -&gt; {target_comp}: {rate_expr}\"\n\n    def _format_stratification_transitions_compact_stratified(\n        self,\n        stratification_transitions: list[Transition],\n        bin_ids: list[str],\n    ) -&gt; list[str]:\n        \"\"\"Format stratification transitions showing movements between categories.\"\"\"\n        lines: list[str] = []\n        strat_by_id = self._group_transitions_by_stratification(\n            stratification_transitions\n        )\n\n        for strat_idx, strat in enumerate(self.population.stratifications):\n            if not strat_by_id.get(strat.id):\n                continue\n\n            transition = strat_by_id[strat.id][0]\n            source_cat = transition.source[0] if transition.source else \"none\"\n            target_cat = transition.target[0] if transition.target else \"none\"\n\n            if not source_cat or not target_cat:\n                continue\n\n            lines.append(\n                (\n                    f\"{strat.id.capitalize()} Stratification Transitions \"\n                    f\"({source_cat} -&gt; {target_cat}):\"\n                )\n            )\n\n            other_strats = [\n                s\n                for i, s in enumerate(self.population.stratifications)\n                if i != strat_idx\n            ]\n\n            lines.append(self._build_stratified_for_each_line(bin_ids, other_strats))\n\n            for trans in strat_by_id[strat.id]:\n                other_cat_combos = (\n                    list(product(*[s.categories for s in other_strats]))\n                    if other_strats\n                    else [()]\n                )\n\n                for combo in other_cat_combos:\n                    lines.append(\n                        self._build_stratified_transition_line(trans, strat_idx, combo)\n                    )\n\n            lines.append(\"\")\n\n        return lines\n\n    def _generate_expanded_form(self) -&gt; list[str]:\n        \"\"\"Generate expanded form with individual equations for each compartment.\"\"\"\n        lines: list[str] = []\n\n        lines.append(\"=\" * 40)\n        lines.append(\"EXPANDED FORM\")\n        lines.append(\"=\" * 40)\n\n        has_stratifications = len(self.population.stratifications) &gt; 0\n\n        if has_stratifications:\n            compartments = self._generate_compartments()\n            bin_transitions, stratification_transitions = (\n                self._separate_transitions_by_type()\n            )\n\n            for compartment in compartments:\n                compartment_str = self._compartment_to_string(compartment)\n                equation = self._build_compartment_equation(\n                    compartment, bin_transitions, stratification_transitions\n                )\n                lines.append(f\"d{compartment_str}/dt = {equation}\")\n        else:\n            bin_and_category_ids = self._collect_bin_and_category_ids()\n            equations = self._build_flow_equations(bin_and_category_ids)\n            bin_ids = [bin_item.id for bin_item in self.population.bins]\n\n            for bin_id in bin_ids:\n                equation = self._format_bin_equation(equations[bin_id])\n                lines.append(f\"d{bin_id}/dt = {equation}\")\n\n        return lines\n\n    def _build_compartment_equation(\n        self,\n        compartment: tuple[str, ...],\n        bin_transitions: list[Transition],\n        stratification_transitions: list[Transition],\n    ) -&gt; str:\n        \"\"\"Build the complete equation for a specific compartment.\"\"\"\n        terms: list[str] = []\n        bin_id = compartment[0]\n\n        for transition in bin_transitions:\n            source_count = transition.source.count(bin_id)\n            target_count = transition.target.count(bin_id)\n            net_change = target_count - source_count\n\n            if net_change != 0:\n                rate = self._get_rate_for_compartment(transition, compartment)\n                if rate:\n                    if net_change &gt; 0:\n                        terms.append(f\"+ ({rate})\")\n                    else:\n                        terms.append(f\"- ({rate})\")\n\n        for transition in stratification_transitions:\n            flow_term = self._get_stratification_flow_for_compartment(\n                compartment, transition\n            )\n            if flow_term:\n                terms.append(flow_term)\n\n        if not terms:\n            return \"0\"\n\n        equation = \" \".join(terms)\n        if equation.startswith(\"+ \"):\n            return equation[2:]\n        if equation.startswith(\"+\"):\n            return equation[1:]\n        return equation\n\n    def _get_stratification_flow_for_compartment(\n        self, compartment: tuple[str, ...], transition: Transition\n    ) -&gt; str | None:\n        \"\"\"Calculate stratification flow term for a compartment.\"\"\"\n        if len(compartment) == 1:\n            return None\n\n        transition_states = set(transition.source) | set(transition.target)\n        target_strat_idx = None\n\n        for i, strat in enumerate(self.population.stratifications):\n            if transition_states.issubset(set(strat.categories)):\n                target_strat_idx = i\n                break\n\n        if target_strat_idx is None:\n            return None\n\n        compartment_category = compartment[target_strat_idx + 1]\n        source_categories = transition.source\n        target_categories = transition.target\n\n        source_count = source_categories.count(compartment_category)\n        target_count = target_categories.count(compartment_category)\n        net_change = target_count - source_count\n\n        if net_change == 0:\n            return None\n\n        rate = self._get_rate_for_compartment(transition, compartment)\n        if not rate:\n            return None\n\n        if net_change &lt; 0:\n            compartment_str = self._compartment_to_string(compartment)\n            return f\"- ({rate} * {compartment_str})\"\n        else:\n            source_category = source_categories[0] if source_categories else None\n            if source_category:\n                source_compartment = list(compartment)\n                source_compartment[target_strat_idx + 1] = source_category\n                source_compartment_str = self._compartment_to_string(\n                    tuple(source_compartment)\n                )\n                return f\"+ ({rate} * {source_compartment_str})\"\n\n        return None\n\n    def _write_output(self, output: str, output_file: str | None) -&gt; None:\n        \"\"\"Write output to file or console.\"\"\"\n        if output_file:\n            with open(output_file, \"w\") as f:\n                _ = f.write(output)\n        else:\n            print(output)\n\n    def check_unit_consistency(self) -&gt; None:\n        \"\"\"\n        Check unit consistency of all equations in the model.\n\n        This method validates that all transition rates have consistent units.\n        It only performs the check if ALL parameters have units specified.\n        If any parameter lacks a unit, the check is skipped.\n\n        For difference equation models, all rates should have units that result in\n        population change rates (e.g., \"person/day\" or \"1/day\" when multiplied by\n        population).\n\n        Raises\n        ------\n        UnitConsistencyError\n            If unit inconsistencies are found in any equation.\n        ValueError\n            If the model type doesn't support unit checking.\n\n        Examples\n        --------\n        &gt;&gt;&gt; model.check_unit_consistency()  # Raises exception if inconsistent\n\n        Notes\n        -----\n        - Bin variables are assumed to have units of \"person\"\n        - Predefined variables (N, N_young, etc.) have units of \"person\"\n        - Time step variables (t, step) are dimensionless\n        - Mathematical constants (pi, e) are dimensionless\n        \"\"\"\n        # Check if all parameters have units\n        if not check_all_parameters_have_units(self.parameters):\n            # Skip check if not all parameters have units\n            return\n\n        if self.dynamics.typology != ModelTypes.DIFFERENCE_EQUATIONS:\n            raise ValueError(\n                (\n                    f\"Unit checking is only supported for DifferenceEquations models. \"\n                    f\"Current model type: {self.dynamics.typology}\"\n                )\n            )\n\n        # Build variable units mapping\n        variable_units = self._build_variable_units()\n\n        # Check each transition\n        errors: list[str] = []\n        for transition in self.dynamics.transitions:\n            # Check main rate\n            if transition.rate:\n                is_consistent, error_msg = self._check_transition_rate_units(\n                    transition.rate,\n                    transition.id,\n                    variable_units,\n                )\n                if not is_consistent and error_msg:\n                    errors.append(error_msg)\n\n            # Check stratified rates\n            if transition.stratified_rates:\n                for idx, strat_rate in enumerate(transition.stratified_rates):\n                    is_consistent, error_msg = self._check_transition_rate_units(\n                        strat_rate.rate,\n                        f\"{transition.id} (stratified rate {idx + 1})\",\n                        variable_units,\n                    )\n                    if not is_consistent and error_msg:\n                        errors.append(error_msg)\n\n        if errors:\n            error_message = \"Unit consistency check failed:\\n\" + \"\\n\".join(\n                f\"  - {err}\" for err in errors\n            )\n            raise UnitConsistencyError(error_message)\n\n    def _build_variable_units(self) -&gt; dict[str, str]:\n        \"\"\"Build a mapping of all variables to their units.\"\"\"\n        variable_units: dict[str, str] = {}\n\n        # Add parameter units\n        for param in self.parameters:\n            if param.unit:\n                variable_units[param.id] = param.unit\n\n        # Add bin units (all are \"person\")\n        for state in self.population.bins:\n            variable_units[state.id] = \"person\"\n\n        # Add stratification category units (all are \"person\" for population counts)\n        for strat in self.population.stratifications:\n            for category in strat.categories:\n                variable_units[category] = \"person\"\n\n        # Add predefined variable units (N, N_young, etc.)\n        predefined_units = get_predefined_variable_units(\n            self.population.stratifications\n        )\n        variable_units.update(predefined_units)\n\n        # Add dimensionless special variables\n        variable_units[\"step\"] = \"dimensionless\"\n        variable_units[\"t\"] = \"dimensionless\"\n        variable_units[\"pi\"] = \"dimensionless\"\n        variable_units[\"e\"] = \"dimensionless\"\n\n        return variable_units\n\n    def _check_transition_rate_units(\n        self,\n        rate: str,\n        transition_id: str,\n        variable_units: dict[str, str],\n    ) -&gt; tuple[bool, str | None]:\n        \"\"\"\n        Check units for a single transition rate.\n\n        For transitions in difference equations, rates represent the absolute change\n        in population per time step, so they should have units of \"person/day\"\n        (or person/timestep).\n        \"\"\"\n        # Get variables used in the rate expression\n        variables = get_expression_variables(rate)\n\n        # Build variable units for this specific rate\n        rate_variable_units: dict[str, str] = {}\n        for var in variables:\n            if var in variable_units:\n                rate_variable_units[var] = variable_units[var]\n            else:\n                # Variable not found\n                # This should have been caught by earlier validation\n                return (\n                    False,\n                    (\n                        f\"Transition '{transition_id}': Variable '{var}' in rate \"\n                        f\"'{rate}' has no defined unit\"\n                    ),\n                )\n\n        # For difference equations, rates should result in person per time unit\n        # This represents the absolute change in population per time step\n        expected_unit = \"person/day\"\n\n        # Check unit consistency\n        is_consistent, error_msg = check_equation_units(\n            rate, rate_variable_units, expected_unit\n        )\n\n        if not is_consistent:\n            return (\n                False,\n                f\"Transition '{transition_id}': {error_msg}\",\n            )\n\n        return (True, None)\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.model.Model.validate_unique_parameter_ids","title":"validate_unique_parameter_ids","text":"<pre><code>validate_unique_parameter_ids() -&gt; Self\n</code></pre> <p>Validates that parameter IDs are unique.</p> Source code in <code>commol/context/model.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_unique_parameter_ids(self) -&gt; Self:\n    \"\"\"\n    Validates that parameter IDs are unique.\n    \"\"\"\n    parameter_ids = [p.id for p in self.parameters]\n    if len(parameter_ids) != len(set(parameter_ids)):\n        duplicates = [\n            item for item in set(parameter_ids) if parameter_ids.count(item) &gt; 1\n        ]\n        raise ValueError(f\"Duplicate parameter IDs found: {duplicates}\")\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.validate_formula_variables","title":"validate_formula_variables","text":"<pre><code>validate_formula_variables() -&gt; Self\n</code></pre> <p>Validate that all variables in rate expressions are defined. This is done by gathering all valid identifiers and checking each transition's rate expressions against them.</p> Source code in <code>commol/context/model.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_formula_variables(self) -&gt; Self:\n    \"\"\"\n    Validate that all variables in rate expressions are defined.\n    This is done by gathering all valid identifiers and checking each\n    transition's rate expressions against them.\n    \"\"\"\n    valid_identifiers = self._get_valid_identifiers()\n\n    for transition in self.dynamics.transitions:\n        self._validate_transition_rates(transition, valid_identifiers)\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.validate_transition_ids","title":"validate_transition_ids","text":"<pre><code>validate_transition_ids() -&gt; Self\n</code></pre> <p>Validates that transition ids (source/target) are consistent in type and match the defined Bin IDs or Stratification Categories in the Population instance.</p> Source code in <code>commol/context/model.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_transition_ids(self) -&gt; Self:\n    \"\"\"\n    Validates that transition ids (source/target) are consistent in type\n    and match the defined Bin IDs or Stratification Categories\n    in the Population instance.\n    \"\"\"\n\n    bin_ids = {bin_item.id for bin_item in self.population.bins}\n    categories_ids = {\n        cat for strat in self.population.stratifications for cat in strat.categories\n    }\n    bin_and_categories_ids = bin_ids.union(categories_ids)\n\n    for transition in self.dynamics.transitions:\n        source = set(transition.source)\n        target = set(transition.target)\n        transition_ids = source.union(target)\n\n        if not transition_ids.issubset(bin_and_categories_ids):\n            invalid_ids = transition_ids - bin_and_categories_ids\n            raise ValueError(\n                (\n                    f\"Transition '{transition.id}' contains invalid ids: \"\n                    f\"{invalid_ids}. Ids must be defined in Bin ids \"\n                    f\"or Stratification Categories.\"\n                )\n            )\n\n        is_bin_flow = transition_ids.issubset(bin_ids)\n        is_stratification_flow = transition_ids.issubset(categories_ids)\n\n        if (not is_bin_flow) and (not is_stratification_flow):\n            bin_elements = transition_ids.intersection(bin_ids)\n            categories_elements = transition_ids.intersection(categories_ids)\n            raise ValueError(\n                (\n                    f\"Transition '{transition.id}' mixes id types. \"\n                    f\"Found Bin ids ({bin_elements}) and \"\n                    f\"Stratification Categories ids ({categories_elements}). \"\n                    \"Transitions must be purely Bin flow or purely \"\n                    f\"Stratification flow.\"\n                )\n            )\n\n        if is_stratification_flow:\n            category_to_stratification_map = {\n                cat: strat.id\n                for strat in self.population.stratifications\n                for cat in strat.categories\n            }\n            parent_stratification_ids = {\n                category_to_stratification_map[cat_id] for cat_id in transition_ids\n            }\n            if len(parent_stratification_ids) &gt; 1:\n                mixed_strats = \", \".join(parent_stratification_ids)\n                raise ValueError(\n                    (\n                        f\"Transition '{transition.id}' is a Stratification flow \"\n                        f\"but involves categories from multiple stratifications: \"\n                        f\"{mixed_strats}. A single transition must only move \"\n                        f\"between categories belonging to the same parent \"\n                        f\"stratification.\"\n                    )\n                )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.print_equations","title":"print_equations","text":"<pre><code>print_equations(output_file: str | None = None) -&gt; None\n</code></pre> <p>Prints the difference equations of the model in mathematical form.</p> <p>Displays model metadata and the system of difference equations in both compact (mathematical notation) and expanded (individual equations) forms.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>str | None</code> <p>If provided, writes the equations to this file path instead of printing to console. If None, prints to console.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the model is not a DifferenceEquations model.</p> Source code in <code>commol/context/model.py</code> <pre><code>def print_equations(self, output_file: str | None = None) -&gt; None:\n    \"\"\"\n    Prints the difference equations of the model in mathematical form.\n\n    Displays model metadata and the system of difference equations in both\n    compact (mathematical notation) and expanded (individual equations) forms.\n\n    Parameters\n    ----------\n    output_file : str | None\n        If provided, writes the equations to this file path instead of printing\n        to console. If None, prints to console.\n\n    Raises\n    ------\n    ValueError\n        If the model is not a DifferenceEquations model.\n    \"\"\"\n\n    if self.dynamics.typology != ModelTypes.DIFFERENCE_EQUATIONS:\n        raise ValueError(\n            (\n                f\"print_equations only supports DifferenceEquations models. \"\n                f\"Current model type: {self.dynamics.typology}\"\n            )\n        )\n\n    lines = self._generate_model_header()\n\n    # Always generate both compact and expanded forms\n    lines.extend(self._generate_compact_form())\n    lines.append(\"\")\n    lines.extend(self._generate_expanded_form())\n\n    output = \"\\n\".join(lines)\n    self._write_output(output, output_file)\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.model.Model.check_unit_consistency","title":"check_unit_consistency","text":"<pre><code>check_unit_consistency() -&gt; None\n</code></pre> <p>Check unit consistency of all equations in the model.</p> <p>This method validates that all transition rates have consistent units. It only performs the check if ALL parameters have units specified. If any parameter lacks a unit, the check is skipped.</p> <p>For difference equation models, all rates should have units that result in population change rates (e.g., \"person/day\" or \"1/day\" when multiplied by population).</p> <p>Raises:</p> Type Description <code>UnitConsistencyError</code> <p>If unit inconsistencies are found in any equation.</p> <code>ValueError</code> <p>If the model type doesn't support unit checking.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.check_unit_consistency()  # Raises exception if inconsistent\n</code></pre> Notes <ul> <li>Bin variables are assumed to have units of \"person\"</li> <li>Predefined variables (N, N_young, etc.) have units of \"person\"</li> <li>Time step variables (t, step) are dimensionless</li> <li>Mathematical constants (pi, e) are dimensionless</li> </ul> Source code in <code>commol/context/model.py</code> <pre><code>def check_unit_consistency(self) -&gt; None:\n    \"\"\"\n    Check unit consistency of all equations in the model.\n\n    This method validates that all transition rates have consistent units.\n    It only performs the check if ALL parameters have units specified.\n    If any parameter lacks a unit, the check is skipped.\n\n    For difference equation models, all rates should have units that result in\n    population change rates (e.g., \"person/day\" or \"1/day\" when multiplied by\n    population).\n\n    Raises\n    ------\n    UnitConsistencyError\n        If unit inconsistencies are found in any equation.\n    ValueError\n        If the model type doesn't support unit checking.\n\n    Examples\n    --------\n    &gt;&gt;&gt; model.check_unit_consistency()  # Raises exception if inconsistent\n\n    Notes\n    -----\n    - Bin variables are assumed to have units of \"person\"\n    - Predefined variables (N, N_young, etc.) have units of \"person\"\n    - Time step variables (t, step) are dimensionless\n    - Mathematical constants (pi, e) are dimensionless\n    \"\"\"\n    # Check if all parameters have units\n    if not check_all_parameters_have_units(self.parameters):\n        # Skip check if not all parameters have units\n        return\n\n    if self.dynamics.typology != ModelTypes.DIFFERENCE_EQUATIONS:\n        raise ValueError(\n            (\n                f\"Unit checking is only supported for DifferenceEquations models. \"\n                f\"Current model type: {self.dynamics.typology}\"\n            )\n        )\n\n    # Build variable units mapping\n    variable_units = self._build_variable_units()\n\n    # Check each transition\n    errors: list[str] = []\n    for transition in self.dynamics.transitions:\n        # Check main rate\n        if transition.rate:\n            is_consistent, error_msg = self._check_transition_rate_units(\n                transition.rate,\n                transition.id,\n                variable_units,\n            )\n            if not is_consistent and error_msg:\n                errors.append(error_msg)\n\n        # Check stratified rates\n        if transition.stratified_rates:\n            for idx, strat_rate in enumerate(transition.stratified_rates):\n                is_consistent, error_msg = self._check_transition_rate_units(\n                    strat_rate.rate,\n                    f\"{transition.id} (stratified rate {idx + 1})\",\n                    variable_units,\n                )\n                if not is_consistent and error_msg:\n                    errors.append(error_msg)\n\n    if errors:\n        error_message = \"Unit consistency check failed:\\n\" + \"\\n\".join(\n            f\"  - {err}\" for err in errors\n        )\n        raise UnitConsistencyError(error_message)\n</code></pre>"},{"location":"advanced/model-structure/#population","title":"Population","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.population.Population","title":"Population","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the compartments, stratifications, and initial conditions of the population.</p> <p>Attributes:</p> Name Type Description <code>disease_states</code> <code>list[Bin]</code> <p>A list of compartments or states that make up the model.</p> <code>stratifications</code> <code>list[Stratification]</code> <p>A list of categorical subdivisions of the population.</p> <code>initial_conditions</code> <code>Initialization</code> <p>Initial state of the subpopulations and stratifications.</p> Source code in <code>commol/context/population.py</code> <pre><code>class Population(BaseModel):\n    \"\"\"\n    Defines the compartments, stratifications, and initial conditions of the population.\n\n    Attributes\n    ----------\n    disease_states : list[Bin]\n        A list of compartments or states that make up the model.\n    stratifications : list[Stratification]\n        A list of categorical subdivisions of the population.\n    initial_conditions: Initialization\n        Initial state of the subpopulations and stratifications.\n    \"\"\"\n\n    bins: list[Bin]\n    stratifications: list[Stratification]\n    transitions: list[Transition]\n    initial_conditions: InitialConditions\n\n    @field_validator(\"bins\")\n    @classmethod\n    def validate_bins_not_empty(cls, v: list[Bin]) -&gt; list[Bin]:\n        if not v:\n            raise ValueError(\"At least one bin must be defined.\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_unique_ids(self) -&gt; Self:\n        \"\"\"\n        Validates that bin and stratification IDs are unique.\n        \"\"\"\n        bin_ids = [ds.id for ds in self.bins]\n        if len(bin_ids) != len(set(bin_ids)):\n            duplicates = [item for item in set(bin_ids) if bin_ids.count(item) &gt; 1]\n            raise ValueError(f\"Duplicate bin IDs found: {duplicates}\")\n\n        stratification_ids = [s.id for s in self.stratifications]\n        if len(stratification_ids) != len(set(stratification_ids)):\n            duplicates = [\n                item\n                for item in set(stratification_ids)\n                if stratification_ids.count(item) &gt; 1\n            ]\n            raise ValueError(f\"Duplicate stratification IDs found: {duplicates}\")\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_bin_initial_conditions(self) -&gt; Self:\n        \"\"\"\n        Validates initial conditions against the defined model bins.\n        \"\"\"\n        initial_conditions = self.initial_conditions\n\n        bins_map = {bin_item.id: bin_item for bin_item in self.bins}\n\n        bin_fractions_dict = {\n            bf.bin: bf.fraction for bf in initial_conditions.bin_fractions\n        }\n\n        actual_bins = set(bin_fractions_dict.keys())\n        expected_bins = set(bins_map.keys())\n\n        if actual_bins != expected_bins:\n            missing = expected_bins - actual_bins\n            extra = actual_bins - expected_bins\n            raise ValueError(\n                (\n                    f\"Initial bin fractions keys must exactly match \"\n                    f\"bin ids. Missing ids: {missing}, Extra ids: {extra}.\"\n                )\n            )\n\n        bins_sum_fractions = sum(bin_fractions_dict.values())\n        if not math.isclose(bins_sum_fractions, 1.0, abs_tol=1e-6):\n            raise ValueError(\n                (f\"Bin fractions must sum to 1.0, but got {bins_sum_fractions:.7f}.\")\n            )\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_stratified_rates(self) -&gt; Self:\n        \"\"\"\n        Validates that stratified rates reference existing stratifications and\n        categories.\n        \"\"\"\n        strat_map = {strat.id: strat for strat in self.stratifications}\n\n        for transition in self.transitions:\n            if transition.stratified_rates:\n                for idx, stratified_rate in enumerate(transition.stratified_rates):\n                    for condition in stratified_rate.conditions:\n                        # Validate stratification exists\n                        if condition.stratification not in strat_map:\n                            raise ValueError(\n                                (\n                                    f\"In transition '{transition.id}', stratified rate \"\n                                    f\"{idx}: Stratification \"\n                                    f\"'{condition.stratification}' not found. \"\n                                    f\"Available: {list(strat_map.keys())}\"\n                                )\n                            )\n\n                        # Validate category exists\n                        strat = strat_map[condition.stratification]\n                        if condition.category not in strat.categories:\n                            raise ValueError(\n                                (\n                                    f\"In transition '{transition.id}', stratified rate \"\n                                    f\"{idx}: Category '{condition.category}' not found \"\n                                    f\"in stratification '{condition.stratification}'. \"\n                                    f\"Available: {strat.categories}\"\n                                )\n                            )\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_stratification_initial_conditions(self) -&gt; Self:\n        \"\"\"\n        Validates initial conditions against the defined model Stratification.\n        \"\"\"\n        initial_conditions = self.initial_conditions\n\n        strat_map = {strat.id: strat for strat in self.stratifications}\n\n        actual_strat = {\n            sf.stratification for sf in initial_conditions.stratification_fractions\n        }\n        expected_strat = set(strat_map.keys())\n\n        if actual_strat != expected_strat:\n            missing = expected_strat - actual_strat\n            extra = actual_strat - expected_strat\n            raise ValueError(\n                (\n                    f\"Initial stratification fractions keys must exactly match \"\n                    f\"stratification ids. Missing ids: {missing}, Extra ids: {extra}.\"\n                )\n            )\n\n        for strat_fractions in initial_conditions.stratification_fractions:\n            strat_id = strat_fractions.stratification\n            strat_instance = strat_map[strat_id]\n\n            fractions_dict = {\n                sf.category: sf.fraction for sf in strat_fractions.fractions\n            }\n\n            categories_expected = set(strat_instance.categories)\n            categories_actual = set(fractions_dict.keys())\n\n            if categories_actual != categories_expected:\n                missing = categories_expected - categories_actual\n                extra = categories_actual - categories_expected\n                raise ValueError(\n                    (\n                        f\"Categories for stratification '{strat_id}' must exactly \"\n                        f\"match defined categories in instance '{strat_instance.id}'. \"\n                        f\"Missing categories: {missing}, Extra categories: {extra}.\"\n                    )\n                )\n\n            strat_sum_fractions = sum(fractions_dict.values())\n            if not math.isclose(strat_sum_fractions, 1.0, abs_tol=1e-6):\n                raise ValueError(\n                    (\n                        f\"Stratification fractions for '{strat_id}' must sum to 1.0, \"\n                        f\"but got {strat_sum_fractions:.7}.\"\n                    )\n                )\n\n        return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.population.Population-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.population.Population.validate_unique_ids","title":"validate_unique_ids","text":"<pre><code>validate_unique_ids() -&gt; Self\n</code></pre> <p>Validates that bin and stratification IDs are unique.</p> Source code in <code>commol/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_unique_ids(self) -&gt; Self:\n    \"\"\"\n    Validates that bin and stratification IDs are unique.\n    \"\"\"\n    bin_ids = [ds.id for ds in self.bins]\n    if len(bin_ids) != len(set(bin_ids)):\n        duplicates = [item for item in set(bin_ids) if bin_ids.count(item) &gt; 1]\n        raise ValueError(f\"Duplicate bin IDs found: {duplicates}\")\n\n    stratification_ids = [s.id for s in self.stratifications]\n    if len(stratification_ids) != len(set(stratification_ids)):\n        duplicates = [\n            item\n            for item in set(stratification_ids)\n            if stratification_ids.count(item) &gt; 1\n        ]\n        raise ValueError(f\"Duplicate stratification IDs found: {duplicates}\")\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.population.Population.validate_bin_initial_conditions","title":"validate_bin_initial_conditions","text":"<pre><code>validate_bin_initial_conditions() -&gt; Self\n</code></pre> <p>Validates initial conditions against the defined model bins.</p> Source code in <code>commol/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_bin_initial_conditions(self) -&gt; Self:\n    \"\"\"\n    Validates initial conditions against the defined model bins.\n    \"\"\"\n    initial_conditions = self.initial_conditions\n\n    bins_map = {bin_item.id: bin_item for bin_item in self.bins}\n\n    bin_fractions_dict = {\n        bf.bin: bf.fraction for bf in initial_conditions.bin_fractions\n    }\n\n    actual_bins = set(bin_fractions_dict.keys())\n    expected_bins = set(bins_map.keys())\n\n    if actual_bins != expected_bins:\n        missing = expected_bins - actual_bins\n        extra = actual_bins - expected_bins\n        raise ValueError(\n            (\n                f\"Initial bin fractions keys must exactly match \"\n                f\"bin ids. Missing ids: {missing}, Extra ids: {extra}.\"\n            )\n        )\n\n    bins_sum_fractions = sum(bin_fractions_dict.values())\n    if not math.isclose(bins_sum_fractions, 1.0, abs_tol=1e-6):\n        raise ValueError(\n            (f\"Bin fractions must sum to 1.0, but got {bins_sum_fractions:.7f}.\")\n        )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.population.Population.validate_stratified_rates","title":"validate_stratified_rates","text":"<pre><code>validate_stratified_rates() -&gt; Self\n</code></pre> <p>Validates that stratified rates reference existing stratifications and categories.</p> Source code in <code>commol/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_stratified_rates(self) -&gt; Self:\n    \"\"\"\n    Validates that stratified rates reference existing stratifications and\n    categories.\n    \"\"\"\n    strat_map = {strat.id: strat for strat in self.stratifications}\n\n    for transition in self.transitions:\n        if transition.stratified_rates:\n            for idx, stratified_rate in enumerate(transition.stratified_rates):\n                for condition in stratified_rate.conditions:\n                    # Validate stratification exists\n                    if condition.stratification not in strat_map:\n                        raise ValueError(\n                            (\n                                f\"In transition '{transition.id}', stratified rate \"\n                                f\"{idx}: Stratification \"\n                                f\"'{condition.stratification}' not found. \"\n                                f\"Available: {list(strat_map.keys())}\"\n                            )\n                        )\n\n                    # Validate category exists\n                    strat = strat_map[condition.stratification]\n                    if condition.category not in strat.categories:\n                        raise ValueError(\n                            (\n                                f\"In transition '{transition.id}', stratified rate \"\n                                f\"{idx}: Category '{condition.category}' not found \"\n                                f\"in stratification '{condition.stratification}'. \"\n                                f\"Available: {strat.categories}\"\n                            )\n                        )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.population.Population.validate_stratification_initial_conditions","title":"validate_stratification_initial_conditions","text":"<pre><code>validate_stratification_initial_conditions() -&gt; Self\n</code></pre> <p>Validates initial conditions against the defined model Stratification.</p> Source code in <code>commol/context/population.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_stratification_initial_conditions(self) -&gt; Self:\n    \"\"\"\n    Validates initial conditions against the defined model Stratification.\n    \"\"\"\n    initial_conditions = self.initial_conditions\n\n    strat_map = {strat.id: strat for strat in self.stratifications}\n\n    actual_strat = {\n        sf.stratification for sf in initial_conditions.stratification_fractions\n    }\n    expected_strat = set(strat_map.keys())\n\n    if actual_strat != expected_strat:\n        missing = expected_strat - actual_strat\n        extra = actual_strat - expected_strat\n        raise ValueError(\n            (\n                f\"Initial stratification fractions keys must exactly match \"\n                f\"stratification ids. Missing ids: {missing}, Extra ids: {extra}.\"\n            )\n        )\n\n    for strat_fractions in initial_conditions.stratification_fractions:\n        strat_id = strat_fractions.stratification\n        strat_instance = strat_map[strat_id]\n\n        fractions_dict = {\n            sf.category: sf.fraction for sf in strat_fractions.fractions\n        }\n\n        categories_expected = set(strat_instance.categories)\n        categories_actual = set(fractions_dict.keys())\n\n        if categories_actual != categories_expected:\n            missing = categories_expected - categories_actual\n            extra = categories_actual - categories_expected\n            raise ValueError(\n                (\n                    f\"Categories for stratification '{strat_id}' must exactly \"\n                    f\"match defined categories in instance '{strat_instance.id}'. \"\n                    f\"Missing categories: {missing}, Extra categories: {extra}.\"\n                )\n            )\n\n        strat_sum_fractions = sum(fractions_dict.values())\n        if not math.isclose(strat_sum_fractions, 1.0, abs_tol=1e-6):\n            raise ValueError(\n                (\n                    f\"Stratification fractions for '{strat_id}' must sum to 1.0, \"\n                    f\"but got {strat_sum_fractions:.7}.\"\n                )\n            )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#bins","title":"Bins","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.bin.Bin","title":"Bin","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a single bin (base category) in the compartmental model.</p> <p>A bin represents a fundamental category before stratification. The combination of a bin with all stratifications produces the actual compartments.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Identifier of the bin.</p> <code>name</code> <code>str</code> <p>A descriptive, human-readable name for the bin.</p> Source code in <code>commol/context/bin.py</code> <pre><code>class Bin(BaseModel):\n    \"\"\"\n    Defines a single bin (base category) in the compartmental model.\n\n    A bin represents a fundamental category before stratification. The combination\n    of a bin with all stratifications produces the actual compartments.\n\n    Attributes\n    ----------\n    id : str\n        Identifier of the bin.\n    name : str\n        A descriptive, human-readable name for the bin.\n    \"\"\"\n\n    id: str = Field(..., description=\"Identifier of the bin.\")\n    name: str = Field(..., description=\"Descriptive, human-readable name for the bin.\")\n\n    @override\n    def __hash__(self) -&gt; int:\n        return hash(self.id)\n\n    @override\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Bin) and self.id == other.id\n</code></pre>"},{"location":"advanced/model-structure/#stratifications","title":"Stratifications","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.stratification.Stratification","title":"Stratification","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a categorical subdivision of the population.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Identifier of the stratification.</p> <code>categories</code> <code>list[str]</code> <p>List of the different stratification groups identifiers.</p> Source code in <code>commol/context/stratification.py</code> <pre><code>class Stratification(BaseModel):\n    \"\"\"\n    Defines a categorical subdivision of the population.\n\n    Attributes\n    ----------\n    id : str\n        Identifier of the stratification.\n    categories : list[str]\n        List of the different stratification groups identifiers.\n    \"\"\"\n\n    id: str = Field(default=..., description=\"Identifier of the stratification.\")\n    categories: list[str] = Field(\n        default=...,\n        description=\"List of the different stratification groups identifiers.\",\n    )\n\n    @override\n    def __hash__(self) -&gt; int:\n        return hash(self.id)\n\n    @override\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Stratification) and self.id == other.id\n\n    @model_validator(mode=\"after\")\n    def validate_categories_length(self) -&gt; Self:\n        \"\"\"\n        Enforces that categories are not empty.\n        \"\"\"\n        if not self.categories:\n            raise ValueError(\n                (f\"Stratification '{self.id}' must have at least one category.\")\n            )\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_categories_uniqueness(self) -&gt; Self:\n        \"\"\"\n        Enforces that categories are not repeated.\n        \"\"\"\n        categories_set = set(self.categories)\n\n        if len(categories_set) != len(self.categories):\n            duplicates = [\n                item for item in categories_set if self.categories.count(item) &gt; 1\n            ]\n            raise ValueError(\n                (\n                    f\"Categories for stratification '{self.id}' must not be repeated. \"\n                    f\"Found duplicates: {list(set(duplicates))}.\"\n                )\n            )\n\n        return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.stratification.Stratification-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.stratification.Stratification.validate_categories_length","title":"validate_categories_length","text":"<pre><code>validate_categories_length() -&gt; Self\n</code></pre> <p>Enforces that categories are not empty.</p> Source code in <code>commol/context/stratification.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_categories_length(self) -&gt; Self:\n    \"\"\"\n    Enforces that categories are not empty.\n    \"\"\"\n    if not self.categories:\n        raise ValueError(\n            (f\"Stratification '{self.id}' must have at least one category.\")\n        )\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.stratification.Stratification.validate_categories_uniqueness","title":"validate_categories_uniqueness","text":"<pre><code>validate_categories_uniqueness() -&gt; Self\n</code></pre> <p>Enforces that categories are not repeated.</p> Source code in <code>commol/context/stratification.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_categories_uniqueness(self) -&gt; Self:\n    \"\"\"\n    Enforces that categories are not repeated.\n    \"\"\"\n    categories_set = set(self.categories)\n\n    if len(categories_set) != len(self.categories):\n        duplicates = [\n            item for item in categories_set if self.categories.count(item) &gt; 1\n        ]\n        raise ValueError(\n            (\n                f\"Categories for stratification '{self.id}' must not be repeated. \"\n                f\"Found duplicates: {list(set(duplicates))}.\"\n            )\n        )\n\n    return self\n</code></pre>"},{"location":"advanced/model-structure/#parameters","title":"Parameters","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.parameter.Parameter","title":"Parameter","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a global model parameter.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The identifier of the parameter.</p> <code>value</code> <code>float</code> <p>Numerical value of the parameter.</p> <code>description</code> <code>str | None</code> <p>A human-readable description of the parameter.</p> <code>unit</code> <code>str | None</code> <p>The unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\"). If None, the parameter has no unit specified.</p> Source code in <code>commol/context/parameter.py</code> <pre><code>class Parameter(BaseModel):\n    \"\"\"\n    Defines a global model parameter.\n\n    Attributes\n    ----------\n    id : str\n        The identifier of the parameter.\n    value : float\n        Numerical value of the parameter.\n    description : str | None\n        A human-readable description of the parameter.\n    unit : str | None\n        The unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\").\n        If None, the parameter has no unit specified.\n    \"\"\"\n\n    id: str = Field(..., description=\"Identifier of the parameter.\")\n    value: float = Field(..., description=\"Numerical value of the parameter.\")\n    description: str | None = Field(\n        default=None, description=\"Human-readable description of the parameter.\"\n    )\n    unit: str | None = Field(\n        default=None,\n        description=\"Unit of the parameter (e.g., '1/day', 'dimensionless', 'person').\",\n    )\n</code></pre>"},{"location":"advanced/model-structure/#transitions","title":"Transitions","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.dynamics.Transition","title":"Transition","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a rule for system evolution.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Id of the transition.</p> <code>source</code> <code>list[str]</code> <p>The origin compartments.</p> <code>target</code> <code>list[str]</code> <p>The destination compartments.</p> <code>rate</code> <code>str | None</code> <p>Default mathematical formula, parameter name, or constant value for the flow. Used when no stratified rate matches. Numeric values are automatically converted to strings during validation.</p> <p>Operators: +, -, *, /, % (modulo), ^ or ** (power) Functions: sin, cos, tan, exp, ln, sqrt, abs, min, max, if, etc. Constants: pi, e</p> <p>Note: Both ^ and ** are supported for exponentiation (** is converted to ^).</p> <p>Examples: - \"beta\" (parameter reference) - \"0.5\" (constant, can also be passed as float 0.5) - \"beta * S * I / N\" (mathematical formula) - \"0.3 * sin(2 * pi * t / 365)\" (time-dependent formula) - \"2^10\" or \"2**10\" (power: both syntaxes work)</p> <code>stratified_rates</code> <code>list[StratifiedRate] | None</code> <p>Stratification-specific rates. Each rate applies to compartments that match all specified stratification conditions.</p> <code>condition</code> <code>Condition | None</code> <p>Logical restrictions for the transition.</p> Source code in <code>commol/context/dynamics.py</code> <pre><code>class Transition(BaseModel):\n    \"\"\"\n    Defines a rule for system evolution.\n\n    Attributes\n    ----------\n    id : str\n        Id of the transition.\n    source : list[str]\n        The origin compartments.\n    target : list[str]\n        The destination compartments.\n    rate : str | None\n        Default mathematical formula, parameter name, or constant value for the flow.\n        Used when no stratified rate matches. Numeric values are automatically\n        converted to strings during validation.\n\n        Operators: +, -, *, /, % (modulo), ^ or ** (power)\n        Functions: sin, cos, tan, exp, ln, sqrt, abs, min, max, if, etc.\n        Constants: pi, e\n\n        Note: Both ^ and ** are supported for exponentiation (** is converted to ^).\n\n        Examples:\n        - \"beta\" (parameter reference)\n        - \"0.5\" (constant, can also be passed as float 0.5)\n        - \"beta * S * I / N\" (mathematical formula)\n        - \"0.3 * sin(2 * pi * t / 365)\" (time-dependent formula)\n        - \"2^10\" or \"2**10\" (power: both syntaxes work)\n    stratified_rates : list[StratifiedRate] | None\n        Stratification-specific rates. Each rate applies to compartments that match\n        all specified stratification conditions.\n    condition : Condition | None\n        Logical restrictions for the transition.\n    \"\"\"\n\n    id: str = Field(default=..., description=\"Id of the transition.\")\n    source: list[str] = Field(default=..., description=\"Origin compartments.\")\n    target: list[str] = Field(default=..., description=\"Destination compartments.\")\n\n    rate: str | None = Field(\n        None,\n        description=(\n            \"Default rate expression (fallback when no stratified rate matches). \"\n            \"Can be a parameter reference (e.g., 'beta'), a constant (e.g., '0.5'), \"\n            \"or a mathematical expression (e.g., 'beta * S * I / N'). \"\n            \"Numeric values are automatically converted to strings during validation.\"\n        ),\n    )\n\n    stratified_rates: list[StratifiedRate] | None = Field(\n        default=None, description=\"List of stratification-specific rates\"\n    )\n\n    condition: Condition | None = Field(\n        default=None, description=\"Logical restrictions for the transition.\"\n    )\n\n    @field_validator(\"rate\", mode=\"before\")\n    @classmethod\n    def validate_rate(cls, value: str | None) -&gt; str | None:\n        \"\"\"\n        Convert numeric rates to strings and perform security and syntax validation.\n        \"\"\"\n        if value is None:\n            return value\n        try:\n            validate_expression_security(value)\n            commol_rs.core.MathExpression(value).validate()\n        except ValueError as e:\n            raise ValueError(f\"Validation failed for rate '{value}': {e}\")\n        return value\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.dynamics.Transition-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.dynamics.Transition.validate_rate","title":"validate_rate  <code>classmethod</code>","text":"<pre><code>validate_rate(value: str | None) -&gt; str | None\n</code></pre> <p>Convert numeric rates to strings and perform security and syntax validation.</p> Source code in <code>commol/context/dynamics.py</code> <pre><code>@field_validator(\"rate\", mode=\"before\")\n@classmethod\ndef validate_rate(cls, value: str | None) -&gt; str | None:\n    \"\"\"\n    Convert numeric rates to strings and perform security and syntax validation.\n    \"\"\"\n    if value is None:\n        return value\n    try:\n        validate_expression_security(value)\n        commol_rs.core.MathExpression(value).validate()\n    except ValueError as e:\n        raise ValueError(f\"Validation failed for rate '{value}': {e}\")\n    return value\n</code></pre>"},{"location":"advanced/model-structure/#initial-conditions","title":"Initial Conditions","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.initial_conditions.InitialConditions","title":"InitialConditions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Initial conditions for a simulation.</p> <p>Attributes:</p> Name Type Description <code>population_size</code> <code>int</code> <p>Population size.</p> <code>bin_fractions</code> <code>list[BinFraction]</code> <p>List of bin fractions. Each item contains a bin id and its initial fractional size.</p> <code>stratification_fractions</code> <code>(list[StratificationFractions], optional)</code> <p>List of stratification fractions. Each item contains a stratification id and its category fractions.</p> Source code in <code>commol/context/initial_conditions.py</code> <pre><code>class InitialConditions(BaseModel):\n    \"\"\"\n    Initial conditions for a simulation.\n\n    Attributes\n    ----------\n    population_size : int\n        Population size.\n    bin_fractions : list[BinFraction]\n        List of bin fractions. Each item contains a bin id and\n        its initial fractional size.\n    stratification_fractions : list[StratificationFractions], optional\n        List of stratification fractions. Each item contains a stratification id and\n        its category fractions.\n    \"\"\"\n\n    population_size: int = Field(..., description=\"Population size.\")\n    bin_fractions: list[BinFraction] = Field(\n        default=...,\n        description=(\n            \"List of bin fractions. Each item contains a bin id \"\n            \"and its initial fractional size.\"\n        ),\n    )\n    stratification_fractions: list[StratificationFractions] = Field(\n        default_factory=list,\n        description=(\n            \"List of stratification fractions. Each item contains a stratification id \"\n            \"and its category fractions.\"\n        ),\n    )\n</code></pre>"},{"location":"advanced/model-structure/#dynamics","title":"Dynamics","text":"<p>options: show_root_heading: true show_source: true heading_level: 3</p>"},{"location":"advanced/model-structure/#commol.context.dynamics.Dynamics","title":"Dynamics","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines how the system evolves.</p> <p>Attributes:</p> Name Type Description <code>typology</code> <code>Literal['DifferenceEquations']</code> <p>The type of model.</p> <code>transitions</code> <code>List[Transition]</code> <p>A list of rules for state changes.</p> Source code in <code>commol/context/dynamics.py</code> <pre><code>class Dynamics(BaseModel):\n    \"\"\"\n    Defines how the system evolves.\n\n    Attributes\n    ----------\n    typology : Literal[\"DifferenceEquations\"]\n        The type of model.\n    transitions : List[Transition]\n        A list of rules for state changes.\n    \"\"\"\n\n    typology: Literal[ModelTypes.DIFFERENCE_EQUATIONS]\n    transitions: list[Transition]\n\n    @field_validator(\"transitions\")\n    @classmethod\n    def validate_transitions_not_empty(cls, v: list[Transition]) -&gt; list[Transition]:\n        if not v:\n            raise ValueError(\"At least one transition must be defined.\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_unique_transition_ids(self) -&gt; Self:\n        \"\"\"\n        Validates that transition IDs are unique.\n        \"\"\"\n        transition_ids = [t.id for t in self.transitions]\n        if len(transition_ids) != len(set(transition_ids)):\n            duplicates = [\n                item for item in set(transition_ids) if transition_ids.count(item) &gt; 1\n            ]\n            raise ValueError(f\"Duplicate transition IDs found: {duplicates}\")\n        return self\n</code></pre>"},{"location":"advanced/model-structure/#commol.context.dynamics.Dynamics-functions","title":"Functions","text":""},{"location":"advanced/model-structure/#commol.context.dynamics.Dynamics.validate_unique_transition_ids","title":"validate_unique_transition_ids","text":"<pre><code>validate_unique_transition_ids() -&gt; Self\n</code></pre> <p>Validates that transition IDs are unique.</p> Source code in <code>commol/context/dynamics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_unique_transition_ids(self) -&gt; Self:\n    \"\"\"\n    Validates that transition IDs are unique.\n    \"\"\"\n    transition_ids = [t.id for t in self.transitions]\n    if len(transition_ids) != len(set(transition_ids)):\n        duplicates = [\n            item for item in set(transition_ids) if transition_ids.count(item) &gt; 1\n        ]\n        raise ValueError(f\"Duplicate transition IDs found: {duplicates}\")\n    return self\n</code></pre>"},{"location":"api/calibrator/","title":"Calibrator API","text":""},{"location":"api/calibrator/#commol.api.calibrator.Calibrator","title":"Calibrator","text":"<p>A Facade for running parameter calibration from a defined CalibrationProblem.</p> Source code in <code>commol/api/calibrator.py</code> <pre><code>class Calibrator:\n    \"\"\"\n    A Facade for running parameter calibration from a defined CalibrationProblem.\n    \"\"\"\n\n    def __init__(\n        self,\n        simulation: Simulation,\n        problem: CalibrationProblem,\n    ):\n        \"\"\"\n        Initializes the calibration from a Simulation and CalibrationProblem.\n\n        Parameters\n        ----------\n        simulation : Simulation\n            A fully initialized Simulation object with the model to calibrate.\n        problem : CalibrationProblem\n            A fully constructed and validated calibration problem definition.\n        \"\"\"\n        logger.info(\n            f\"Initializing Calibration for model: '{simulation.model_definition.name}'\"\n        )\n        self.simulation: Simulation = simulation\n        self.problem: CalibrationProblem = problem\n        self._engine: \"DifferenceEquationsProtocol\" = simulation.engine\n\n        logger.info(\n            (\n                f\"Calibration initialized with {len(problem.parameters)} parameters \"\n                f\"and {len(problem.observed_data)} observed data points.\"\n            )\n        )\n\n    def run(self) -&gt; CalibrationResult:\n        \"\"\"\n        Runs the calibration optimization.\n\n        Returns\n        -------\n        CalibrationResult\n            Object containing the optimized parameter values, final loss,\n            convergence status, and other optimization statistics.\n\n        Raises\n        ------\n        ImportError\n            If Rust extension is not available.\n        ValueError\n            If calibration problem setup is invalid.\n        RuntimeError\n            If optimization fails.\n        \"\"\"\n        logger.info(\n            (\n                f\"Starting calibration with \"\n                f\"{self.problem.optimization_config.algorithm.value} algorithm and \"\n                f\"{self.problem.loss_config.function.value} loss function.\"\n            )\n        )\n\n        # Convert observed data to Rust types\n        rust_observed_data = [\n            rust_calibration.ObservedDataPoint(\n                step=point.step,\n                compartment=point.compartment,\n                value=point.value,\n                weight=point.weight,\n            )\n            for point in self.problem.observed_data\n        ]\n\n        # Convert parameters to Rust types\n        rust_parameters = [\n            rust_calibration.CalibrationParameter(\n                id=param.id,\n                min_bound=param.min_bound,\n                max_bound=param.max_bound,\n                initial_guess=param.initial_guess,\n            )\n            for param in self.problem.parameters\n        ]\n\n        # Convert loss config to Rust type\n        rust_loss_config = self._build_loss_config()\n\n        # Convert optimization config to Rust type\n        rust_optimization_config = self._build_optimization_config()\n\n        logger.info(\"Converted problem definition to Rust types.\")\n        logger.info(\"Running optimization...\")\n\n        # Call the Rust calibrate function\n        rust_result = rust_calibration.calibrate(\n            self._engine,\n            rust_observed_data,\n            rust_parameters,\n            rust_loss_config,\n            rust_optimization_config,\n        )\n\n        # Convert result back to Python CalibrationResult\n        result = CalibrationResult(\n            best_parameters=rust_result.best_parameters,\n            parameter_names=rust_result.parameter_names,\n            best_parameters_list=rust_result.best_parameters_list,\n            final_loss=rust_result.final_loss,\n            iterations=rust_result.iterations,\n            converged=rust_result.converged,\n            termination_reason=rust_result.termination_reason,\n        )\n\n        logger.info(\n            (\n                f\"Calibration finished after {result.iterations} iterations. \"\n                f\"Final loss: {result.final_loss:.6f}\"\n            )\n        )\n\n        return result\n\n    def _build_loss_config(self) -&gt; \"LossConfigProtocol\":\n        \"\"\"Convert Python LossConfig to Rust LossConfig.\"\"\"\n        loss_func = self.problem.loss_config.function\n\n        if loss_func == LossFunction.SSE:\n            return rust_calibration.LossConfig.sum_squared_error()\n        elif loss_func == LossFunction.RMSE:\n            return rust_calibration.LossConfig.root_mean_squared_error()\n        elif loss_func == LossFunction.MAE:\n            return rust_calibration.LossConfig.mean_absolute_error()\n        elif loss_func == LossFunction.WEIGHTED_SSE:\n            return rust_calibration.LossConfig.weighted_sse()\n        else:\n            raise ValueError(f\"Unsupported loss function: {loss_func}.\")\n\n    def _build_optimization_config(self) -&gt; \"OptimizationConfigProtocol\":\n        \"\"\"Convert Python OptimizationConfig to Rust OptimizationConfig.\"\"\"\n        opt_config = self.problem.optimization_config\n\n        if opt_config.algorithm == OptimizationAlgorithm.NELDER_MEAD:\n            if not isinstance(opt_config.config, NelderMeadConfig):\n                raise ValueError(\n                    (\n                        f\"Expected NelderMeadConfig for Nelder-Mead algorithm, \"\n                        f\"got {type(opt_config.config).__name__}\"\n                    )\n                )\n\n            nm_config = rust_calibration.NelderMeadConfig(\n                max_iterations=opt_config.config.max_iterations,\n                sd_tolerance=opt_config.config.sd_tolerance,\n                alpha=opt_config.config.alpha,\n                gamma=opt_config.config.gamma,\n                rho=opt_config.config.rho,\n                sigma=opt_config.config.sigma,\n                verbose=opt_config.config.verbose,\n                header_interval=opt_config.config.header_interval,\n            )\n            return rust_calibration.OptimizationConfig.nelder_mead(nm_config)\n\n        elif opt_config.algorithm == OptimizationAlgorithm.PARTICLE_SWARM:\n            if not isinstance(opt_config.config, ParticleSwarmConfig):\n                raise ValueError(\n                    (\n                        f\"Expected ParticleSwarmConfig for Particle Swarm algorithm, \"\n                        f\"got {type(opt_config.config).__name__}\"\n                    )\n                )\n\n            ps_config = rust_calibration.ParticleSwarmConfig(\n                num_particles=opt_config.config.num_particles,\n                max_iterations=opt_config.config.max_iterations,\n                target_cost=opt_config.config.target_cost,\n                inertia_factor=opt_config.config.inertia_factor,\n                cognitive_factor=opt_config.config.cognitive_factor,\n                social_factor=opt_config.config.social_factor,\n                verbose=opt_config.config.verbose,\n                header_interval=opt_config.config.header_interval,\n            )\n            return rust_calibration.OptimizationConfig.particle_swarm(ps_config)\n\n        else:\n            raise ValueError(\n                f\"Unsupported optimization algorithm: {opt_config.algorithm}\"\n            )\n\n    @property\n    def num_parameters(self) -&gt; int:\n        \"\"\"Number of parameters being calibrated.\"\"\"\n        return len(self.problem.parameters)\n\n    @property\n    def num_observations(self) -&gt; int:\n        \"\"\"Number of observed data points.\"\"\"\n        return len(self.problem.observed_data)\n\n    @property\n    def parameter_names(self) -&gt; list[str]:\n        \"\"\"Names of parameters being calibrated.\"\"\"\n        return [param.id for param in self.problem.parameters]\n</code></pre>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator-attributes","title":"Attributes","text":""},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.num_parameters","title":"num_parameters  <code>property</code>","text":"<pre><code>num_parameters: int\n</code></pre> <p>Number of parameters being calibrated.</p>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.num_observations","title":"num_observations  <code>property</code>","text":"<pre><code>num_observations: int\n</code></pre> <p>Number of observed data points.</p>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.parameter_names","title":"parameter_names  <code>property</code>","text":"<pre><code>parameter_names: list[str]\n</code></pre> <p>Names of parameters being calibrated.</p>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.__init__","title":"__init__","text":"<pre><code>__init__(simulation: Simulation, problem: CalibrationProblem)\n</code></pre> <p>Initializes the calibration from a Simulation and CalibrationProblem.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A fully initialized Simulation object with the model to calibrate.</p> required <code>problem</code> <code>CalibrationProblem</code> <p>A fully constructed and validated calibration problem definition.</p> required Source code in <code>commol/api/calibrator.py</code> <pre><code>def __init__(\n    self,\n    simulation: Simulation,\n    problem: CalibrationProblem,\n):\n    \"\"\"\n    Initializes the calibration from a Simulation and CalibrationProblem.\n\n    Parameters\n    ----------\n    simulation : Simulation\n        A fully initialized Simulation object with the model to calibrate.\n    problem : CalibrationProblem\n        A fully constructed and validated calibration problem definition.\n    \"\"\"\n    logger.info(\n        f\"Initializing Calibration for model: '{simulation.model_definition.name}'\"\n    )\n    self.simulation: Simulation = simulation\n    self.problem: CalibrationProblem = problem\n    self._engine: \"DifferenceEquationsProtocol\" = simulation.engine\n\n    logger.info(\n        (\n            f\"Calibration initialized with {len(problem.parameters)} parameters \"\n            f\"and {len(problem.observed_data)} observed data points.\"\n        )\n    )\n</code></pre>"},{"location":"api/calibrator/#commol.api.calibrator.Calibrator.run","title":"run","text":"<pre><code>run() -&gt; CalibrationResult\n</code></pre> <p>Runs the calibration optimization.</p> <p>Returns:</p> Type Description <code>CalibrationResult</code> <p>Object containing the optimized parameter values, final loss, convergence status, and other optimization statistics.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Rust extension is not available.</p> <code>ValueError</code> <p>If calibration problem setup is invalid.</p> <code>RuntimeError</code> <p>If optimization fails.</p> Source code in <code>commol/api/calibrator.py</code> <pre><code>def run(self) -&gt; CalibrationResult:\n    \"\"\"\n    Runs the calibration optimization.\n\n    Returns\n    -------\n    CalibrationResult\n        Object containing the optimized parameter values, final loss,\n        convergence status, and other optimization statistics.\n\n    Raises\n    ------\n    ImportError\n        If Rust extension is not available.\n    ValueError\n        If calibration problem setup is invalid.\n    RuntimeError\n        If optimization fails.\n    \"\"\"\n    logger.info(\n        (\n            f\"Starting calibration with \"\n            f\"{self.problem.optimization_config.algorithm.value} algorithm and \"\n            f\"{self.problem.loss_config.function.value} loss function.\"\n        )\n    )\n\n    # Convert observed data to Rust types\n    rust_observed_data = [\n        rust_calibration.ObservedDataPoint(\n            step=point.step,\n            compartment=point.compartment,\n            value=point.value,\n            weight=point.weight,\n        )\n        for point in self.problem.observed_data\n    ]\n\n    # Convert parameters to Rust types\n    rust_parameters = [\n        rust_calibration.CalibrationParameter(\n            id=param.id,\n            min_bound=param.min_bound,\n            max_bound=param.max_bound,\n            initial_guess=param.initial_guess,\n        )\n        for param in self.problem.parameters\n    ]\n\n    # Convert loss config to Rust type\n    rust_loss_config = self._build_loss_config()\n\n    # Convert optimization config to Rust type\n    rust_optimization_config = self._build_optimization_config()\n\n    logger.info(\"Converted problem definition to Rust types.\")\n    logger.info(\"Running optimization...\")\n\n    # Call the Rust calibrate function\n    rust_result = rust_calibration.calibrate(\n        self._engine,\n        rust_observed_data,\n        rust_parameters,\n        rust_loss_config,\n        rust_optimization_config,\n    )\n\n    # Convert result back to Python CalibrationResult\n    result = CalibrationResult(\n        best_parameters=rust_result.best_parameters,\n        parameter_names=rust_result.parameter_names,\n        best_parameters_list=rust_result.best_parameters_list,\n        final_loss=rust_result.final_loss,\n        iterations=rust_result.iterations,\n        converged=rust_result.converged,\n        termination_reason=rust_result.termination_reason,\n    )\n\n    logger.info(\n        (\n            f\"Calibration finished after {result.iterations} iterations. \"\n            f\"Final loss: {result.final_loss:.6f}\"\n        )\n    )\n\n    return result\n</code></pre>"},{"location":"api/calibrator/#related-classes","title":"Related Classes","text":""},{"location":"api/calibrator/#calibrationproblem","title":"CalibrationProblem","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationProblem","title":"CalibrationProblem","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a complete calibration problem.</p> <p>This class encapsulates all the information needed to calibrate model parameters against observed data. It provides validation of the calibration setup but delegates the actual optimization to the Rust backend.</p> <p>Attributes:</p> Name Type Description <code>observed_data</code> <code>list[ObservedDataPoint]</code> <p>List of observed data points to fit against</p> <code>parameters</code> <code>list[CalibrationParameter]</code> <p>List of parameters to calibrate with their bounds</p> <code>loss_config</code> <code>LossConfig</code> <p>Configuration for the loss function</p> <code>optimization_config</code> <code>OptimizationConfig</code> <p>Configuration for the optimization algorithm</p>"},{"location":"api/calibrator/#commol.context.calibration.CalibrationProblem-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationProblem.validate_unique_parameter_ids","title":"validate_unique_parameter_ids","text":"<pre><code>validate_unique_parameter_ids() -&gt; Self\n</code></pre> <p>Ensure parameter IDs are unique.</p>"},{"location":"api/calibrator/#calibrationresult","title":"CalibrationResult","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationResult","title":"CalibrationResult","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result of a calibration run.</p> <p>This is a simple data class that holds the results returned from the Rust calibration function.</p> <p>Attributes:</p> Name Type Description <code>best_parameters</code> <code>dict[str, float]</code> <p>Dictionary mapping parameter IDs to their calibrated values</p> <code>parameter_names</code> <code>list[str]</code> <p>Ordered list of parameter names</p> <code>best_parameters_list</code> <code>list[float]</code> <p>Ordered list of parameter values (matches parameter_names order)</p> <code>final_loss</code> <code>float</code> <p>Final loss value achieved</p> <code>iterations</code> <code>int</code> <p>Number of iterations performed</p> <code>converged</code> <code>bool</code> <p>Whether the optimization converged</p> <code>termination_reason</code> <code>str</code> <p>Explanation of why optimization terminated</p>"},{"location":"api/calibrator/#commol.context.calibration.CalibrationResult-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationResult.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>String representation of calibration result.</p>"},{"location":"api/calibrator/#calibrationparameter","title":"CalibrationParameter","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationParameter","title":"CalibrationParameter","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a parameter to be calibrated with its bounds.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Parameter identifier (must match a model parameter ID)</p> <code>min_bound</code> <code>float</code> <p>Minimum allowed value for this parameter</p> <code>max_bound</code> <code>float</code> <p>Maximum allowed value for this parameter</p> <code>initial_guess</code> <code>float | None</code> <p>Optional starting value for optimization (if None, midpoint is used)</p>"},{"location":"api/calibrator/#commol.context.calibration.CalibrationParameter-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.context.calibration.CalibrationParameter.validate_bounds","title":"validate_bounds","text":"<pre><code>validate_bounds() -&gt; Self\n</code></pre> <p>Validate that max_bound &gt; min_bound and initial_guess is within bounds.</p>"},{"location":"api/calibrator/#observeddatapoint","title":"ObservedDataPoint","text":""},{"location":"api/calibrator/#commol.context.calibration.ObservedDataPoint","title":"ObservedDataPoint","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single observed data point for calibration.</p> <p>Attributes:</p> Name Type Description <code>step</code> <code>int</code> <p>Time step of the observation</p> <code>compartment</code> <code>str</code> <p>Name of the compartment being observed</p> <code>value</code> <code>float</code> <p>Observed value</p> <code>weight</code> <code>float</code> <p>Weight for this observation in the loss function (default: 1.0)</p>"},{"location":"api/calibrator/#lossconfig","title":"LossConfig","text":""},{"location":"api/calibrator/#commol.context.calibration.LossConfig","title":"LossConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the loss function used in calibration.</p> <p>Attributes:</p> Name Type Description <code>function</code> <code>LossFunction</code> <p>The loss function to use for measuring fit quality</p>"},{"location":"api/calibrator/#optimizationconfig","title":"OptimizationConfig","text":""},{"location":"api/calibrator/#commol.context.calibration.OptimizationConfig","title":"OptimizationConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the optimization algorithm.</p> <p>Attributes:</p> Name Type Description <code>algorithm</code> <code>Literal[nelder_mead, particle_swarm]</code> <p>The optimization algorithm to use</p> <code>config</code> <code>NelderMeadConfig | ParticleSwarmConfig</code> <p>Configuration for the selected algorithm</p>"},{"location":"api/calibrator/#commol.context.calibration.OptimizationConfig-functions","title":"Functions","text":""},{"location":"api/calibrator/#commol.context.calibration.OptimizationConfig.validate_algorithm_config","title":"validate_algorithm_config","text":"<pre><code>validate_algorithm_config() -&gt; Self\n</code></pre> <p>Ensure the config type matches the selected algorithm.</p>"},{"location":"api/calibrator/#neldermeadconfig","title":"NelderMeadConfig","text":""},{"location":"api/calibrator/#commol.context.calibration.NelderMeadConfig","title":"NelderMeadConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the Nelder-Mead optimization algorithm.</p> <p>The Nelder-Mead method is a simplex-based derivative-free optimization algorithm, suitable for problems where gradients are not available.</p> <p>Attributes:</p> Name Type Description <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations (default: 1000)</p> <code>sd_tolerance</code> <code>float</code> <p>Convergence tolerance for standard deviation (default: 1e-6)</p> <code>alpha</code> <code>float | None</code> <p>Reflection coefficient (default: None, uses argmin's default)</p> <code>gamma</code> <code>float | None</code> <p>Expansion coefficient (default: None, uses argmin's default)</p> <code>rho</code> <code>float | None</code> <p>Contraction coefficient (default: None, uses argmin's default)</p> <code>sigma</code> <code>float | None</code> <p>Shrink coefficient (default: None, uses argmin's default)</p> <code>verbose</code> <code>bool</code> <p>Enable verbose output during optimization (default: False)</p> <code>header_interval</code> <code>int</code> <p>Number of iterations between table header repeats in verbose output (default: 100)</p>"},{"location":"api/calibrator/#particleswarmconfig","title":"ParticleSwarmConfig","text":""},{"location":"api/calibrator/#commol.context.calibration.ParticleSwarmConfig","title":"ParticleSwarmConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the Particle Swarm Optimization algorithm.</p> <p>Particle Swarm Optimization (PSO) is a population-based metaheuristic inspired by social behavior of bird flocking or fish schooling.</p> <p>Attributes:</p> Name Type Description <code>num_particles</code> <code>int</code> <p>Number of particles in the swarm (default: 40)</p> <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations (default: 1000)</p> <code>target_cost</code> <code>float | None</code> <p>Target cost for early stopping (optional)</p> <code>inertia_factor</code> <code>float | None</code> <p>Inertia weight applied to velocity (default: None, uses argmin's default)</p> <code>cognitive_factor</code> <code>float | None</code> <p>Attraction to personal best (default: None, uses argmin's default)</p> <code>social_factor</code> <code>float | None</code> <p>Attraction to swarm best (default: None, uses argmin's default)</p> <code>verbose</code> <code>bool</code> <p>Enable verbose output during optimization (default: False)</p> <code>header_interval</code> <code>int</code> <p>Number of iterations between table header repeats in verbose output (default: 100)</p>"},{"location":"api/calibrator/#enumerations","title":"Enumerations","text":""},{"location":"api/calibrator/#lossfunction","title":"LossFunction","text":""},{"location":"api/calibrator/#commol.context.calibration.LossFunction","title":"LossFunction","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available loss functions for calibration.</p> <p>Attributes:</p> Name Type Description <code>SSE</code> <code>str</code> <p>Sum of Squared Errors</p> <code>RMSE</code> <code>str</code> <p>Root Mean Squared Error</p> <code>MAE</code> <code>str</code> <p>Mean Absolute Error</p> <code>WEIGHTED_SSE</code> <code>str</code> <p>Weighted Sum of Squared Errors</p>"},{"location":"api/calibrator/#commol.context.calibration.LossFunction-attributes","title":"Attributes","text":""},{"location":"api/calibrator/#commol.context.calibration.LossFunction.SSE","title":"SSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SSE = 'sum_squared_error'\n</code></pre>"},{"location":"api/calibrator/#commol.context.calibration.LossFunction.RMSE","title":"RMSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RMSE = 'root_mean_squared_error'\n</code></pre>"},{"location":"api/calibrator/#commol.context.calibration.LossFunction.MAE","title":"MAE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAE = 'mean_absolute_error'\n</code></pre>"},{"location":"api/calibrator/#commol.context.calibration.LossFunction.WEIGHTED_SSE","title":"WEIGHTED_SSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEIGHTED_SSE = 'weighted_sse'\n</code></pre>"},{"location":"api/calibrator/#optimizationalgorithm","title":"OptimizationAlgorithm","text":""},{"location":"api/calibrator/#commol.context.calibration.OptimizationAlgorithm","title":"OptimizationAlgorithm","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available optimization algorithms.</p> <p>Attributes:</p> Name Type Description <code>NELDER_MEAD</code> <code>str</code> <p>Nelder-Mead simplex algorithm</p> <code>PARTICLE_SWARM</code> <code>str</code> <p>Particle Swarm Optimization</p>"},{"location":"api/calibrator/#commol.context.calibration.OptimizationAlgorithm-attributes","title":"Attributes","text":""},{"location":"api/calibrator/#commol.context.calibration.OptimizationAlgorithm.NELDER_MEAD","title":"NELDER_MEAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NELDER_MEAD = 'nelder_mead'\n</code></pre>"},{"location":"api/calibrator/#commol.context.calibration.OptimizationAlgorithm.PARTICLE_SWARM","title":"PARTICLE_SWARM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARTICLE_SWARM = 'particle_swarm'\n</code></pre>"},{"location":"api/constants/","title":"Constants","text":""},{"location":"api/constants/#commol.constants","title":"constants","text":""},{"location":"api/model-builder/","title":"ModelBuilder API","text":""},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder","title":"ModelBuilder","text":"<p>A programmatic interface for building compartment models.</p> <p>This class provides a fluent API for constructing Model instances by progressively adding bins, stratifications, transitions, parameters, and initial conditions. It includes validation methods to ensure model consistency before building.</p> <p>Attributes:</p> Name Type Description <code>_name</code> <code>str</code> <p>The model name.</p> <code>_description</code> <code>str | None</code> <p>The model description.</p> <code>_version</code> <code>str | None</code> <p>The model version.</p> <code>_disease_states</code> <code>list[Bin]</code> <p>List of bins in the model.</p> <code>_stratifications</code> <code>list[Stratification]</code> <p>List of population stratifications.</p> <code>_transitions</code> <code>list[Transition]</code> <p>List of transitions between states.</p> <code>_parameters</code> <code>list[Parameter]</code> <p>List of model parameters.</p> <code>_initial_conditions</code> <code>InitialConditions | None</code> <p>Initial population conditions.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>class ModelBuilder:\n    \"\"\"\n    A programmatic interface for building compartment models.\n\n    This class provides a fluent API for constructing Model instances by progressively\n    adding bins, stratifications, transitions, parameters, and\n    initial conditions. It includes validation methods to ensure model consistency\n    before building.\n\n    Attributes\n    ----------\n    _name : str\n        The model name.\n    _description : str | None\n        The model description.\n    _version : str | None\n        The model version.\n    _disease_states : list[Bin]\n        List of bins in the model.\n    _stratifications : list[Stratification]\n        List of population stratifications.\n    _transitions : list[Transition]\n        List of transitions between states.\n    _parameters : list[Parameter]\n        List of model parameters.\n    _initial_conditions : InitialConditions | None\n        Initial population conditions.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str | None = None,\n        version: str | None = None,\n    ):\n        \"\"\"\n        Initialize the ModelBuilder.\n\n        Parameters\n        ----------\n        name : str\n            The unique name that identifies the model.\n        description : str | None, default=None\n            A human-readable description of the model's purpose and function.\n        version : str | None, default=None\n            The version number of the model.\n        \"\"\"\n        self._name: str = name\n        self._description: str | None = description\n        self._version: str | None = version\n\n        self._bins: list[Bin] = []\n        self._stratifications: list[Stratification] = []\n        self._transitions: list[Transition] = []\n        self._parameters: list[Parameter] = []\n        self._initial_conditions: InitialConditions | None = None\n\n        logging.info(\n            (\n                f\"Initialized ModelBuilder: name='{self._name}', \"\n                f\"version='{self._version or 'N/A'}'\"\n            )\n        )\n\n    def add_bin(self, id: str, name: str) -&gt; Self:\n        \"\"\"\n        Add a bin to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the bin.\n        name : str\n            Human-readable name for the bin.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        self._bins.append(Bin(id=id, name=name))\n        logging.info(f\"Added bin: id='{id}', name='{name}'\")\n        return self\n\n    def add_stratification(self, id: str, categories: list[str]) -&gt; Self:\n        \"\"\"\n        Add a population stratification to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the stratification.\n        categories : list[str]\n            list of category identifiers within this stratification.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        self._stratifications.append(Stratification(id=id, categories=categories))\n        logging.info(f\"Added stratification: id='{id}', categories={categories}\")\n        return self\n\n    def add_parameter(\n        self,\n        id: str,\n        value: float,\n        description: str | None = None,\n        unit: str | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Add a global parameter to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the parameter.\n        value : float\n            Numerical value of the parameter.\n        description : str | None, default=None\n            Human-readable description of the parameter.\n        unit : str | None, default=None\n            Unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\").\n            Used for unit consistency checking in equations.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        self._parameters.append(\n            Parameter(id=id, value=value, description=description, unit=unit)\n        )\n        logging.info(f\"Added parameter: id='{id}', value={value}, unit='{unit}'\")\n        return self\n\n    def add_transition(\n        self,\n        id: str,\n        source: list[str],\n        target: list[str],\n        rate: str | float | None = None,\n        stratified_rates: list[StratifiedRateDict] | None = None,\n        condition: Condition | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Add a transition between states to the model.\n\n        Parameters\n        ----------\n        id : str\n            Unique identifier for the transition.\n        source : list[str]\n            List of source state/category identifiers.\n        target : list[str]\n            List of target state/category identifiers.\n        rate : str | float | None, default=None\n            Default mathematical formula, parameter reference, or constant value for\n            the transition rate. Used when no stratified rate matches.\n            Can be:\n            - A parameter reference (e.g., \"beta\")\n            - A constant value (e.g., \"0.5\" or 0.5)\n            - A mathematical formula (e.g., \"beta * S * I / N\")\n\n            Special variables available in formulas:\n            - N: Total population (automatically calculated)\n            - step or t: Current simulation step (both are equivalent)\n            - pi, e: Mathematical constants\n\n        stratified_rates : list[dict] | None, default=None\n            List of stratification-specific rates. Each dict must contain:\n            - \"conditions\": List of dicts with \"stratification\" and \"category\" keys\n            - \"rate\": Rate expression string\n\n        condition : Condition| None, default=None\n            Logical conditions that must be met for the transition.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        # Convert rate to string if numeric\n        if isinstance(rate, int) or isinstance(rate, float):\n            rate = str(rate)\n\n        # Convert stratified rates dicts to Pydantic objects\n        stratified_rates_objects: list[StratifiedRate] | None = None\n        if stratified_rates:\n            stratified_rates_objects = []\n            for rate_dict in stratified_rates:\n                conditions = [\n                    StratificationCondition(**cond) for cond in rate_dict[\"conditions\"]\n                ]\n                stratified_rates_objects.append(\n                    StratifiedRate(conditions=conditions, rate=str(rate_dict[\"rate\"]))\n                )\n\n        self._transitions.append(\n            Transition(\n                id=id,\n                source=source,\n                target=target,\n                rate=rate,\n                stratified_rates=stratified_rates_objects,\n                condition=condition,\n            )\n        )\n        logging.info(\n            (\n                f\"Added transition: id='{id}', source={source}, target={target}, \"\n                f\"rate='{rate}', stratified_rates={\n                    len(stratified_rates_objects) if stratified_rates_objects else 0\n                }\"\n            )\n        )\n        return self\n\n    def create_condition(\n        self,\n        logic: Literal[LogicOperators.AND, LogicOperators.OR],\n        rules: list[RuleDict],\n    ) -&gt; Condition:\n        \"\"\"\n        Create a condition object for use in transitions.\n\n        Parameters\n        ----------\n        logic : Literal[\"and\", \"or\"]\n            How to combine the rules.\n        rules : List[RuleDict]\n            List of rule dictionaries with 'variable', 'operator', and 'value' keys.\n            Each dictionary must have:\n            - 'variable': str (format '&lt;prefix&gt;:&lt;variable_id&gt;')\n            - 'operator': Literal[\"eq\", \"neq\", \"gt\", \"get\", \"lt\", \"let\"]\n            - 'value': str | int | float | bool\n\n        Returns\n        -------\n        Condition\n            The created condition object.\n\n        Examples\n        --------\n        &gt;&gt;&gt; condition = builder.create_condition(\n        ...     \"and\",\n        ...     [\n        ...         {\"variable\": \"states:I\", \"operator\": \"gt\", \"value\": 0},\n        ...         {\"variable\": \"strati:age\", \"operator\": \"eq\", \"value\": \"adult\"},\n        ...     ],\n        ... )\n        \"\"\"\n        rule_objects: list[Rule] = []\n        for rule_dict in rules:\n            rule_objects.append(\n                Rule(\n                    variable=rule_dict[\"variable\"],\n                    operator=rule_dict[\"operator\"],\n                    value=rule_dict[\"value\"],\n                )\n            )\n\n        return Condition(logic=logic, rules=rule_objects)\n\n    def set_initial_conditions(\n        self,\n        population_size: int,\n        bin_fractions: list[BinFractionDict],\n        stratification_fractions: list[StratificationFractionsDict] | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Set the initial conditions for the model.\n\n        Parameters\n        ----------\n        population_size : int\n            Total population size.\n        bin_fractions : list[BinFractionDict]\n            List of bin fractions. Each item is a dictionary with:\n            - \"bin\": str (bin id)\n            - \"fraction\": float (fractional size)\n\n            Example:\n            [\n                {\"bin\": \"S\", \"fraction\": 0.99},\n                {\"bin\": \"I\", \"fraction\": 0.01},\n                {\"bin\": \"R\", \"fraction\": 0.0}\n            ]\n        stratification_fractions : list[StratificationFractionsDict] | None,\n            default=None\n            List of stratification fractions. Each item is a dictionary with:\n            - \"stratification\": str (stratification id)\n            - \"fractions\": list of dicts, each with \"category\" and \"fraction\"\n\n            Example:\n            [\n                {\n                    \"stratification\": \"age_group\",\n                    \"fractions\": [\n                        {\"category\": \"young\", \"fraction\": 0.3},\n                        {\"category\": \"adult\", \"fraction\": 0.5},\n                        {\"category\": \"elderly\", \"fraction\": 0.2}\n                    ]\n                }\n            ]\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n\n        Raises\n        ------\n        ValueError\n            If initial conditions have already been set.\n        \"\"\"\n        if self._initial_conditions is not None:\n            raise ValueError(\"Initial conditions have already been set\")\n\n        bin_fractions_list: list[BinFraction] = []\n        for bf_dict in bin_fractions:\n            bin_fractions_list.append(\n                BinFraction(\n                    bin=bf_dict[\"bin\"],\n                    fraction=bf_dict[\"fraction\"],\n                )\n            )\n\n        strat_fractions_list: list[StratificationFractions] = []\n        if stratification_fractions:\n            for strat_dict in stratification_fractions:\n                fractions_list: list[StratificationFraction] = []\n                for frac_dict in strat_dict[\"fractions\"]:\n                    fractions_list.append(\n                        StratificationFraction(\n                            category=frac_dict[\"category\"],\n                            fraction=frac_dict[\"fraction\"],\n                        )\n                    )\n                strat_fractions_list.append(\n                    StratificationFractions(\n                        stratification=strat_dict[\"stratification\"],\n                        fractions=fractions_list,\n                    )\n                )\n\n        self._initial_conditions = InitialConditions(\n            population_size=population_size,\n            bin_fractions=bin_fractions_list,\n            stratification_fractions=strat_fractions_list,\n        )\n        bin_ids = [bf[\"bin\"] for bf in bin_fractions]\n        logging.info(\n            (\n                f\"Set initial conditions: population_size={population_size}, \"\n                f\"bins={bin_ids}\"\n            )\n        )\n        return self\n\n    def get_summary(self) -&gt; dict[str, str | int | list[str] | None]:\n        \"\"\"\n        Get a summary of the current model builder state.\n\n        Returns\n        -------\n        dict[str, dict[str, str | int | list[str] | None]]\n            Dictionary containing summary information about the model being built.\n        \"\"\"\n        return {\n            \"name\": self._name,\n            \"description\": self._description,\n            \"version\": self._version,\n            \"disease_states_count\": len(self._bins),\n            \"bin_ids\": [state.id for state in self._bins],\n            \"stratifications_count\": len(self._stratifications),\n            \"stratification_ids\": [strat.id for strat in self._stratifications],\n            \"transitions_count\": len(self._transitions),\n            \"transition_ids\": [trans.id for trans in self._transitions],\n            \"parameters_count\": len(self._parameters),\n            \"parameter_ids\": [param.id for param in self._parameters],\n            \"has_initial_conditions\": self._initial_conditions is not None,\n        }\n\n    def clone(self) -&gt; Self:\n        \"\"\"\n        Create a deep copy of this ModelBuilder.\n\n        Returns\n        -------\n        ModelBuilder\n            A new ModelBuilder instance with the same configuration.\n        \"\"\"\n\n        new_builder = type(self)(self._name, self._description, self._version)\n\n        new_builder._bins = copy.deepcopy(self._bins)\n        new_builder._stratifications = copy.deepcopy(self._stratifications)\n        new_builder._transitions = copy.deepcopy(self._transitions)\n        new_builder._parameters = copy.deepcopy(self._parameters)\n        new_builder._initial_conditions = copy.deepcopy(self._initial_conditions)\n\n        return new_builder\n\n    def reset(self) -&gt; Self:\n        \"\"\"\n        Reset the builder to empty state while keeping name, description, and version.\n\n        Returns\n        -------\n        ModelBuilder\n            Self for method chaining.\n        \"\"\"\n        self._bins.clear()\n        self._stratifications.clear()\n        self._transitions.clear()\n        self._parameters.clear()\n        self._initial_conditions = None\n        return self\n\n    def build(self, typology: Literal[ModelTypes.DIFFERENCE_EQUATIONS]) -&gt; Model:\n        \"\"\"\n        Build and return the final Model instance.\n\n        Parameters\n        ----------\n        typology : Literal[\"DifferenceEquations\"]\n            Type of the model.\n\n        Returns\n        -------\n        Model\n            The constructed compartment model.\n\n        Raises\n        ------\n        ValueError\n            If validation fails or required components are missing.\n        \"\"\"\n        if self._initial_conditions is None:\n            raise ValueError(\"Initial conditions must be set\")\n\n        population = Population(\n            bins=self._bins,\n            stratifications=self._stratifications,\n            transitions=self._transitions,\n            initial_conditions=self._initial_conditions,\n        )\n\n        dynamics = Dynamics(typology=typology, transitions=self._transitions)\n\n        model = Model(\n            name=self._name,\n            description=self._description,\n            version=self._version,\n            population=population,\n            parameters=self._parameters,\n            dynamics=dynamics,\n        )\n\n        logging.info(\n            f\"Model '{self._name}' successfully built with typology '{typology}'.\"\n        )\n\n        return model\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder-functions","title":"Functions","text":""},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.__init__","title":"__init__","text":"<pre><code>__init__(name: str, description: str | None = None, version: str | None = None)\n</code></pre> <p>Initialize the ModelBuilder.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name that identifies the model.</p> required <code>description</code> <code>str | None</code> <p>A human-readable description of the model's purpose and function.</p> <code>None</code> <code>version</code> <code>str | None</code> <p>The version number of the model.</p> <code>None</code> Source code in <code>commol/api/model_builder.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    description: str | None = None,\n    version: str | None = None,\n):\n    \"\"\"\n    Initialize the ModelBuilder.\n\n    Parameters\n    ----------\n    name : str\n        The unique name that identifies the model.\n    description : str | None, default=None\n        A human-readable description of the model's purpose and function.\n    version : str | None, default=None\n        The version number of the model.\n    \"\"\"\n    self._name: str = name\n    self._description: str | None = description\n    self._version: str | None = version\n\n    self._bins: list[Bin] = []\n    self._stratifications: list[Stratification] = []\n    self._transitions: list[Transition] = []\n    self._parameters: list[Parameter] = []\n    self._initial_conditions: InitialConditions | None = None\n\n    logging.info(\n        (\n            f\"Initialized ModelBuilder: name='{self._name}', \"\n            f\"version='{self._version or 'N/A'}'\"\n        )\n    )\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.add_bin","title":"add_bin","text":"<pre><code>add_bin(id: str, name: str) -&gt; Self\n</code></pre> <p>Add a bin to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the bin.</p> required <code>name</code> <code>str</code> <p>Human-readable name for the bin.</p> required <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def add_bin(self, id: str, name: str) -&gt; Self:\n    \"\"\"\n    Add a bin to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the bin.\n    name : str\n        Human-readable name for the bin.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    self._bins.append(Bin(id=id, name=name))\n    logging.info(f\"Added bin: id='{id}', name='{name}'\")\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.add_stratification","title":"add_stratification","text":"<pre><code>add_stratification(id: str, categories: list[str]) -&gt; Self\n</code></pre> <p>Add a population stratification to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the stratification.</p> required <code>categories</code> <code>list[str]</code> <p>list of category identifiers within this stratification.</p> required <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def add_stratification(self, id: str, categories: list[str]) -&gt; Self:\n    \"\"\"\n    Add a population stratification to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the stratification.\n    categories : list[str]\n        list of category identifiers within this stratification.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    self._stratifications.append(Stratification(id=id, categories=categories))\n    logging.info(f\"Added stratification: id='{id}', categories={categories}\")\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.add_parameter","title":"add_parameter","text":"<pre><code>add_parameter(id: str, value: float, description: str | None = None, unit: str | None = None) -&gt; Self\n</code></pre> <p>Add a global parameter to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the parameter.</p> required <code>value</code> <code>float</code> <p>Numerical value of the parameter.</p> required <code>description</code> <code>str | None</code> <p>Human-readable description of the parameter.</p> <code>None</code> <code>unit</code> <code>str | None</code> <p>Unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\"). Used for unit consistency checking in equations.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def add_parameter(\n    self,\n    id: str,\n    value: float,\n    description: str | None = None,\n    unit: str | None = None,\n) -&gt; Self:\n    \"\"\"\n    Add a global parameter to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the parameter.\n    value : float\n        Numerical value of the parameter.\n    description : str | None, default=None\n        Human-readable description of the parameter.\n    unit : str | None, default=None\n        Unit of the parameter (e.g., \"1/day\", \"dimensionless\", \"person\").\n        Used for unit consistency checking in equations.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    self._parameters.append(\n        Parameter(id=id, value=value, description=description, unit=unit)\n    )\n    logging.info(f\"Added parameter: id='{id}', value={value}, unit='{unit}'\")\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.add_transition","title":"add_transition","text":"<pre><code>add_transition(id: str, source: list[str], target: list[str], rate: str | float | None = None, stratified_rates: list[StratifiedRateDict] | None = None, condition: Condition | None = None) -&gt; Self\n</code></pre> <p>Add a transition between states to the model.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the transition.</p> required <code>source</code> <code>list[str]</code> <p>List of source state/category identifiers.</p> required <code>target</code> <code>list[str]</code> <p>List of target state/category identifiers.</p> required <code>rate</code> <code>str | float | None</code> <p>Default mathematical formula, parameter reference, or constant value for the transition rate. Used when no stratified rate matches. Can be: - A parameter reference (e.g., \"beta\") - A constant value (e.g., \"0.5\" or 0.5) - A mathematical formula (e.g., \"beta * S * I / N\")</p> <p>Special variables available in formulas: - N: Total population (automatically calculated) - step or t: Current simulation step (both are equivalent) - pi, e: Mathematical constants</p> <code>None</code> <code>stratified_rates</code> <code>list[dict] | None</code> <p>List of stratification-specific rates. Each dict must contain: - \"conditions\": List of dicts with \"stratification\" and \"category\" keys - \"rate\": Rate expression string</p> <code>None</code> <code>condition</code> <code>Condition | None</code> <p>Logical conditions that must be met for the transition.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def add_transition(\n    self,\n    id: str,\n    source: list[str],\n    target: list[str],\n    rate: str | float | None = None,\n    stratified_rates: list[StratifiedRateDict] | None = None,\n    condition: Condition | None = None,\n) -&gt; Self:\n    \"\"\"\n    Add a transition between states to the model.\n\n    Parameters\n    ----------\n    id : str\n        Unique identifier for the transition.\n    source : list[str]\n        List of source state/category identifiers.\n    target : list[str]\n        List of target state/category identifiers.\n    rate : str | float | None, default=None\n        Default mathematical formula, parameter reference, or constant value for\n        the transition rate. Used when no stratified rate matches.\n        Can be:\n        - A parameter reference (e.g., \"beta\")\n        - A constant value (e.g., \"0.5\" or 0.5)\n        - A mathematical formula (e.g., \"beta * S * I / N\")\n\n        Special variables available in formulas:\n        - N: Total population (automatically calculated)\n        - step or t: Current simulation step (both are equivalent)\n        - pi, e: Mathematical constants\n\n    stratified_rates : list[dict] | None, default=None\n        List of stratification-specific rates. Each dict must contain:\n        - \"conditions\": List of dicts with \"stratification\" and \"category\" keys\n        - \"rate\": Rate expression string\n\n    condition : Condition| None, default=None\n        Logical conditions that must be met for the transition.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    # Convert rate to string if numeric\n    if isinstance(rate, int) or isinstance(rate, float):\n        rate = str(rate)\n\n    # Convert stratified rates dicts to Pydantic objects\n    stratified_rates_objects: list[StratifiedRate] | None = None\n    if stratified_rates:\n        stratified_rates_objects = []\n        for rate_dict in stratified_rates:\n            conditions = [\n                StratificationCondition(**cond) for cond in rate_dict[\"conditions\"]\n            ]\n            stratified_rates_objects.append(\n                StratifiedRate(conditions=conditions, rate=str(rate_dict[\"rate\"]))\n            )\n\n    self._transitions.append(\n        Transition(\n            id=id,\n            source=source,\n            target=target,\n            rate=rate,\n            stratified_rates=stratified_rates_objects,\n            condition=condition,\n        )\n    )\n    logging.info(\n        (\n            f\"Added transition: id='{id}', source={source}, target={target}, \"\n            f\"rate='{rate}', stratified_rates={\n                len(stratified_rates_objects) if stratified_rates_objects else 0\n            }\"\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.create_condition","title":"create_condition","text":"<pre><code>create_condition(logic: Literal[AND, OR], rules: list[RuleDict]) -&gt; Condition\n</code></pre> <p>Create a condition object for use in transitions.</p> <p>Parameters:</p> Name Type Description Default <code>logic</code> <code>Literal['and', 'or']</code> <p>How to combine the rules.</p> required <code>rules</code> <code>List[RuleDict]</code> <p>List of rule dictionaries with 'variable', 'operator', and 'value' keys. Each dictionary must have: - 'variable': str (format ':') - 'operator': Literal[\"eq\", \"neq\", \"gt\", \"get\", \"lt\", \"let\"] - 'value': str | int | float | bool required <p>Returns:</p> Type Description <code>Condition</code> <p>The created condition object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; condition = builder.create_condition(\n...     \"and\",\n...     [\n...         {\"variable\": \"states:I\", \"operator\": \"gt\", \"value\": 0},\n...         {\"variable\": \"strati:age\", \"operator\": \"eq\", \"value\": \"adult\"},\n...     ],\n... )\n</code></pre> Source code in <code>commol/api/model_builder.py</code> <pre><code>def create_condition(\n    self,\n    logic: Literal[LogicOperators.AND, LogicOperators.OR],\n    rules: list[RuleDict],\n) -&gt; Condition:\n    \"\"\"\n    Create a condition object for use in transitions.\n\n    Parameters\n    ----------\n    logic : Literal[\"and\", \"or\"]\n        How to combine the rules.\n    rules : List[RuleDict]\n        List of rule dictionaries with 'variable', 'operator', and 'value' keys.\n        Each dictionary must have:\n        - 'variable': str (format '&lt;prefix&gt;:&lt;variable_id&gt;')\n        - 'operator': Literal[\"eq\", \"neq\", \"gt\", \"get\", \"lt\", \"let\"]\n        - 'value': str | int | float | bool\n\n    Returns\n    -------\n    Condition\n        The created condition object.\n\n    Examples\n    --------\n    &gt;&gt;&gt; condition = builder.create_condition(\n    ...     \"and\",\n    ...     [\n    ...         {\"variable\": \"states:I\", \"operator\": \"gt\", \"value\": 0},\n    ...         {\"variable\": \"strati:age\", \"operator\": \"eq\", \"value\": \"adult\"},\n    ...     ],\n    ... )\n    \"\"\"\n    rule_objects: list[Rule] = []\n    for rule_dict in rules:\n        rule_objects.append(\n            Rule(\n                variable=rule_dict[\"variable\"],\n                operator=rule_dict[\"operator\"],\n                value=rule_dict[\"value\"],\n            )\n        )\n\n    return Condition(logic=logic, rules=rule_objects)\n</code></pre> <p>options: show_root_heading: true show_source: true heading_level: 2 show_docstring_attributes: false</p>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.set_initial_conditions","title":"set_initial_conditions","text":"<pre><code>set_initial_conditions(population_size: int, bin_fractions: list[BinFractionDict], stratification_fractions: list[StratificationFractionsDict] | None = None) -&gt; Self\n</code></pre> <p>Set the initial conditions for the model.</p> <p>Parameters:</p> Name Type Description Default <code>population_size</code> <code>int</code> <p>Total population size.</p> required <code>bin_fractions</code> <code>list[BinFractionDict]</code> <p>List of bin fractions. Each item is a dictionary with: - \"bin\": str (bin id) - \"fraction\": float (fractional size)</p> <p>Example: [     {\"bin\": \"S\", \"fraction\": 0.99},     {\"bin\": \"I\", \"fraction\": 0.01},     {\"bin\": \"R\", \"fraction\": 0.0} ]</p> required <code>stratification_fractions</code> <code>(list[StratificationFractionsDict] | None,)</code> <p>default=None List of stratification fractions. Each item is a dictionary with: - \"stratification\": str (stratification id) - \"fractions\": list of dicts, each with \"category\" and \"fraction\"</p> <p>Example: [     {         \"stratification\": \"age_group\",         \"fractions\": [             {\"category\": \"young\", \"fraction\": 0.3},             {\"category\": \"adult\", \"fraction\": 0.5},             {\"category\": \"elderly\", \"fraction\": 0.2}         ]     } ]</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If initial conditions have already been set.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def set_initial_conditions(\n    self,\n    population_size: int,\n    bin_fractions: list[BinFractionDict],\n    stratification_fractions: list[StratificationFractionsDict] | None = None,\n) -&gt; Self:\n    \"\"\"\n    Set the initial conditions for the model.\n\n    Parameters\n    ----------\n    population_size : int\n        Total population size.\n    bin_fractions : list[BinFractionDict]\n        List of bin fractions. Each item is a dictionary with:\n        - \"bin\": str (bin id)\n        - \"fraction\": float (fractional size)\n\n        Example:\n        [\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    stratification_fractions : list[StratificationFractionsDict] | None,\n        default=None\n        List of stratification fractions. Each item is a dictionary with:\n        - \"stratification\": str (stratification id)\n        - \"fractions\": list of dicts, each with \"category\" and \"fraction\"\n\n        Example:\n        [\n            {\n                \"stratification\": \"age_group\",\n                \"fractions\": [\n                    {\"category\": \"young\", \"fraction\": 0.3},\n                    {\"category\": \"adult\", \"fraction\": 0.5},\n                    {\"category\": \"elderly\", \"fraction\": 0.2}\n                ]\n            }\n        ]\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n\n    Raises\n    ------\n    ValueError\n        If initial conditions have already been set.\n    \"\"\"\n    if self._initial_conditions is not None:\n        raise ValueError(\"Initial conditions have already been set\")\n\n    bin_fractions_list: list[BinFraction] = []\n    for bf_dict in bin_fractions:\n        bin_fractions_list.append(\n            BinFraction(\n                bin=bf_dict[\"bin\"],\n                fraction=bf_dict[\"fraction\"],\n            )\n        )\n\n    strat_fractions_list: list[StratificationFractions] = []\n    if stratification_fractions:\n        for strat_dict in stratification_fractions:\n            fractions_list: list[StratificationFraction] = []\n            for frac_dict in strat_dict[\"fractions\"]:\n                fractions_list.append(\n                    StratificationFraction(\n                        category=frac_dict[\"category\"],\n                        fraction=frac_dict[\"fraction\"],\n                    )\n                )\n            strat_fractions_list.append(\n                StratificationFractions(\n                    stratification=strat_dict[\"stratification\"],\n                    fractions=fractions_list,\n                )\n            )\n\n    self._initial_conditions = InitialConditions(\n        population_size=population_size,\n        bin_fractions=bin_fractions_list,\n        stratification_fractions=strat_fractions_list,\n    )\n    bin_ids = [bf[\"bin\"] for bf in bin_fractions]\n    logging.info(\n        (\n            f\"Set initial conditions: population_size={population_size}, \"\n            f\"bins={bin_ids}\"\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.get_summary","title":"get_summary","text":"<pre><code>get_summary() -&gt; dict[str, str | int | list[str] | None]\n</code></pre> <p>Get a summary of the current model builder state.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, str | int | list[str] | None]]</code> <p>Dictionary containing summary information about the model being built.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def get_summary(self) -&gt; dict[str, str | int | list[str] | None]:\n    \"\"\"\n    Get a summary of the current model builder state.\n\n    Returns\n    -------\n    dict[str, dict[str, str | int | list[str] | None]]\n        Dictionary containing summary information about the model being built.\n    \"\"\"\n    return {\n        \"name\": self._name,\n        \"description\": self._description,\n        \"version\": self._version,\n        \"disease_states_count\": len(self._bins),\n        \"bin_ids\": [state.id for state in self._bins],\n        \"stratifications_count\": len(self._stratifications),\n        \"stratification_ids\": [strat.id for strat in self._stratifications],\n        \"transitions_count\": len(self._transitions),\n        \"transition_ids\": [trans.id for trans in self._transitions],\n        \"parameters_count\": len(self._parameters),\n        \"parameter_ids\": [param.id for param in self._parameters],\n        \"has_initial_conditions\": self._initial_conditions is not None,\n    }\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.clone","title":"clone","text":"<pre><code>clone() -&gt; Self\n</code></pre> <p>Create a deep copy of this ModelBuilder.</p> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>A new ModelBuilder instance with the same configuration.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def clone(self) -&gt; Self:\n    \"\"\"\n    Create a deep copy of this ModelBuilder.\n\n    Returns\n    -------\n    ModelBuilder\n        A new ModelBuilder instance with the same configuration.\n    \"\"\"\n\n    new_builder = type(self)(self._name, self._description, self._version)\n\n    new_builder._bins = copy.deepcopy(self._bins)\n    new_builder._stratifications = copy.deepcopy(self._stratifications)\n    new_builder._transitions = copy.deepcopy(self._transitions)\n    new_builder._parameters = copy.deepcopy(self._parameters)\n    new_builder._initial_conditions = copy.deepcopy(self._initial_conditions)\n\n    return new_builder\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.reset","title":"reset","text":"<pre><code>reset() -&gt; Self\n</code></pre> <p>Reset the builder to empty state while keeping name, description, and version.</p> <p>Returns:</p> Type Description <code>ModelBuilder</code> <p>Self for method chaining.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def reset(self) -&gt; Self:\n    \"\"\"\n    Reset the builder to empty state while keeping name, description, and version.\n\n    Returns\n    -------\n    ModelBuilder\n        Self for method chaining.\n    \"\"\"\n    self._bins.clear()\n    self._stratifications.clear()\n    self._transitions.clear()\n    self._parameters.clear()\n    self._initial_conditions = None\n    return self\n</code></pre>"},{"location":"api/model-builder/#commol.api.model_builder.ModelBuilder.build","title":"build","text":"<pre><code>build(typology: Literal[DIFFERENCE_EQUATIONS]) -&gt; Model\n</code></pre> <p>Build and return the final Model instance.</p> <p>Parameters:</p> Name Type Description Default <code>typology</code> <code>Literal['DifferenceEquations']</code> <p>Type of the model.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>The constructed compartment model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails or required components are missing.</p> Source code in <code>commol/api/model_builder.py</code> <pre><code>def build(self, typology: Literal[ModelTypes.DIFFERENCE_EQUATIONS]) -&gt; Model:\n    \"\"\"\n    Build and return the final Model instance.\n\n    Parameters\n    ----------\n    typology : Literal[\"DifferenceEquations\"]\n        Type of the model.\n\n    Returns\n    -------\n    Model\n        The constructed compartment model.\n\n    Raises\n    ------\n    ValueError\n        If validation fails or required components are missing.\n    \"\"\"\n    if self._initial_conditions is None:\n        raise ValueError(\"Initial conditions must be set\")\n\n    population = Population(\n        bins=self._bins,\n        stratifications=self._stratifications,\n        transitions=self._transitions,\n        initial_conditions=self._initial_conditions,\n    )\n\n    dynamics = Dynamics(typology=typology, transitions=self._transitions)\n\n    model = Model(\n        name=self._name,\n        description=self._description,\n        version=self._version,\n        population=population,\n        parameters=self._parameters,\n        dynamics=dynamics,\n    )\n\n    logging.info(\n        f\"Model '{self._name}' successfully built with typology '{typology}'.\"\n    )\n\n    return model\n</code></pre>"},{"location":"api/simulation/","title":"Simulation API","text":"<p>options: show_root_heading: true show_source: true heading_level: 2 show_docstring_attributes: false</p>"},{"location":"api/simulation/#commol.api.simulation.Simulation","title":"Simulation","text":"<p>A Facade for running a simulation from a defined Model.</p> Source code in <code>commol/api/simulation.py</code> <pre><code>class Simulation:\n    \"\"\"\n    A Facade for running a simulation from a defined Model.\n    \"\"\"\n\n    def __init__(self, model: Model):\n        \"\"\"\n        Initializes the simulation engine from a Pydantic Model definition.\n\n        Parameters\n        ----------\n        model : Model\n            A fully constructed and validated model object.\n        \"\"\"\n        logging.info(f\"Initializing Simulation with model: '{model.name}'\")\n        self.model_definition: Model = model\n        self._engine: \"DifferenceEquationsProtocol\" = self._initialize_engine()\n\n        self._compartments: list[str] = self._engine.compartments\n        logging.info(\n            f\"Simulation engine ready. Total compartments: {len(self._compartments)}\"\n        )\n\n    def _initialize_engine(self) -&gt; \"DifferenceEquationsProtocol\":\n        \"\"\"Internal method to set up the Rust backend.\"\"\"\n        logging.info(\"Preparing model definition for Rust serialization...\")\n        model_json = self.model_definition.model_dump_json()\n\n        rust_model_instance: \"RustModelProtocol\" = core.Model.from_json(model_json)\n        logging.info(\"Rust model instance created from JSON.\")\n\n        # This could be extended if you have more engine types\n        if self.model_definition.dynamics.typology == ModelTypes.DIFFERENCE_EQUATIONS:\n            logging.info(\"Initializing DifferenceEquations engine.\")\n            return difference.DifferenceEquations(rust_model_instance)\n\n        raise NotImplementedError(\n            (\n                f\"Engine for typology '{self.model_definition.dynamics.typology}' \"\n                f\"not implemented.\"\n            )\n        )\n\n    def _run_raw(self, num_steps: int) -&gt; list[list[float]]:\n        \"\"\"\n        Runs the simulation and returns the raw, high-performance output.\n        This is the fastest method, returning a list of lists of floats.\n        \"\"\"\n        logging.info(f\"Running raw simulation for {num_steps} steps.\")\n        start = time.time()\n        results = self._engine.run(num_steps)\n        end = time.time()\n        logging.info(f\"Raw simulation complete. It tool {end - start} seconds.\")\n        return results\n\n    @overload\n    def run(\n        self, num_steps: int, output_format: Literal[\"list_of_lists\"]\n    ) -&gt; list[list[float]]: ...\n    @overload\n    def run(\n        self, num_steps: int, output_format: Literal[\"dict_of_lists\"]\n    ) -&gt; dict[str, list[float]]: ...\n    @overload\n    def run(self, num_steps: int) -&gt; dict[str, list[float]]: ...\n    def run(\n        self,\n        num_steps: int,\n        output_format: Literal[\"dict_of_lists\", \"list_of_lists\"] = \"dict_of_lists\",\n    ) -&gt; dict[str, list[float]] | list[list[float]]:\n        \"\"\"\n        Runs the simulation and returns the output in the specified format.\n\n        Parameters\n        ----------\n        num_steps : int\n            The number of steps for the simulation.\n        output_format : {'dict_of_lists', 'list_of_lists'}, default 'dict_of_lists'\n            - 'dict_of_lists': Returns a dictionary of lists, with compartment names\n                as keys.\n            - 'list_of_lists': Returns a list of lists of floats, where the first level\n                is the step and the second level the comptarment.\n\n        Returns\n        -------\n        dict[str, list[float]] | list[list[float]]\n            The simulation results in the specified format.\n        \"\"\"\n        raw_results = self._run_raw(num_steps)\n        if output_format == \"list_of_lists\":\n            logging.info(\"Returning results in 'list_of_lists' format.\")\n            return raw_results\n\n        elif output_format == \"dict_of_lists\":\n            logging.info(\"Transposing raw results to 'dict_of_lists' format.\")\n            if not raw_results:\n                return {c: [] for c in self._compartments}\n            transposed_results = zip(*raw_results)\n            return {\n                compartment: list(values)\n                for compartment, values in zip(self._compartments, transposed_results)\n            }\n\n        else:\n            assert_never(output_format)\n\n    @property\n    def engine(self) -&gt; \"DifferenceEquationsProtocol\":\n        \"\"\"Get the underlying simulation engine.\"\"\"\n        return self._engine\n</code></pre>"},{"location":"api/simulation/#commol.api.simulation.Simulation-attributes","title":"Attributes","text":""},{"location":"api/simulation/#commol.api.simulation.Simulation.engine","title":"engine  <code>property</code>","text":"<pre><code>engine: DifferenceEquationsProtocol\n</code></pre> <p>Get the underlying simulation engine.</p>"},{"location":"api/simulation/#commol.api.simulation.Simulation-functions","title":"Functions","text":""},{"location":"api/simulation/#commol.api.simulation.Simulation.__init__","title":"__init__","text":"<pre><code>__init__(model: Model)\n</code></pre> <p>Initializes the simulation engine from a Pydantic Model definition.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>A fully constructed and validated model object.</p> required Source code in <code>commol/api/simulation.py</code> <pre><code>def __init__(self, model: Model):\n    \"\"\"\n    Initializes the simulation engine from a Pydantic Model definition.\n\n    Parameters\n    ----------\n    model : Model\n        A fully constructed and validated model object.\n    \"\"\"\n    logging.info(f\"Initializing Simulation with model: '{model.name}'\")\n    self.model_definition: Model = model\n    self._engine: \"DifferenceEquationsProtocol\" = self._initialize_engine()\n\n    self._compartments: list[str] = self._engine.compartments\n    logging.info(\n        f\"Simulation engine ready. Total compartments: {len(self._compartments)}\"\n    )\n</code></pre>"},{"location":"api/simulation/#commol.api.simulation.Simulation.run","title":"run","text":"<pre><code>run(num_steps: int, output_format: Literal['list_of_lists']) -&gt; list[list[float]]\n</code></pre><pre><code>run(num_steps: int, output_format: Literal['dict_of_lists']) -&gt; dict[str, list[float]]\n</code></pre><pre><code>run(num_steps: int) -&gt; dict[str, list[float]]\n</code></pre> <pre><code>run(num_steps: int, output_format: Literal['dict_of_lists', 'list_of_lists'] = 'dict_of_lists') -&gt; dict[str, list[float]] | list[list[float]]\n</code></pre> <p>Runs the simulation and returns the output in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>The number of steps for the simulation.</p> required <code>output_format</code> <code>(dict_of_lists, list_of_lists)</code> <ul> <li>'dict_of_lists': Returns a dictionary of lists, with compartment names     as keys.</li> <li>'list_of_lists': Returns a list of lists of floats, where the first level     is the step and the second level the comptarment.</li> </ul> <code>'dict_of_lists'</code> <p>Returns:</p> Type Description <code>dict[str, list[float]] | list[list[float]]</code> <p>The simulation results in the specified format.</p> Source code in <code>commol/api/simulation.py</code> <pre><code>def run(\n    self,\n    num_steps: int,\n    output_format: Literal[\"dict_of_lists\", \"list_of_lists\"] = \"dict_of_lists\",\n) -&gt; dict[str, list[float]] | list[list[float]]:\n    \"\"\"\n    Runs the simulation and returns the output in the specified format.\n\n    Parameters\n    ----------\n    num_steps : int\n        The number of steps for the simulation.\n    output_format : {'dict_of_lists', 'list_of_lists'}, default 'dict_of_lists'\n        - 'dict_of_lists': Returns a dictionary of lists, with compartment names\n            as keys.\n        - 'list_of_lists': Returns a list of lists of floats, where the first level\n            is the step and the second level the comptarment.\n\n    Returns\n    -------\n    dict[str, list[float]] | list[list[float]]\n        The simulation results in the specified format.\n    \"\"\"\n    raw_results = self._run_raw(num_steps)\n    if output_format == \"list_of_lists\":\n        logging.info(\"Returning results in 'list_of_lists' format.\")\n        return raw_results\n\n    elif output_format == \"dict_of_lists\":\n        logging.info(\"Transposing raw results to 'dict_of_lists' format.\")\n        if not raw_results:\n            return {c: [] for c in self._compartments}\n        transposed_results = zip(*raw_results)\n        return {\n            compartment: list(values)\n            for compartment, values in zip(self._compartments, transposed_results)\n        }\n\n    else:\n        assert_never(output_format)\n</code></pre>"},{"location":"development/contributing/","title":"Contributing Guidelines","text":"<p>Thank you for considering contributing to EpiModel! This document provides guidelines for contributing to the project.</p>"},{"location":"development/contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"development/contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>Before creating a bug report:</p> <ul> <li>Check the issue tracker for existing reports</li> <li>Verify the bug exists in the latest version</li> </ul> <p>When creating a bug report, include:</p> <ul> <li>Clear title and description</li> <li>Steps to reproduce the issue</li> <li>Expected vs actual behavior</li> <li>Environment details (OS, Python version, EpiModel version)</li> <li>Code samples or test cases that demonstrate the problem</li> </ul>"},{"location":"development/contributing/#suggesting-features","title":"Suggesting Features","text":"<p>Feature suggestions are welcome! Please:</p> <ul> <li>Check if the feature has already been requested</li> <li>Provide a clear use case and rationale</li> <li>Describe the desired API or interface</li> <li>Consider implementation complexity vs benefit</li> </ul>"},{"location":"development/contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Keep PRs focused: One feature/fix per PR</li> <li>Write tests: All new code should have tests</li> <li>Update docs: Update README or documentation as needed</li> <li>Follow conventions: Use the project's code style</li> <li>Be descriptive: Write clear commit messages and PR descriptions</li> </ol>"},{"location":"development/contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"development/contributing/#code-style","title":"Code Style","text":""},{"location":"development/contributing/#python","title":"Python","text":"<ul> <li>Follow PEP 8</li> <li>Use type hints for all functions</li> <li>Maximum line length: 88 characters</li> <li>Use Ruff for linting and formatting</li> </ul> <pre><code>cd py-commol\npoetry run ruff check .\npoetry run ruff format .\npoetry run mypy epimodel\n</code></pre>"},{"location":"development/contributing/#rust","title":"Rust","text":"<ul> <li>Follow Rust API Guidelines</li> <li>Use <code>cargo fmt</code> for formatting</li> <li>Use <code>cargo clippy</code> for linting</li> <li>Document public APIs with rustdoc</li> </ul> <pre><code>cargo fmt --all\ncargo clippy --all-targets --all-features\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#python-tests","title":"Python Tests","text":"<ul> <li>Write tests using pytest</li> <li>Aim for &gt;95% code coverage</li> <li>Test both success and error cases</li> <li>Use descriptive test names</li> </ul> <pre><code>def test_model_builder_creates_valid_sir_model():\n    \"\"\"Test that ModelBuilder creates a valid SIR model.\"\"\"\n    model = (\n        ModelBuilder(name=\"Test SIR\")\n        .add_bin(id=\"S\", name=\"Susceptible\")\n        # ... rest of model\n        .build(ModelTypes.DIFFERENCE_EQUATIONS)\n    )\n    assert model.name == \"Test SIR\"\n</code></pre> <p>Run tests:</p> <pre><code>cd py-commol\npoetry run pytest -v --cov=epimodel\n</code></pre>"},{"location":"development/contributing/#rust-tests","title":"Rust Tests","text":"<ul> <li>Write unit tests in the same file</li> <li>Write integration tests in <code>tests/</code> directory</li> <li>Use <code>#[should_panic]</code> for error cases</li> </ul> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_model_creation() {\n        // Test implementation\n    }\n}\n</code></pre> <p>Run tests:</p> <pre><code>cargo test --workspace\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":""},{"location":"development/contributing/#python-docstrings","title":"Python Docstrings","text":"<p>Use NumPy-style docstrings:</p> <pre><code>def run(self, num_steps: int, output_format: str = \"dict_of_lists\") -&gt; dict:\n    \"\"\"\n    Runs the simulation and returns results.\n\n    Parameters\n    ----------\n    num_steps : int\n        Number of simulation steps to run.\n    output_format : str, default 'dict_of_lists'\n        Format for results ('dict_of_lists' or 'list_of_lists').\n\n    Returns\n    -------\n    dict\n        Simulation results in the specified format.\n\n    Raises\n    ------\n    ValueError\n        If num_steps is negative.\n\n    Examples\n    --------\n    &gt;&gt;&gt; sim = Simulation(model)\n    &gt;&gt;&gt; results = sim.run(num_steps=100)\n    \"\"\"\n</code></pre>"},{"location":"development/contributing/#rust-documentation","title":"Rust Documentation","text":"<p>Use rustdoc:</p> <pre><code>/// Runs the simulation for a given number of steps.\n///\n/// # Arguments\n///\n/// * `num_steps` - The number of time steps to simulate\n///\n/// # Returns\n///\n/// A vector of state vectors, one per time step\n///\n/// # Examples\n///\n/// ```\n/// let results = engine.run(100);\n/// assert_eq!(results.len(), 100);\n/// ```\npub fn run(&amp;self, num_steps: usize) -&gt; Vec&lt;Vec&lt;f64&gt;&gt; {\n    // Implementation\n}\n</code></pre>"},{"location":"development/contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow Conventional Commits:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Code style (formatting, missing semicolons, etc.)</li> <li><code>refactor</code>: Code refactoring</li> <li><code>perf</code>: Performance improvements</li> <li><code>test</code>: Adding or updating tests</li> <li><code>build</code>: Build system or dependencies</li> <li><code>ci</code>: CI/CD changes</li> <li><code>chore</code>: Other changes (releasing, etc.)</li> </ul> <p>Examples:</p> <pre><code>feat(transitions): add support for time-dependent rates\n\nImplemented mathematical expression parsing for dynamic\ntransition rates that change over time.\n\nCloses #123\n</code></pre> <pre><code>fix(simulation): prevent negative population values\n\nAdded validation to ensure compartment populations\nremain non-negative during simulation.\n</code></pre>"},{"location":"development/contributing/#code-review-process","title":"Code Review Process","text":""},{"location":"development/contributing/#for-contributors","title":"For Contributors","text":"<ol> <li>Respond to feedback promptly and professionally</li> <li>Make requested changes or discuss alternatives</li> <li>Keep the PR updated with the target branch</li> <li>Test locally before requesting re-review</li> </ol>"},{"location":"development/contributing/#for-reviewers","title":"For Reviewers","text":"<ol> <li>Be constructive and respectful</li> <li>Explain reasoning for requested changes</li> <li>Acknowledge good work when you see it</li> <li>Test the changes when possible</li> </ol>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<p>See Release Process for details on versioning and releases.</p>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check the docs</li> <li>Discussions: Use GitHub Discussions</li> <li>Issues: Report bugs via GitHub Issues</li> </ul>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors will be recognized in:</p> <ul> <li>The project's AUTHORS file</li> <li>Release notes for significant contributions</li> <li>GitHub's contributor graph</li> </ul> <p>Thank you for contributing to EpiModel! \ud83c\udf89</p>"},{"location":"development/release/","title":"Release Process","text":"<p>EpiModel follows Semantic Versioning (SemVer) for version numbering: <code>MAJOR.MINOR.PATCH</code></p>"},{"location":"development/release/#version-guidelines","title":"Version Guidelines","text":""},{"location":"development/release/#major-version-x00","title":"MAJOR version (X.0.0)","text":"<p>Incremented for incompatible API changes:</p> <ul> <li>Breaking changes to public API</li> <li>Removal of deprecated features</li> <li>Major architectural changes affecting backwards compatibility</li> <li>Example: Changing method signatures, removing public methods</li> </ul>"},{"location":"development/release/#minor-version-0x0","title":"MINOR version (0.X.0)","text":"<p>Incremented for backwards-compatible new features:</p> <ul> <li>New functionality added</li> <li>New disease states, stratifications, or transition types</li> <li>Performance improvements without API changes</li> <li>Deprecation notices (without removal)</li> <li>Example: Adding new mathematical functions, new model types</li> </ul>"},{"location":"development/release/#patch-version-00x","title":"PATCH version (0.0.X)","text":"<p>Incremented for backwards-compatible bug fixes:</p> <ul> <li>Bug fixes that don't change the API</li> <li>Documentation improvements</li> <li>Internal refactoring</li> <li>Security patches</li> <li>Example: Fixing calculation errors, typos in error messages</li> </ul>"},{"location":"development/release/#release-workflow","title":"Release Workflow","text":""},{"location":"development/release/#step-1-prepare-the-release","title":"Step 1: Prepare the Release","text":""},{"location":"development/release/#11-update-version-numbers","title":"1.1 Update Version Numbers","text":"<p>Edit the following files:</p> <ul> <li><code>py-commol/pyproject.toml</code> - Update <code>version</code> field</li> <li><code>Cargo.toml</code> - Update <code>[workspace.package]</code> version</li> </ul> <pre><code># py-commol/pyproject.toml\n[tool.poetry]\nversion = \"1.2.3\"\n\n# Cargo.toml\n[workspace.package]\nversion = \"1.2.3\"\n</code></pre>"},{"location":"development/release/#12-update-changelog-if-maintained","title":"1.2 Update CHANGELOG (if maintained)","text":"<p>Document all changes under the new version:</p> <pre><code>## [1.2.3] - 2024-12-15\n\n### Added\n\n- New mathematical functions for transition rates\n- Support for multi-compartment transitions\n\n### Changed\n\n- Improved simulation performance by 20%\n\n### Fixed\n\n- Fixed population conservation bug in stratified models\n- Corrected type hints in Simulation class\n\n### Security\n\n- Updated dependencies to patch vulnerabilities\n</code></pre>"},{"location":"development/release/#13-run-quality-checks","title":"1.3 Run Quality Checks","text":"<pre><code># Python checks\ncd py-commol\npoetry run ruff check .\npoetry run ruff format .\npoetry run mypy epimodel\npoetry run pytest\n\n# Rust checks\ncd ..\ncargo fmt --all\ncargo clippy --all-targets --all-features\ncargo test --workspace\n</code></pre>"},{"location":"development/release/#14-commit-version-changes","title":"1.4 Commit Version Changes","text":"<pre><code>git add py-commol/pyproject.toml Cargo.toml CHANGELOG.md\ngit commit -m \"chore: bump version to X.Y.Z\"\ngit push origin main\n</code></pre>"},{"location":"development/release/#step-2-create-github-release","title":"Step 2: Create GitHub Release","text":""},{"location":"development/release/#21-create-tag","title":"2.1 Create Tag","text":"<pre><code>git tag -a vX.Y.Z -m \"Release version X.Y.Z\"\ngit push origin vX.Y.Z\n</code></pre>"},{"location":"development/release/#22-create-github-release","title":"2.2 Create GitHub Release","text":"<ol> <li>Go to Releases page</li> <li>Click \"Draft a new release\"</li> <li>Select tag: <code>vX.Y.Z</code></li> <li>Set release title: <code>Version X.Y.Z</code></li> <li>Add release notes:</li> </ol> <pre><code>## What's New in X.Y.Z\n\n### New Features\n\n- Feature 1 description\n- Feature 2 description\n\n### Bug Fixes\n\n- Fix 1 description\n- Fix 2 description\n\n### Documentation\n\n- Documentation improvements\n\n### Performance\n\n- Performance improvements\n\n## Breaking Changes (for major versions)\n\n- List breaking changes\n- Migration guide\n\n## Installation\n\npip install epimodel==X.Y.Z\n\n## Full Changelog\n\nSee [CHANGELOG.md](https://github.com/MUNQU/commol/blob/main/CHANGELOG.md)\n</code></pre> <ol> <li>Click \"Publish release\"</li> </ol>"},{"location":"development/release/#step-3-automated-pypi-publication","title":"Step 3: Automated PyPI Publication","text":"<p>Once the release is published, the GitHub Actions workflow automatically:</p> <ol> <li>Builds wheels for Linux, Windows, and macOS</li> <li>Creates source distribution (sdist)</li> <li>Publishes to PyPI using trusted publishing</li> </ol> <p>Monitor progress:</p> <ul> <li>Go to Actions tab</li> <li>Watch the \"Release to PyPI\" workflow</li> </ul>"},{"location":"development/release/#step-4-verify-the-release","title":"Step 4: Verify the Release","text":""},{"location":"development/release/#41-check-pypi","title":"4.1 Check PyPI","text":"<p>Verify the package appears at: https://pypi.org/project/epimodel/</p>"},{"location":"development/release/#42-test-installation","title":"4.2 Test Installation","text":"<pre><code># Create fresh virtual environment\npython -m venv test_env\nsource test_env/bin/activate  # or test_env\\Scripts\\activate on Windows\n\n# Install the new version\npip install epimodel==X.Y.Z\n\n# Verify it works\npython -c \"from commol import ModelBuilder; print('Success!')\"\n</code></pre>"},{"location":"development/release/#43-test-functionality","title":"4.3 Test Functionality","text":"<pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n\n# Run a quick test\nmodel = (\n    ModelBuilder(name=\"Test\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"N\", value=1000.0)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsim = Simulation(model)\nresults = sim.run(num_steps=100)\nprint(f\"Final infected: {results['I'][-1]:.0f}\")\n</code></pre>"},{"location":"development/release/#step-5-sync-branches","title":"Step 5: Sync Branches","text":"<pre><code># Merge main back to develop\ngit checkout develop\ngit merge main\ngit push origin develop\n</code></pre>"},{"location":"development/release/#pre-release-versions","title":"Pre-release Versions","text":"<p>For testing before official release:</p>"},{"location":"development/release/#alpha-releases","title":"Alpha Releases","text":"<pre><code># Version: X.Y.Z-alpha.N\ngit tag -a v1.3.0-alpha.1 -m \"Alpha release for testing\"\ngit push origin v1.3.0-alpha.1\n</code></pre>"},{"location":"development/release/#beta-releases","title":"Beta Releases","text":"<pre><code># Version: X.Y.Z-beta.N\ngit tag -a v1.3.0-beta.1 -m \"Beta release for testing\"\ngit push origin v1.3.0-beta.1\n</code></pre>"},{"location":"development/release/#release-candidates","title":"Release Candidates","text":"<pre><code># Version: X.Y.Z-rc.N\ngit tag -a v1.3.0-rc.1 -m \"Release candidate\"\ngit push origin v1.3.0-rc.1\n</code></pre> <p>Important: Mark GitHub releases as \"pre-release\" to prevent automatic PyPI publication.</p>"},{"location":"development/release/#version-support-policy","title":"Version Support Policy","text":"<ul> <li>Latest version: Fully supported with new features and bug fixes</li> <li>Older versions: No support, users encouraged to upgrade</li> </ul>"},{"location":"development/release/#pypi-trusted-publishing-setup","title":"PyPI Trusted Publishing Setup","text":"<p>To enable automated PyPI publishing, configure trusted publishing:</p> <ol> <li>Go to PyPI and log in</li> <li>Go to your project settings</li> <li>Navigate to \"Publishing\" section</li> <li>Add GitHub as a trusted publisher:</li> <li>Owner: MUNQU</li> <li>Repository: epimodel</li> <li>Workflow: release.yml</li> <li>Environment: pypi</li> </ol> <p>This allows GitHub Actions to publish without API tokens.</p>"},{"location":"development/release/#release-checklist","title":"Release Checklist","text":"<ul> <li>[ ] Version updated in <code>pyproject.toml</code></li> <li>[ ] Version updated in <code>Cargo.toml</code></li> <li>[ ] CHANGELOG updated with all changes</li> <li>[ ] All tests passing locally</li> <li>[ ] Version committed and pushed to main</li> <li>[ ] Git tag created and pushed</li> <li>[ ] GitHub release created with notes</li> <li>[ ] CI/CD pipeline completed successfully</li> <li>[ ] Package verified on PyPI</li> <li>[ ] Installation tested in clean environment</li> <li>[ ] Main merged back to develop</li> <li>[ ] Release announced (if applicable)</li> </ul>"},{"location":"development/release/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/release/#pypi-upload-fails","title":"PyPI Upload Fails","text":"<ol> <li>Check GitHub Actions logs</li> <li>Verify trusted publishing is configured</li> <li>Ensure version number is unique (not already on PyPI)</li> <li>Check for artifact build errors</li> </ol>"},{"location":"development/release/#wheel-build-fails","title":"Wheel Build Fails","text":"<ol> <li>Check that Rust code compiles on all platforms</li> <li>Verify maturin configuration is correct</li> <li>Check for platform-specific dependencies</li> </ol>"},{"location":"development/release/#version-conflicts","title":"Version Conflicts","text":"<ol> <li>Ensure version is updated in all required files</li> <li>Use <code>git tag -d vX.Y.Z</code> to delete incorrect tags locally</li> <li>Use <code>git push origin :refs/tags/vX.Y.Z</code> to delete remote tags</li> </ol>"},{"location":"development/workflow/","title":"Development Workflow","text":""},{"location":"development/workflow/#development-setup","title":"Development Setup","text":"<p>EpiModel is built with Rust and Python. To set up your development environment:</p>"},{"location":"development/workflow/#1-install-prerequisites","title":"1. Install Prerequisites","text":"<pre><code># Install Rust toolchain\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Install Python 3.11 or higher\n# (use your system's package manager)\n\n# Install Poetry\ncurl -sSL https://install.python-poetry.org | python3 -\n</code></pre>"},{"location":"development/workflow/#2-clone-and-setup","title":"2. Clone and Setup","text":"<pre><code>git clone https://github.com/MUNQU/commol.git\ncd epimodel\n\n# Install Python dependencies\ncd py-commol\npoetry install --with dev\n\n# Install pre-commit hooks (optional but recommended)\npoetry run pre-commit install\n</code></pre>"},{"location":"development/workflow/#3-build-the-project","title":"3. Build the Project","text":"<pre><code># Build Rust workspace\ncargo build --workspace\n\n# Build Python extension\ncd py-commol\nmaturin develop --release\n</code></pre>"},{"location":"development/workflow/#branching-strategy","title":"Branching Strategy","text":"<p>We use a simplified Git Flow approach:</p> <ul> <li><code>main</code>: Production-ready code. Protected branch.</li> <li><code>develop</code>: Integration branch for features. Used for staging releases.</li> <li><code>feature/*</code>: New features, refactoring, or significant changes (e.g., <code>feature/add-stochastic-model</code>)</li> <li><code>fix/*</code>: Bug fixes (e.g., <code>fix/calculation-error</code>)</li> <li><code>docs/*</code>: Documentation-only changes (e.g., <code>docs/update-api-reference</code>)</li> <li><code>test/*</code>: Test additions or improvements (e.g., <code>test/add-sir-model-tests</code>)</li> <li><code>chore/*</code>: Maintenance tasks, dependencies (e.g., <code>chore/update-dependencies</code>)</li> </ul>"},{"location":"development/workflow/#development-process","title":"Development Process","text":""},{"location":"development/workflow/#1-starting-new-work","title":"1. Starting New Work","text":"<pre><code># Always start from the latest develop branch\ngit checkout develop\ngit pull origin develop\n\n# Create a feature branch\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/workflow/#2-making-changes","title":"2. Making Changes","text":"<pre><code># Make your changes to the code\n\n# Run quality checks before committing\ncd py-commol\npoetry run ruff check . --fix         # Auto-fix Python linting issues\npoetry run ruff format .              # Format Python code\npoetry run mypy epimodel              # Type checking\n\ncd ..\ncargo fmt --all                       # Format Rust code\ncargo clippy --all-targets --fix      # Fix Rust linting issues\n</code></pre>"},{"location":"development/workflow/#3-testing-your-changes","title":"3. Testing Your Changes","text":"<pre><code># Run Python tests\ncd py-commol\npoetry run pytest -v\n\n# Run Rust tests\ncd ..\ncargo test --workspace\n</code></pre>"},{"location":"development/workflow/#4-committing-changes","title":"4. Committing Changes","text":"<p>We follow Conventional Commits for commit messages:</p> <pre><code># Commit format: &lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\ngit add .\ngit commit -m \"feat(transitions): add support for time-varying rates\"\ngit commit -m \"fix(simulation): correct population calculation\"\ngit commit -m \"docs(readme): update installation instructions\"\ngit commit -m \"test(models): add tests for stratified models\"\n</code></pre> <p>Commit Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation only</li> <li><code>style</code>: Code style changes (formatting)</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Adding or updating tests</li> <li><code>chore</code>: Maintenance tasks, dependencies</li> <li><code>perf</code>: Performance improvements</li> <li><code>ci</code>: CI/CD changes</li> <li><code>build</code>: Build system changes</li> </ul> <p>Branch vs Commit Type:</p> <p>The branch name indicates the primary purpose of the work, while commit types describe individual changes:</p> <ul> <li>A <code>feature/refactor-api</code> branch may have <code>refactor</code>, <code>test</code>, and <code>docs</code> commits</li> <li>A <code>test/*</code> branch primarily adds tests but may have <code>fix</code> commits too</li> <li>A <code>docs/*</code> branch is documentation-only, so all commits should use <code>docs</code> type</li> </ul>"},{"location":"development/workflow/#5-pushing-and-creating-pull-requests","title":"5. Pushing and Creating Pull Requests","text":"<pre><code># Push your branch\ngit push origin feature/your-feature-name\n\n# Create a Pull Request on GitHub\n# - Target the 'develop' branch\n# - Fill in the PR template with:\n#   - Description of changes\n#   - Related issues\n#   - Testing performed\n#   - Screenshots (if UI changes)\n</code></pre>"},{"location":"development/workflow/#6-code-review-and-ci","title":"6. Code Review and CI","text":"<p>When you create a PR, automated checks run:</p> <ul> <li>Code Quality Pipeline: Linting, formatting, type checking for both Python and Rust</li> <li>Build Pipeline: Builds on Ubuntu, Windows, and macOS with Python versions</li> <li>Test Coverage: Runs all tests and reports coverage</li> </ul> <p>PR Requirements:</p> <ul> <li>All CI checks must pass</li> <li>At least one approving review</li> <li>No merge conflicts with target branch</li> <li>Code coverage should be &gt;95%</li> </ul>"},{"location":"development/workflow/#7-merging-to-develop","title":"7. Merging to Develop","text":"<p>Once approved:</p> <pre><code># Merge using \"Squash and merge\" or \"Rebase and merge\" on GitHub\n# Delete the feature branch after merging\n</code></pre>"},{"location":"development/workflow/#continuous-integration-pipelines","title":"Continuous Integration Pipelines","text":"<p>The project uses three main CI/CD pipelines:</p>"},{"location":"development/workflow/#1-code-quality-on-every-pushpr","title":"1. Code Quality (on every push/PR)","text":"<ul> <li>Python: Ruff (linting/formatting), MyPy (type checking), Pytest (testing)</li> <li>Rust: rustfmt (formatting), Clippy (linting), cargo test</li> <li>Runs on: Ubuntu</li> <li>Purpose: Ensure code quality standards</li> </ul>"},{"location":"development/workflow/#2-build-on-every-pushpr","title":"2. Build (on every push/PR)","text":"<ul> <li>Builds on: Ubuntu, Windows, macOS</li> <li>Python versions: 3.11, 3.12</li> <li>Tests: Full test suite on all platforms</li> <li>Artifacts: Wheel files for each platform</li> <li>Purpose: Ensure cross-platform compatibility</li> </ul>"},{"location":"development/workflow/#3-release-on-github-release","title":"3. Release (on GitHub release)","text":"<ul> <li>Builds wheels for all platforms</li> <li>Creates source distribution</li> <li>Publishes to PyPI using trusted publishing</li> <li>Purpose: Automated deployment</li> </ul>"},{"location":"development/workflow/#local-development-tips","title":"Local Development Tips","text":""},{"location":"development/workflow/#quick-commands","title":"Quick Commands","text":"<pre><code># Run all quality checks (Python)\ncd py-commol &amp;&amp; poetry run ruff check . &amp;&amp; poetry run ruff format . &amp;&amp; poetry run mypy epimodel &amp;&amp; poetry run pytest\n\n# Run all quality checks (Rust)\ncargo fmt --all &amp;&amp; cargo clippy --all-targets &amp;&amp; cargo test --workspace\n\n# Build and test the Python package locally\ncd py-commol\nmaturin develop --release\npoetry run pytest\n</code></pre>"},{"location":"development/workflow/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Install pre-commit hooks to automatically check code before committing:</p> <pre><code>cd py-commol\npoetry run pre-commit install\n</code></pre> <p>This runs:</p> <ul> <li>Ruff linting and formatting</li> <li>MyPy type checking</li> <li>Trailing whitespace removal</li> <li>End-of-file fixing</li> <li>Poetry lock file validation</li> <li>Ensures <code>poetry.lock</code> stays in sync with <code>pyproject.toml</code></li> </ul>"},{"location":"development/workflow/#keeping-poetrylock-in-sync","title":"Keeping poetry.lock in Sync","text":"<p>Important: Always ensure <code>poetry.lock</code> is synchronized with <code>pyproject.toml</code> before committing.</p>"},{"location":"development/workflow/#automatic-recommended","title":"Automatic (Recommended)","text":"<p>Pre-commit hooks handle this automatically:</p> <pre><code>cd py-commol\npoetry run pre-commit install  # One-time setup\n\n# Now git commit automatically updates poetry.lock if needed\ngit add pyproject.toml\ngit commit -m \"chore: update dependencies\"\n</code></pre>"},{"location":"development/workflow/#manual","title":"Manual","text":"<p>If not using pre-commit hooks:</p> <pre><code>cd py-commol\npoetry check  # Check if lock file is in sync\npoetry lock   # Update lock file without changing versions\ngit add poetry.lock\ngit commit -m \"chore: update poetry.lock\"\n</code></pre> <p>Why this matters: Out-of-sync lock files cause CI/CD pipeline failures. The pre-commit hook prevents this automatically.</p>"},{"location":"development/workflow/#debugging-rust-from-python","title":"Debugging Rust from Python","text":"<pre><code># Build with debug symbols\nmaturin develop\n\n# Run Python\ncd py-commol\npoetry run python -m your_test_script.py\n</code></pre>"},{"location":"development/workflow/#building-documentation","title":"Building Documentation","text":"<p>The project uses MkDocs Material for documentation with multi-version support via Mike:</p> <pre><code># Install documentation dependencies\ncd py-commol\npoetry install --with docs\n\n# Serve documentation locally\npoetry run mkdocs serve\n\n# Build documentation\npoetry run mkdocs build\n</code></pre> <p>Visit http://127.0.0.1:8000 to view the documentation locally.</p>"},{"location":"development/workflow/#documentation-versioning","title":"Documentation Versioning","text":"<p>EpiModel maintains two documentation versions:</p> <ul> <li><code>latest</code>: Documentation for the current stable release from the <code>main</code> branch</li> <li><code>dev</code>: Development documentation from the <code>develop</code> branch</li> </ul>"},{"location":"development/workflow/#automatic-deployment","title":"Automatic Deployment","text":"<p>Documentation is automatically deployed when pushing to tracked branches:</p> <ul> <li>Push to <code>main</code>: Deploys to <code>latest</code> version</li> <li>Push to <code>develop</code>: Deploys to <code>dev</code> version</li> <li>Pull requests: Build and validate documentation without deploying</li> </ul> <p>Users can switch between versions using the version selector in the documentation site.</p>"},{"location":"development/workflow/#manual-deployment-if-needed","title":"Manual Deployment (if needed)","text":"<p>If you need to manually deploy documentation:</p> <pre><code># Deploy latest version (from main branch)\ncd py-commol\npoetry run mike deploy --push --update-aliases latest\npoetry run mike set-default --push latest\n\n# Deploy dev version (from develop branch)\ncd py-commol\npoetry run mike deploy --push dev\n\n# List all deployed versions\npoetry run mike list\n\n# Delete a version\npoetry run mike delete &lt;version-name&gt; --push\n</code></pre>"},{"location":"development/workflow/#version-management-tips","title":"Version Management Tips","text":"<ul> <li>The version selector appears in the top-right of the documentation site</li> <li>Each version is completely isolated with its own search index</li> <li>Old versions remain accessible even after new deployments</li> <li>Use <code>mike list</code> to see all deployed versions and aliases</li> </ul>"},{"location":"development/workflow/#next-steps","title":"Next Steps","text":"<ul> <li>Contributing Guidelines - Best practices for contributions</li> <li>Release Process - How releases are managed</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>Rust toolchain (for building from source)</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>Once published, you can install Commol directly from PyPI:</p> <pre><code>pip install commol\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>To install the latest development version:</p>"},{"location":"getting-started/installation/#1-install-prerequisites","title":"1. Install Prerequisites","text":""},{"location":"getting-started/installation/#install-rust","title":"Install Rust","text":"<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre>"},{"location":"getting-started/installation/#install-poetry-optional-for-development","title":"Install Poetry (optional, for development)","text":"<pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre>"},{"location":"getting-started/installation/#2-clone-the-repository","title":"2. Clone the Repository","text":"<pre><code>git clone https://github.com/MUNQU/commol.git\ncd commol\n</code></pre>"},{"location":"getting-started/installation/#3-install-with-pip","title":"3. Install with pip","text":"<pre><code>pip install maturin\ncd py-commol\nmaturin develop --release\n</code></pre>"},{"location":"getting-started/installation/#4-install-with-poetry-for-development","title":"4. Install with Poetry (for development)","text":"<pre><code>cd py-commol\npoetry install\nmaturin develop --release\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test that Commol is correctly installed:</p> <pre><code>from commol import ModelBuilder\nfrom commol.constants import ModelTypes\n\nprint(\"Commol installed successfully!\")\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first model</li> <li>Core Concepts - Understand Commol fundamentals</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will help you build and run your first compartment model with Commol.</p>"},{"location":"getting-started/quickstart/#your-first-sir-model","title":"Your First SIR Model","text":"<p>Let's create a basic SIR (Susceptible-Infected-Recovered) model:</p> <pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n\n# Build the model\nmodel = (\n    ModelBuilder(name=\"Basic SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)   # Transmission rate\n    .add_parameter(id=\"gamma\", value=0.1)  # Recovery rate\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"  # Mathematical formula\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run simulation\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n\n# Display results\nprint(f\"Susceptible at day 100: {results['S'][-1]:.0f}\")\nprint(f\"Infected at day 100: {results['I'][-1]:.0f}\")\nprint(f\"Recovered at day 100: {results['R'][-1]:.0f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"getting-started/quickstart/#1-import-required-classes","title":"1. Import Required Classes","text":"<pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n</code></pre> <ul> <li><code>ModelBuilder</code>: Fluent API for constructing models</li> <li><code>Simulation</code>: Runs the model simulation</li> <li><code>ModelTypes</code>: Enumeration of available model types</li> </ul>"},{"location":"getting-started/quickstart/#2-define-disease-states","title":"2. Define Disease States","text":"<pre><code>.add_bin(id=\"S\", name=\"Susceptible\")\n.add_bin(id=\"I\", name=\"Infected\")\n.add_bin(id=\"R\", name=\"Recovered\")\n</code></pre> <p>Disease states represent compartments in your model.</p>"},{"location":"getting-started/quickstart/#3-add-parameters","title":"3. Add Parameters","text":"<pre><code>.add_parameter(id=\"beta\", value=0.3)   # Transmission rate\n.add_parameter(id=\"gamma\", value=0.1)  # Recovery rate\n</code></pre> <p>Parameters are constants used in transition rate formulas.</p>"},{"location":"getting-started/quickstart/#4-define-transitions","title":"4. Define Transitions","text":"<pre><code>.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"\n)\n</code></pre> <p>Transitions move populations between states using mathematical formulas.</p>"},{"location":"getting-started/quickstart/#5-set-initial-conditions","title":"5. Set Initial Conditions","text":"<pre><code>.set_initial_conditions(\n    population_size=1000,\n    bin_fractions={\"S\": 0.99, \"I\": 0.01, \"R\": 0.0}\n)\n</code></pre> <p>Define the starting population distribution.</p>"},{"location":"getting-started/quickstart/#6-build-and-run","title":"6. Build and Run","text":"<pre><code>model = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"getting-started/quickstart/#adding-unit-checking","title":"Adding Unit Checking","text":"<p>Improve model safety by adding units to your parameters:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR with Units\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.5, unit=\"1/day\")    # Rate per day\n    .add_parameter(id=\"gamma\", value=0.1, unit=\"1/day\")   # Rate per day\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma * I\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Validate dimensional consistency\nmodel.check_unit_consistency()\n</code></pre> <p>Benefits:</p> <ul> <li>Catches unit errors before simulation (e.g., mixing days and weeks)</li> <li>Validates mathematical functions receive correct dimensional arguments</li> <li>Documents the physical meaning of parameters</li> </ul> <p>See the Unit Checking section for details.</p>"},{"location":"getting-started/quickstart/#calibrating-model-parameters","title":"Calibrating Model Parameters","text":"<p>Once you have a model, you can calibrate its parameters to match observed data using the <code>Calibrator</code> class:</p> <pre><code>from commol import (\n    Calibrator,\n    CalibrationProblem,\n    CalibrationParameter,\n    ObservedDataPoint,\n    LossConfig,\n    LossFunction,\n    OptimizationConfig,\n    OptimizationAlgorithm,\n    ParticleSwarmConfig,\n)\n\n# Suppose we have observed infected counts at different time steps\nobserved_data = [\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5),\n    ObservedDataPoint(step=30, compartment=\"I\", value=62.3),\n    ObservedDataPoint(step=40, compartment=\"I\", value=38.1),\n]\n\n# Define which parameters to calibrate and their bounds\nparameters = [\n    CalibrationParameter(id=\"beta\", min_bound=0.0, max_bound=1.0),\n    CalibrationParameter(id=\"gamma\", min_bound=0.0, max_bound=1.0),\n]\n\n# Configure the calibration problem\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=parameters,\n    loss_config=LossConfig(function=LossFunction.SSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n        config=ParticleSwarmConfig(max_iterations=300, verbose=True),\n    ),\n)\n\n# Run calibration\ncalibrator = Calibrator(simulation, problem)\nresult = calibrator.run()\n\n# Display calibrated parameters\nprint(f\"Calibrated beta: {result.best_parameters['beta']:.4f}\")\nprint(f\"Calibrated gamma: {result.best_parameters['gamma']:.4f}\")\nprint(f\"Final loss: {result.final_loss:.6f}\")\n</code></pre> <p>Key concepts:</p> <ul> <li><code>ObservedDataPoint</code>: Real-world measurements to fit against</li> <li><code>CalibrationParameter</code>: Parameters to optimize with bounds</li> <li><code>LossFunction</code>: How to measure fit quality (SSE, RMSE, MAE, etc.)</li> <li><code>OptimizationAlgorithm</code>: Optimization method (Particle Swarm or Nelder-Mead)</li> </ul> <p>See the Calibration Guide for advanced techniques.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've built your first model, explore:</p> <ul> <li>Core Concepts - Deep dive into EpiModel concepts</li> <li>Building Models - Advanced model construction</li> <li>Mathematical Expressions - Complex rate formulas</li> <li>Model Calibration - Comprehensive calibration guide</li> <li>Examples - More complete examples</li> </ul>"},{"location":"guide/building-models/","title":"Building Models","text":"<p>The <code>ModelBuilder</code> class provides a fluent API for constructing compartment models.</p>"},{"location":"guide/building-models/#modelbuilder-basics","title":"ModelBuilder Basics","text":""},{"location":"guide/building-models/#creating-a-builder","title":"Creating a Builder","text":"<pre><code>from commol import ModelBuilder\n\nbuilder = ModelBuilder(\n    name=\"My Model\",\n    version=\"1.0\",\n    description=\"Optional description\"\n)\n</code></pre>"},{"location":"guide/building-models/#chaining-methods","title":"Chaining Methods","text":"<p>The builder uses method chaining for a clean, readable API:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR Model\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .build(ModelTypes.DIFFERENCE_EQUATIONS)\n)\n</code></pre>"},{"location":"guide/building-models/#adding-disease-states","title":"Adding Disease States","text":"<pre><code>builder.add_bin(\n    id=\"S\",                    # Required: Unique identifier\n    name=\"Susceptible\",        # Required: Display name\n    description=\"Population susceptible to infection\"  # Optional\n)\n</code></pre>"},{"location":"guide/building-models/#best-practices","title":"Best Practices","text":"<ul> <li>Use short, clear IDs (S, I, R, E, etc.)</li> <li>Provide descriptive names</li> </ul>"},{"location":"guide/building-models/#adding-stratifications","title":"Adding Stratifications","text":"<p>Stratifications create population subgroups:</p> <pre><code>builder.add_stratification(\n    id=\"age_group\",\n    categories=[\"0-17\", \"18-64\", \"65+\"],\n    description=\"Age-based stratification\"\n)\n</code></pre>"},{"location":"guide/building-models/#multiple-stratifications","title":"Multiple Stratifications","text":"<pre><code>builder.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\nbuilder.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n</code></pre> <p>This creates compartments: <code>S_young_urban</code>, <code>S_young_rural</code>, <code>S_old_urban</code>, <code>S_old_rural</code>, etc.</p>"},{"location":"guide/building-models/#adding-parameters","title":"Adding Parameters","text":"<p>Parameters are global constants used in formulas:</p> <pre><code>builder.add_parameter(\n    id=\"beta\",\n    value=0.3,\n    description=\"Transmission rate per contact per day\"\n)\n</code></pre>"},{"location":"guide/building-models/#parameters-with-units","title":"Parameters with Units","text":"<p>You can specify units for automatic dimensional analysis and validation:</p> <pre><code>builder.add_parameter(\n    id=\"beta\",\n    value=0.5,\n    description=\"Transmission rate\",\n    unit=\"1/day\"  # Rate unit\n)\n\nbuilder.add_parameter(\n    id=\"seasonal_amplitude\",\n    value=0.2,\n    description=\"Seasonal variation amplitude\",\n    unit=\"dimensionless\"  # Pure number\n)\n</code></pre> <p>When all parameters have units, the model will automatically validate dimensional consistency. See Unit Checking below.</p>"},{"location":"guide/building-models/#parameter-guidelines","title":"Parameter Guidelines","text":"<ul> <li>Use meaningful IDs (beta, gamma, R0, etc.)</li> <li>Document units and meaning</li> <li>Ensure values are realistic for your model</li> <li>Specify units for automatic validation (recommended)</li> </ul>"},{"location":"guide/building-models/#adding-transitions","title":"Adding Transitions","text":"<p>Transitions move populations between states.</p>"},{"location":"guide/building-models/#understanding-transition-rates","title":"Understanding Transition Rates","text":"<p>The <code>rate</code> parameter accepts mathematical expressions that can include:</p> <ul> <li>Parameters: Reference parameter IDs (e.g., <code>\"gamma\"</code>)</li> <li>Disease states: Use state populations (e.g., <code>\"S\"</code>, <code>\"I\"</code>)</li> <li>Special variables: <code>N</code> (total population), <code>step</code> or <code>t</code> (current time step), <code>pi</code>, <code>e</code></li> <li>Mathematical operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> (power)</li> <li>Functions: <code>sin()</code>, <code>cos()</code>, <code>exp()</code>, <code>log()</code>, <code>sqrt()</code>, <code>max()</code>, <code>min()</code>, etc.</li> </ul> <p>For the complete list of functions and advanced examples, see Mathematical Expressions.</p>"},{"location":"guide/building-models/#simple-parameter-based-rates","title":"Simple Parameter-Based Rates","text":"<pre><code>builder.add_transition(\n    id=\"recovery\",\n    source=[\"I\"],\n    target=[\"R\"],\n    rate=\"gamma\"  # References parameter id\n)\n</code></pre>"},{"location":"guide/building-models/#formula-based-rates","title":"Formula-Based Rates","text":"<pre><code>builder.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"  # Mathematical expression\n)\n</code></pre>"},{"location":"guide/building-models/#constant-rates","title":"Constant Rates","text":"<pre><code>builder.add_transition(\n    id=\"birth\",\n    source=[],      # Empty = enters system\n    target=[\"S\"],\n    rate=\"0.001\"    # Fixed rate\n)\n</code></pre>"},{"location":"guide/building-models/#time-dependent-rates","title":"Time-Dependent Rates","text":"<pre><code>builder.add_transition(\n    id=\"seasonal_infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * (1 + 0.3 * sin(2 * pi * t / 365)) * S * I / N\"\n)\n</code></pre> <p>See Mathematical Expressions for more complex rate formulas.</p>"},{"location":"guide/building-models/#multi-state-transitions","title":"Multi-State Transitions","text":"<pre><code># Death from any compartment\nbuilder.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],  # Empty = leaves system\n    rate=\"mu\"\n)\n</code></pre>"},{"location":"guide/building-models/#stratified-transitions","title":"Stratified Transitions","text":"<p>When a model includes stratifications, you often need different transition rates for different subgroups. The <code>add_transition</code> method supports this via the <code>stratified_rates</code> parameter.</p> <p>This parameter takes a list of dictionaries, where each dictionary defines a rate for a specific combination of stratification categories.</p>"},{"location":"guide/building-models/#single-stratification","title":"Single Stratification","text":"<p>Let's define different recovery rates for different age groups.</p> <pre><code>builder.add_stratification(id=\"age\", categories=[\"child\", \"adult\", \"elderly\"])\nbuilder.add_parameter(id=\"gamma_child\", value=0.15)\nbuilder.add_parameter(id=\"gamma_adult\", value=0.1)\nbuilder.add_parameter(id=\"gamma_elderly\", value=0.08)\n\nbuilder.add_transition(\n    id=\"recovery\",\n    source=[\"I\"],\n    target=[\"R\"],\n    stratified_rates=[\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"child\"}],\n            \"rate\": \"gamma_child\"\n        },\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"adult\"}],\n            \"rate\": \"gamma_adult\"\n        },\n        {\n            \"conditions\": [{\"stratification\": \"age\", \"category\": \"elderly\"}],\n            \"rate\": \"gamma_elderly\"\n        },\n    ]\n)\n</code></pre>"},{"location":"guide/building-models/#multi-stratification-transitions","title":"Multi-Stratification Transitions","text":"<p>To define rates for intersections of multiple stratifications, add multiple conditions to a single rate entry.</p> <p>For example, let's model different infection rates for high-risk adults in urban areas.</p> <pre><code>builder.add_stratification(id=\"age\", categories=[\"child\", \"adult\"])\nbuilder.add_stratification(id=\"risk\", categories=[\"low\", \"high\"])\nbuilder.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n\nbuilder.add_parameter(id=\"beta_urban_adult_high_risk\", value=0.8)\nbuilder.add_parameter(id=\"beta_default\", value=0.3)\n\nbuilder.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta_default * S * I / N\",  # Fallback rate\n    stratified_rates=[\n        {\n            \"conditions\": [\n                {\"stratification\": \"age\", \"category\": \"adult\"},\n                {\"stratification\": \"risk\", \"category\": \"high\"},\n                {\"stratification\": \"location\", \"category\": \"urban\"},\n            ],\n            \"rate\": \"beta_urban_adult_high_risk * S * I / N\"\n        }\n    ]\n)\n</code></pre> <p>In this example:</p> <ul> <li>The <code>rate</code> parameter acts as a fallback for any compartment that doesn't match a specific stratified rate.</li> <li>The <code>stratified_rates</code> entry defines a high infection rate that only applies to compartments matching all three conditions (e.g., <code>S_adult_high_urban</code>).</li> </ul>"},{"location":"guide/building-models/#setting-initial-conditions","title":"Setting Initial Conditions","text":""},{"location":"guide/building-models/#basic-setup","title":"Basic Setup","text":"<pre><code>builder.set_initial_conditions(\n    population_size=1000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},\n        {\"bin\": \"I\", \"fraction\": 0.01},\n        {\"bin\": \"R\", \"fraction\": 0.0}\n    ]\n)\n</code></pre>"},{"location":"guide/building-models/#with-stratifications","title":"With Stratifications","text":"<pre><code>builder.set_initial_conditions(\n    population_size=10000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},\n        {\"bin\": \"I\", \"fraction\": 0.01},\n        {\"bin\": \"R\", \"fraction\": 0.0}\n    ],\n    stratification_fractions=[\n        {\n            \"stratification\": \"age_group\",\n            \"fractions\": [\n                {\"category\": \"young\", \"fraction\": 0.3},\n                {\"category\": \"adult\", \"fraction\": 0.5},\n                {\"category\": \"elderly\", \"fraction\": 0.2}\n            ]\n        },\n        {\n            \"stratification\": \"risk\",\n            \"fractions\": [\n                {\"category\": \"low\", \"fraction\": 0.8},\n                {\"category\": \"high\", \"fraction\": 0.2}\n            ]\n        }\n    ]\n)\n</code></pre>"},{"location":"guide/building-models/#building-the-model","title":"Building the Model","text":"<p>Once all components are added, build the model:</p> <pre><code>from commol.constants import ModelTypes\n\nmodel = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n</code></pre>"},{"location":"guide/building-models/#validation","title":"Validation","text":"<p>The build process validates:</p> <ul> <li>All disease state fractions sum to 1.0</li> <li>All stratification fractions sum to 1.0</li> <li>Transition sources/targets reference valid states</li> <li>Mathematical expressions are syntactically correct</li> <li>No security issues in formulas</li> </ul> <p>If validation fails, a descriptive error is raised.</p>"},{"location":"guide/building-models/#unit-checking","title":"Unit Checking","text":"<p>EpiModel provides automatic dimensional analysis to catch unit errors in your model equations. This validates that rate expressions produce the correct units and that mathematical functions receive dimensionally correct arguments.</p>"},{"location":"guide/building-models/#enabling-unit-checking","title":"Enabling Unit Checking","text":"<p>Unit checking is enabled when all parameters have units:</p> <pre><code># Build model with units\nbuilder = ModelBuilder(name=\"SIR with Units\", version=\"1.0\")\n\nbuilder.add_bin(\"S\", \"Susceptible\")\nbuilder.add_bin(\"I\", \"Infected\")\nbuilder.add_bin(\"R\", \"Recovered\")\n\n# Specify units for all parameters\nbuilder.add_parameter(\"beta\", 0.5, \"Transmission rate\", unit=\"1/day\")\nbuilder.add_parameter(\"gamma\", 0.1, \"Recovery rate\", unit=\"1/day\")\n\nbuilder.add_transition(\n    \"infection\", [\"S\"], [\"I\"],\n    rate=\"beta * S * I / N\"\n)\nbuilder.add_transition(\"recovery\", [\"I\"], [\"R\"], rate=\"gamma * I\")\n\nbuilder.set_initial_conditions(\n    population_size=1000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},\n        {\"bin\": \"I\", \"fraction\": 0.01},\n        {\"bin\": \"R\", \"fraction\": 0.0},\n    ],\n)\n\nmodel = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n\n# Validate dimensional consistency\nmodel.check_unit_consistency()  # Raises error if units are inconsistent\n</code></pre>"},{"location":"guide/building-models/#common-units","title":"Common Units","text":"<pre><code># Rate units\nunit=\"1/day\"         # Per-day rates\nunit=\"1/week\"        # Per-week rates\n\n# Population units (automatically assigned to disease states)\nunit=\"person\"        # Population count\n\n# Dimensionless quantities\nunit=\"dimensionless\" # Ratios, fractions, amplitudes\n</code></pre>"},{"location":"guide/building-models/#mathematical-functions","title":"Mathematical Functions","text":"<p>All standard math functions work with unit checking and validate their arguments:</p> <pre><code># Seasonal forcing (sin requires dimensionless argument)\nbuilder.add_parameter(\"beta_avg\", 0.5, unit=\"1/day\")\nbuilder.add_parameter(\"seasonal_amp\", 0.2, unit=\"dimensionless\")\n\nbuilder.add_transition(\n    \"infection\", [\"S\"], [\"I\"],\n    rate=\"beta_avg * (1 + seasonal_amp * sin(2 * pi * step / 365)) * S * I / N\"\n)\n\n# Exponential decay (exp requires dimensionless argument)\nbuilder.add_parameter(\"beta_0\", 0.5, unit=\"1/day\")\nbuilder.add_parameter(\"decay_rate\", 0.01, unit=\"dimensionless\")\n\nbuilder.add_transition(\n    \"infection\", [\"S\"], [\"I\"],\n    rate=\"beta_0 * exp(-decay_rate * step) * S * I / N\"\n)\n</code></pre> <p>Supported functions: <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>exp</code>, <code>log</code>, <code>sqrt</code>, <code>pow</code>, <code>min</code>, <code>max</code>, <code>abs</code>, and more.</p>"},{"location":"guide/building-models/#automatic-unit-assignment","title":"Automatic Unit Assignment","text":"<p>The system automatically assigns units to:</p> <ul> <li>Disease states: All have units of <code>person</code> (S, I, R, etc.)</li> <li>Population variables: <code>N</code>, <code>N_young</code>, <code>N_urban</code>, etc. have units of <code>person</code></li> <li>Time variables: <code>t</code> and <code>step</code> are dimensionless</li> <li>Constants: <code>pi</code> and <code>e</code> are dimensionless</li> </ul>"},{"location":"guide/building-models/#error-detection","title":"Error Detection","text":"<p>Unit checking catches common errors:</p> <pre><code># Wrong parameter units\nbuilder.add_parameter(\"beta\", 0.5, unit=\"day\")  # Should be \"1/day\"!\n# Error: Unit mismatch: equation has unit 'day * person' but expected 'person/day'\n\n# Dimensional argument to math function\nrate=\"beta * sin(I) * S\"  # I has units of person!\n# Error: Cannot convert from 'person' to 'dimensionless'\n\n# Incompatible units in operations\nrate=\"min(beta, threshold) * S\"  # beta is 1/day, threshold is person\n# Error: Cannot compare incompatible units\n</code></pre>"},{"location":"guide/building-models/#best-practices_1","title":"Best Practices","text":"<ol> <li>Always specify units for physical quantities</li> <li>Use \"dimensionless\" for ratios and fractions</li> <li>Ensure math function arguments are dimensionless (divide by appropriate quantities)</li> <li>Use consistent time units throughout your model</li> </ol>"},{"location":"guide/building-models/#when-unit-checking-is-skipped","title":"When Unit Checking is Skipped","text":"<p>If any parameter lacks a unit, checking is automatically skipped:</p> <pre><code>builder.add_parameter(\"beta\", 0.5)  # No unit\nbuilder.add_parameter(\"gamma\", 0.1, unit=\"1/day\")\n# Unit checking will be skipped (not all parameters have units)\n</code></pre>"},{"location":"guide/building-models/#advanced-conditional-transitions","title":"Advanced: Conditional Transitions","text":"<p>Create transitions that only occur under certain conditions:</p> <pre><code># Create a condition\ncondition = builder.create_condition(\n    logic=\"and\",\n    rules=[\n        {\"variable\": \"state:I\", \"operator\": \"gt\", \"value\": 100},\n        {\"variable\": \"step\", \"operator\": \"gt\", \"value\": 30}\n    ]\n)\n\n# Add conditional transition\nbuilder.add_transition(\n    id=\"intervention\",\n    source=[\"S\"],\n    target=[\"S\"],\n    rate=\"0.5 * beta\",  # Reduced transmission\n    condition=condition\n)\n</code></pre>"},{"location":"guide/building-models/#loading-from-json","title":"Loading from JSON","text":"<p>Load pre-defined models from JSON files:</p> <pre><code>from commol import ModelLoader\n\nmodel = ModelLoader.from_json(\"path/to/model.json\")\n</code></pre>"},{"location":"guide/building-models/#json-structure","title":"JSON Structure","text":"<pre><code>{\n  \"name\": \"SIR Model\",\n  \"version\": \"1.0\",\n  \"population\": {\n    \"disease_states\": [\n      { \"id\": \"S\", \"name\": \"Susceptible\" },\n      { \"id\": \"I\", \"name\": \"Infected\" },\n      { \"id\": \"R\", \"name\": \"Recovered\" }\n    ]\n  },\n  \"parameters\": [\n    { \"id\": \"beta\", \"value\": 0.3 },\n    { \"id\": \"gamma\", \"value\": 0.1 }\n  ],\n  \"dynamics\": {\n    \"typology\": \"difference_equations\",\n    \"transitions\": [\n      {\n        \"id\": \"infection\",\n        \"source\": [\"S\"],\n        \"target\": [\"I\"],\n        \"rate\": \"beta * S * I / N\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"guide/building-models/#complete-example","title":"Complete Example","text":"<pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\n\n# Build SEIR model\nmodel = (\n    ModelBuilder(name=\"SEIR Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"E\", name=\"Exposed\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4, description=\"Transmission rate\")\n    .add_parameter(id=\"sigma\", value=0.2, description=\"Incubation rate\")\n    .add_parameter(id=\"gamma\", value=0.1, description=\"Recovery rate\")\n    .add_transition(id=\"exposure\", source=[\"S\"], target=[\"E\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"infection\", source=[\"E\"], target=[\"I\"], rate=\"sigma\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.999},\n            {\"bin\": \"E\", \"fraction\": 0.0},\n            {\"bin\": \"I\", \"fraction\": 0.001},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run simulation\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=200)\n</code></pre>"},{"location":"guide/building-models/#next-steps","title":"Next Steps","text":"<ul> <li>Mathematical Expressions - Advanced formulas</li> <li>Simulations - Running and analyzing models</li> <li>Examples - Complete model examples</li> </ul>"},{"location":"guide/calibration/","title":"Model Calibration","text":"<p>Calibration is the process of adjusting model parameters to match observed data. EpiModel provides a powerful calibration framework that uses optimization algorithms to find the best parameter values that minimize the difference between model predictions and real-world observations.</p>"},{"location":"guide/calibration/#overview","title":"Overview","text":"<p>The calibration process involves:</p> <ol> <li>Defining observed data: Real-world measurements at specific time steps</li> <li>Selecting parameters to calibrate: Which model parameters to optimize</li> <li>Choosing a loss function: How to measure fit quality (SSE, RMSE, MAE, etc.)</li> <li>Selecting an optimization algorithm: Nelder-Mead or Particle Swarm</li> <li>Running the calibration: Finding optimal parameter values</li> <li>Creating a new model: Rebuilding your model with the calibrated parameters</li> </ol> <p>Calibrator Returns Parameter Values Only</p> <p>The <code>Calibrator.run()</code> method returns a <code>CalibrationResult</code> object containing the optimized parameter values, but does not return or modify your model. To use the calibrated parameters, you must create a new model using <code>ModelBuilder</code> with the fitted values.</p>"},{"location":"guide/calibration/#basic-example","title":"Basic Example","text":"<p>Here's a simple calibration of an SIR model's transmission and recovery rates:</p> <pre><code>from commol import (\n    ModelBuilder,\n    Simulation,\n    Calibrator,\n    CalibrationProblem,\n    CalibrationParameter,\n    ObservedDataPoint,\n    LossConfig,\n    LossFunction,\n    OptimizationConfig,\n    OptimizationAlgorithm,\n    ParticleSwarmConfig,\n)\nfrom commol.constants import ModelTypes\n\n# Build the model\nmodel = (\n    ModelBuilder(name=\"SIR Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)   # Initial guess\n    .add_parameter(id=\"gamma\", value=0.1)  # Initial guess\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma * I\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Define observed data (e.g., from real outbreak data)\nobserved_data = [\n    ObservedDataPoint(step=0, compartment=\"I\", value=10.0),\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5),\n    ObservedDataPoint(step=30, compartment=\"I\", value=62.3),\n    ObservedDataPoint(step=40, compartment=\"I\", value=38.1),\n    ObservedDataPoint(step=50, compartment=\"I\", value=18.7),\n]\n\n# Define parameters to calibrate with bounds\nparameters = [\n    CalibrationParameter(\n        id=\"beta\",\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.3  # Optional starting point\n    ),\n    CalibrationParameter(\n        id=\"gamma\",\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.1\n    ),\n]\n\n# Configure the calibration problem\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=parameters,\n    loss_config=LossConfig(function=LossFunction.SSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n        config=ParticleSwarmConfig(\n            num_particles=30,\n            max_iterations=500,\n            verbose=True  # Show optimization progress\n        ),\n    ),\n)\n\n# Run calibration\nsimulation = Simulation(model)\ncalibrator = Calibrator(simulation, problem)\nresult = calibrator.run()\n\n# Display results\nprint(result)\nprint(f\"Calibrated beta: {result.best_parameters['beta']:.4f}\")\nprint(f\"Calibrated gamma: {result.best_parameters['gamma']:.4f}\")\n</code></pre>"},{"location":"guide/calibration/#loss-functions","title":"Loss Functions","text":"<p>EpiModel supports multiple loss functions for measuring fit quality:</p>"},{"location":"guide/calibration/#sum-of-squared-errors-sse","title":"Sum of Squared Errors (SSE)","text":"<p>Default loss function. Minimizes the sum of squared differences:</p> <pre><code>loss_config = LossConfig(function=LossFunction.SSE)\n</code></pre> <p>$$\\text{SSE} = \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2$$</p>"},{"location":"guide/calibration/#root-mean-squared-error-rmse","title":"Root Mean Squared Error (RMSE)","text":"<p>Provides error in the same units as the data:</p> <pre><code>loss_config = LossConfig(function=LossFunction.RMSE)\n</code></pre> <p>$$\\text{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2}$$</p>"},{"location":"guide/calibration/#mean-absolute-error-mae","title":"Mean Absolute Error (MAE)","text":"<p>Less sensitive to outliers:</p> <pre><code>loss_config = LossConfig(function=LossFunction.MAE)\n</code></pre> <p>$$\\text{MAE} = \\frac{1}{n}\\sum_{i=1}^{n} |y_i - \\hat{y}_i|$$</p>"},{"location":"guide/calibration/#weighted-sse","title":"Weighted SSE","text":"<p>Allows different importance for different observations:</p> <pre><code># Give more weight to early observations\nobserved_data = [\n    ObservedDataPoint(step=0, compartment=\"I\", value=10.0, weight=2.0),\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2, weight=1.5),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5, weight=1.0),\n]\n\nloss_config = LossConfig(function=LossFunction.WEIGHTED_SSE)\n</code></pre> <p>$$\\text{WSSE} = \\sum_{i=1}^{n} w_i (y_i - \\hat{y}_i)^2$$</p>"},{"location":"guide/calibration/#optimization-algorithms","title":"Optimization Algorithms","text":""},{"location":"guide/calibration/#particle-swarm-optimization-pso","title":"Particle Swarm Optimization (PSO)","text":"<p>Population-based algorithm inspired by social behavior. Good for global optimization:</p> <pre><code>from commol import ParticleSwarmConfig, OptimizationConfig, OptimizationAlgorithm\n\noptimization_config = OptimizationConfig(\n    algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n    config=ParticleSwarmConfig(\n        num_particles=40,        # Number of particles in swarm\n        max_iterations=1000,     # Maximum iterations\n        target_cost=0.01,        # Stop if loss below this (optional)\n        inertia_factor=0.7,      # Velocity inertia (optional)\n        cognitive_factor=1.5,    # Attraction to personal best (optional)\n        social_factor=1.5,       # Attraction to global best (optional)\n        verbose=True,            # Print progress\n        header_interval=50       # Print header every N iterations\n    ),\n)\n</code></pre> <p>When to use:</p> <ul> <li>Multiple local minima expected</li> <li>Robust global search needed</li> <li>Multiple parameters to calibrate</li> </ul>"},{"location":"guide/calibration/#nelder-mead-simplex","title":"Nelder-Mead Simplex","text":"<p>Derivative-free simplex algorithm. Fast convergence for smooth problems:</p> <pre><code>from commol import NelderMeadConfig, OptimizationConfig, OptimizationAlgorithm\n\noptimization_config = OptimizationConfig(\n    algorithm=OptimizationAlgorithm.NELDER_MEAD,\n    config=NelderMeadConfig(\n        max_iterations=1000,     # Maximum iterations\n        sd_tolerance=1e-6,       # Convergence tolerance\n        alpha=1.0,               # Reflection coefficient (optional)\n        gamma=2.0,               # Expansion coefficient (optional)\n        rho=0.5,                 # Contraction coefficient (optional)\n        sigma=0.5,               # Shrink coefficient (optional)\n        verbose=True,            # Print progress\n        header_interval=50       # Print header every N iterations\n    ),\n)\n</code></pre> <p>When to use:</p> <ul> <li>Smooth, unimodal objective function</li> <li>Few parameters (&lt; 10)</li> <li>Fast convergence desired</li> </ul>"},{"location":"guide/calibration/#advanced-examples","title":"Advanced Examples","text":""},{"location":"guide/calibration/#multi-compartment-calibration","title":"Multi-Compartment Calibration","text":"<p>Calibrate against observations from multiple compartments:</p> <pre><code># Observed data from both infected and recovered compartments\nobserved_data = [\n    # Infected observations\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5),\n    ObservedDataPoint(step=30, compartment=\"I\", value=62.3),\n    # Recovered observations\n    ObservedDataPoint(step=10, compartment=\"R\", value=12.5),\n    ObservedDataPoint(step=20, compartment=\"R\", value=35.8),\n    ObservedDataPoint(step=30, compartment=\"R\", value=68.2),\n]\n\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=[\n        CalibrationParameter(id=\"beta\", min_bound=0.0, max_bound=1.0),\n        CalibrationParameter(id=\"gamma\", min_bound=0.0, max_bound=1.0),\n    ],\n    loss_config=LossConfig(function=LossFunction.RMSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n        config=ParticleSwarmConfig(max_iterations=500, verbose=False),\n    ),\n)\n</code></pre>"},{"location":"guide/calibration/#calibrating-stratified-models","title":"Calibrating Stratified Models","text":"<p>Calibrate parameters specific to age groups or other stratifications:</p> <pre><code># Build age-stratified model\nmodel = (\n    ModelBuilder(name=\"Age-Stratified SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma_young\", value=0.12)\n    .add_parameter(id=\"gamma_old\", value=0.08)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        stratified_rates=[\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"young\"}],\n                \"rate\": \"gamma_young * I\"\n            },\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"old\"}],\n                \"rate\": \"gamma_old * I\"\n            },\n        ]\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ],\n        stratification_fractions=[\n            {\n                \"stratification\": \"age\",\n                \"fractions\": [\n                    {\"category\": \"young\", \"fraction\": 0.6},\n                    {\"category\": \"old\", \"fraction\": 0.4}\n                ]\n            }\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Calibrate stratification-specific parameters\nparameters = [\n    CalibrationParameter(id=\"beta\", min_bound=0.0, max_bound=1.0),\n    CalibrationParameter(id=\"gamma_young\", min_bound=0.05, max_bound=0.2),\n    CalibrationParameter(id=\"gamma_old\", min_bound=0.05, max_bound=0.2),\n]\n\n# Note: Observed data uses stratified compartment names like \"I_young\", \"I_old\"\nobserved_data = [\n    ObservedDataPoint(step=10, compartment=\"I_young\", value=30.5),\n    ObservedDataPoint(step=10, compartment=\"I_old\", value=15.2),\n    ObservedDataPoint(step=20, compartment=\"I_young\", value=52.3),\n    ObservedDataPoint(step=20, compartment=\"I_old\", value=26.1),\n]\n</code></pre>"},{"location":"guide/calibration/#using-calibration-results","title":"Using Calibration Results","text":"<p>Once calibrated, you need to create a new model with the fitted parameters to run predictions:</p> <pre><code># Run calibration\nresult = Calibrator(simulation, problem).run()\n\n# Check if calibration converged\nif result.converged:\n    print(f\"Calibration converged after {result.iterations} iterations\")\n    print(f\"Final loss: {result.final_loss:.6f}\")\n    print(f\"Calibrated parameters: {result.best_parameters}\")\n\n    # Create a new model with the calibrated parameters\n    # You need to rebuild the model with the new parameter values\n    calibrated_model = (\n        ModelBuilder(name=\"Calibrated SIR\", version=\"1.0\")\n        .add_bin(id=\"S\", name=\"Susceptible\")\n        .add_bin(id=\"I\", name=\"Infected\")\n        .add_bin(id=\"R\", name=\"Recovered\")\n        # Use calibrated parameter values\n        .add_parameter(id=\"beta\", value=result.best_parameters[\"beta\"])\n        .add_parameter(id=\"gamma\", value=result.best_parameters[\"gamma\"])\n        .add_transition(\n            id=\"infection\",\n            source=[\"S\"],\n            target=[\"I\"],\n            rate=\"beta * S * I / N\"\n        )\n        .add_transition(\n            id=\"recovery\",\n            source=[\"I\"],\n            target=[\"R\"],\n            rate=\"gamma * I\"\n        )\n        .set_initial_conditions(\n            population_size=1000,\n            bin_fractions=[\n                {\"bin\": \"S\", \"fraction\": 0.99},\n                {\"bin\": \"I\", \"fraction\": 0.01},\n                {\"bin\": \"R\", \"fraction\": 0.0}\n            ]\n        )\n        .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n    )\n\n    # Run predictions with calibrated model\n    calibrated_simulation = Simulation(calibrated_model)\n    prediction_results = calibrated_simulation.run(num_steps=200)\n\n    print(f\"Predicted infections at day 200: {prediction_results['I'][-1]:.0f}\")\nelse:\n    print(f\"Calibration did not converge: {result.termination_reason}\")\n</code></pre> <p>Important: The <code>Calibrator</code> returns a <code>CalibrationResult</code> object containing the optimized parameter values, but does not automatically update your model. You must manually create a new model with the calibrated parameters to use them for predictions.</p>"},{"location":"guide/calibration/#best-practices","title":"Best Practices","text":""},{"location":"guide/calibration/#1-choose-appropriate-bounds","title":"1. Choose Appropriate Bounds","text":"<p>Set realistic bounds based on biological knowledge:</p> <pre><code># Too wide: allows unrealistic values\nCalibrationParameter(id=\"beta\", min_bound=0.0, max_bound=100.0)  # Bad\n\n# Reasonable: based on disease characteristics\nCalibrationParameter(id=\"beta\", min_bound=0.1, max_bound=0.8)    # Good\n</code></pre>"},{"location":"guide/calibration/#2-provide-good-initial-guesses","title":"2. Provide Good Initial Guesses","text":"<p>Initial guesses can speed up convergence:</p> <pre><code># Let optimizer choose random\nCalibrationParameter(id=\"beta\", min_bound=0.1, max_bound=0.8)\n\n# Provide informed starting point\nCalibrationParameter(\n    id=\"beta\",\n    min_bound=0.1,\n    max_bound=0.8,\n    initial_guess=0.4  # Based on literature\n)\n</code></pre>"},{"location":"guide/calibration/#3-use-appropriate-loss-functions","title":"3. Use Appropriate Loss Functions","text":"<ul> <li>SSE/RMSE: When all observations equally important</li> <li>MAE: When outliers present in data</li> <li>Weighted SSE: When some observations more reliable</li> </ul>"},{"location":"guide/calibration/#4-choose-the-right-algorithm","title":"4. Choose the Right Algorithm","text":"<ul> <li>Particle Swarm: Complex landscapes, global search, multiple parameters</li> <li>Nelder-Mead: Smooth problems, fewer parameters, faster convergence</li> </ul>"},{"location":"guide/calibration/#5-validate-results","title":"5. Validate Results","text":"<p>Always check biological plausibility:</p> <pre><code>result = calibrator.run()\n\n# Check parameter values make sense\nif result.best_parameters['beta'] &gt; 1.0:\n    print(\"Warning: Unusually high transmission rate\")\n\n# Check final loss\nif result.final_loss &gt; 1000:\n    print(\"Warning: Poor fit quality\")\n\n# Verify convergence\nif not result.converged:\n    print(f\"Warning: Did not converge - {result.termination_reason}\")\n</code></pre>"},{"location":"guide/calibration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/calibration/#calibration-not-converging","title":"Calibration Not Converging","text":"<ul> <li>Increase <code>max_iterations</code></li> <li>Widen parameter bounds</li> <li>Try different optimization algorithm</li> <li>Check if model can actually produce observed patterns</li> </ul>"},{"location":"guide/calibration/#poor-fit-quality","title":"Poor Fit Quality","text":"<ul> <li>Verify observed data is correct</li> <li>Check model structure matches reality</li> <li>Add more parameters if underfitting</li> <li>Use weighted loss to prioritize important observations</li> </ul>"},{"location":"guide/calibration/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete Calibrator API documentation</li> <li>Examples - Additional calibration examples</li> <li>Simulation - Running model simulations</li> </ul>"},{"location":"guide/core-concepts/","title":"Core Concepts","text":"<p>Commol is built around several key concepts that work together to create compartment models.</p>"},{"location":"guide/core-concepts/#disease-states","title":"Disease States","text":"<p>Disease states (also called compartments) represent different stages of infection in your population.</p> <pre><code>builder.add_bin(id=\"S\", name=\"Susceptible\")\nbuilder.add_bin(id=\"E\", name=\"Exposed\")\nbuilder.add_bin(id=\"I\", name=\"Infected\")\nbuilder.add_bin(id=\"R\", name=\"Recovered\")\n</code></pre>"},{"location":"guide/core-concepts/#common-disease-states","title":"Common Disease States","text":"ID Name Description S Susceptible Individuals who can become infected E Exposed Infected but not yet infectious I Infected Actively infected and infectious R Recovered No longer infectious, immune D Dead Deceased from disease"},{"location":"guide/core-concepts/#stratifications","title":"Stratifications","text":"<p>Stratifications allow you to model population subgroups (age, location, risk factors, etc.):</p> <pre><code># Age stratification\nbuilder.add_stratification(\n    id=\"age_group\",\n    categories=[\"young\", \"adult\", \"elderly\"]\n)\n\n# Location stratification\nbuilder.add_stratification(\n    id=\"region\",\n    categories=[\"urban\", \"rural\"]\n)\n</code></pre>"},{"location":"guide/core-concepts/#initial-conditions-with-stratifications","title":"Initial Conditions with Stratifications","text":"<pre><code>builder.set_initial_conditions(\n    population_size=10000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},\n        {\"bin\": \"I\", \"fraction\": 0.01},\n        {\"bin\": \"R\", \"fraction\": 0.0}\n    ],\n    stratification_fractions=[\n        {\n            \"stratification\": \"age_group\",\n            \"fractions\": [\n                {\"category\": \"young\", \"fraction\": 0.3},\n                {\"category\": \"adult\", \"fraction\": 0.5},\n                {\"category\": \"elderly\", \"fraction\": 0.2}\n            ]\n        }\n    ]\n)\n</code></pre> <p>This creates compartments: <code>S_young</code>, <code>S_adult</code>, <code>S_elderly</code>, <code>I_young</code>, etc.</p>"},{"location":"guide/core-concepts/#parameters","title":"Parameters","text":"<p>Parameters are global constants used throughout your model:</p> <pre><code>builder.add_parameter(\n    id=\"beta\",\n    value=0.3,\n    description=\"Transmission rate per contact\"\n)\n\nbuilder.add_parameter(\n    id=\"gamma\",\n    value=0.1,\n    description=\"Recovery rate (1/infectious_period)\"\n)\n</code></pre>"},{"location":"guide/core-concepts/#common-parameters","title":"Common Parameters","text":"Parameter Meaning Typical Range <code>beta</code> Transmission rate 0.1 - 1.0 <code>gamma</code> Recovery rate 0.05 - 0.5 <code>sigma</code> Incubation rate (1/incubation_period) 0.1 - 0.5 <code>mu</code> Birth/death rate 0.0001 - 0.001 <code>R0</code> Basic reproduction number 1.0 - 10.0"},{"location":"guide/core-concepts/#transitions","title":"Transitions","text":"<p>Transitions define how populations move between disease states:</p>"},{"location":"guide/core-concepts/#simple-transitions","title":"Simple Transitions","text":"<pre><code># Recovery: I \u2192 R\nbuilder.add_transition(\n    id=\"recovery\",\n    source=[\"I\"],\n    target=[\"R\"],\n    rate=\"gamma\"\n)\n</code></pre>"},{"location":"guide/core-concepts/#formula-based-transitions","title":"Formula-Based Transitions","text":"<pre><code># Infection: S \u2192 I (with force of infection)\nbuilder.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"\n)\n</code></pre>"},{"location":"guide/core-concepts/#multi-source-transitions","title":"Multi-Source Transitions","text":"<pre><code># Natural death from any state\nbuilder.add_transition(\n    id=\"death\",\n    source=[\"S\", \"I\", \"R\"],\n    target=[],  # Empty = removal from system\n    rate=\"0.000027\"  # Daily death rate\n)\n</code></pre>"},{"location":"guide/core-concepts/#initial-conditions","title":"Initial Conditions","text":"<p>Initial conditions define the starting state of your model:</p> <pre><code>builder.set_initial_conditions(\n    population_size=1000,\n    bin_fractions=[\n        {\"bin\": \"S\", \"fraction\": 0.99},  # 99% susceptible\n        {\"bin\": \"I\", \"fraction\": 0.01},  # 1% infected\n        {\"bin\": \"R\", \"fraction\": 0.0}    # 0% recovered\n    ]\n)\n</code></pre>"},{"location":"guide/core-concepts/#validation-rules","title":"Validation Rules","text":"<ul> <li>Disease state fractions must sum to 1.0</li> <li>Stratification fractions must sum to 1.0 for each stratification</li> <li>Population size must be positive</li> <li>All disease states must have initial fractions defined</li> </ul>"},{"location":"guide/core-concepts/#model-types","title":"Model Types","text":"<p>EpiModel currently supports:</p> <pre><code>from commol.constants import ModelTypes\n\nmodel = builder.build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n</code></pre>"},{"location":"guide/core-concepts/#difference-equations","title":"Difference Equations","text":"<ul> <li>Discrete time steps</li> <li>Deterministic dynamics</li> <li>Fast computation</li> <li>Best for: Population-level modeling, policy analysis</li> </ul>"},{"location":"guide/core-concepts/#the-model-building-process","title":"The Model Building Process","text":"<p>A typical workflow:</p> <ol> <li>Define disease states - What compartments exist?</li> <li>Add stratifications (optional) - What subgroups matter?</li> <li>Define parameters - What rates and constants?</li> <li>Create transitions - How do populations flow?</li> <li>Set initial conditions - What's the starting state?</li> <li>Build the model - Validate and construct</li> <li>Run simulation - Execute and analyze</li> </ol>"},{"location":"guide/core-concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Building Models - Detailed ModelBuilder API</li> <li>Mathematical Expressions - Advanced formulas</li> <li>Examples - Complete model examples</li> </ul>"},{"location":"guide/examples/","title":"Examples","text":"<p>Complete examples demonstrating different modeling scenarios.</p>"},{"location":"guide/examples/#example-1-basic-sir-model","title":"Example 1: Basic SIR Model","text":"<p>Classic Susceptible-Infected-Recovered model:</p> <pre><code>from commol import ModelBuilder, Simulation\nfrom commol.constants import ModelTypes\nimport matplotlib.pyplot as plt\n\n# Build model\nmodel = (\n    ModelBuilder(name=\"Basic SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Simulate\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-2-seir-model","title":"Example 2: SEIR Model","text":"<p>Adding an exposed (incubation) period:</p> <pre><code>model = (\n    ModelBuilder(name=\"SEIR Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"E\", name=\"Exposed\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4, description=\"Transmission rate\")\n    .add_parameter(id=\"sigma\", value=0.2, description=\"Incubation rate\")\n    .add_parameter(id=\"gamma\", value=0.1, description=\"Recovery rate\")\n    .add_transition(id=\"exposure\", source=[\"S\"], target=[\"E\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"infection\", source=[\"E\"], target=[\"I\"], rate=\"sigma\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.999},\n            {\"bin\": \"E\", \"fraction\": 0.0},\n            {\"bin\": \"I\", \"fraction\": 0.001},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-3-seasonal-transmission","title":"Example 3: Seasonal Transmission","text":"<p>Modeling seasonal variation in transmission:</p> <pre><code>model = (\n    ModelBuilder(name=\"Seasonal SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta_mean\", value=0.3)\n    .add_parameter(id=\"beta_amp\", value=0.2)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(\n        id=\"seasonal_infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        # Seasonal forcing: peaks in winter (day 0, 365, ...)\n        rate=\"beta_mean * (1 + beta_amp * sin(2 * pi * step / 365)) * S * I / N\"\n    )\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run for 3 years to see seasonal pattern\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=365 * 3)\n</code></pre>"},{"location":"guide/examples/#example-4-age-stratified-model","title":"Example 4: Age-Stratified Model","text":"<p>Different age groups with varying recovery rates:</p> <pre><code>model = (\n    ModelBuilder(name=\"Age-Stratified SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_stratification(id=\"age\", categories=[\"child\", \"adult\", \"elderly\"])\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma_child\", value=0.15)\n    .add_parameter(id=\"gamma_adult\", value=0.12)\n    .add_parameter(id=\"gamma_elderly\", value=0.08)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        stratified_rates=[\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"child\"}],\n                \"rate\": \"gamma_child\"\n            },\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"adult\"}],\n                \"rate\": \"gamma_adult\"\n            },\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"elderly\"}],\n                \"rate\": \"gamma_elderly\"\n            },\n        ]\n    )\n    .set_initial_conditions(\n        population_size=10000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ],\n        stratification_fractions=[\n            {\n                \"stratification\": \"age\",\n                \"fractions\": [\n                    {\"category\": \"child\", \"fraction\": 0.25},\n                    {\"category\": \"adult\", \"fraction\": 0.55},\n                    {\"category\": \"elderly\", \"fraction\": 0.20}\n                ]\n            }\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-5-vaccination-campaign","title":"Example 5: Vaccination Campaign","text":"<p>Adding vaccination to an SIR model:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR with Vaccination\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.4)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"vax_rate\", value=0.01)  # 1% per day\n    .add_parameter(id=\"vax_eff\", value=0.9)     # 90% effective\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .add_transition(\n        id=\"vaccination\",\n        source=[\"S\"],\n        target=[\"R\"],\n        rate=\"vax_rate * vax_eff\"  # Effective vaccination rate\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Compare with and without vaccination\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-6-healthcare-capacity","title":"Example 6: Healthcare Capacity","text":"<p>Modeling reduced recovery when hospitals are overwhelmed:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIR with Healthcare Capacity\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.5)\n    .add_parameter(id=\"gamma_max\", value=0.15)\n    .add_parameter(id=\"hospital_cap\", value=100.0)\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(\n        id=\"recovery_saturated\",\n        source=[\"I\"],\n        target=[\"R\"],\n        # Recovery slows as infections approach hospital capacity\n        rate=\"gamma_max * (1 - max(0, (I - hospital_cap) / hospital_cap))\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.95},\n            {\"bin\": \"I\", \"fraction\": 0.05},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-7-waning-immunity","title":"Example 7: Waning Immunity","text":"<p>Recovered individuals gradually become susceptible again:</p> <pre><code>model = (\n    ModelBuilder(name=\"SIRS Model\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_parameter(id=\"omega\", value=0.01)  # Waning immunity rate\n    .add_transition(id=\"infection\", source=[\"S\"], target=[\"I\"], rate=\"beta * S * I / N\")\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .add_transition(id=\"waning\", source=[\"R\"], target=[\"S\"], rate=\"omega\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Run for longer to see endemic equilibrium\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=1000)\n</code></pre>"},{"location":"guide/examples/#example-8-multi-stratified-model","title":"Example 8: Multi-Stratified Model","text":"<p>This example demonstrates a model with multiple stratifications (age and risk) and defines a transition rate for a specific intersection of these stratifications.</p> <pre><code>import numpy as np\n\n# Build model\nmodel = (\n    ModelBuilder(name=\"Multi-Stratified SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n    .add_stratification(id=\"risk\", categories=[\"low\", \"high\"])\n    .add_parameter(id=\"beta_low\", value=0.3)\n    .add_parameter(id=\"beta_high\", value=0.6)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta_low * S * I / N\", # Default rate\n        stratified_rates=[\n            {\n                \"conditions\": [{\"stratification\": \"risk\", \"category\": \"high\"}],\n                \"rate\": \"beta_high * S * I / N\"\n            }\n        ]\n    )\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ],\n        stratification_fractions=[\n            {\n                \"stratification\": \"age\",\n                \"fractions\": [\n                    {\"category\": \"young\", \"fraction\": 0.6},\n                    {\"category\": \"old\", \"fraction\": 0.4}\n                ]\n            },\n            {\n                \"stratification\": \"risk\",\n                \"fractions\": [\n                    {\"category\": \"low\", \"fraction\": 0.8},\n                    {\"category\": \"high\", \"fraction\": 0.2}\n                ]\n            }\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Simulate\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-9-subpopulation-dependent-transmission","title":"Example 9: Subpopulation-Dependent Transmission","text":"<p>This example shows how to model frequency-dependent transmission within a specific subpopulation using the automatically calculated <code>N_{category}</code> variable. The infection rate for the <code>young</code> category is normalized by the total <code>young</code> population (<code>N_young</code>), while the <code>old</code> category uses the global population <code>N</code>.</p> <pre><code># Build model\nmodel = (\n    ModelBuilder(name=\"Subpopulation-Dependent SIR\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n    .add_parameter(id=\"beta\", value=0.4)\n    .add_parameter(id=\"gamma\", value=0.1)\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\", # Default rate for old\n        stratified_rates=[\n            {\n                \"conditions\": [{\"stratification\": \"age\", \"category\": \"young\"}],\n                \"rate\": \"beta * S * I / N_young\" # Rate normalized by subpopulation\n            }\n        ]\n    )\n    .add_transition(id=\"recovery\", source=[\"I\"], target=[\"R\"], rate=\"gamma\")\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ],\n        stratification_fractions=[\n            {\n                \"stratification\": \"age\",\n                \"fractions\": [\n                    {\"category\": \"young\", \"fraction\": 0.5},\n                    {\"category\": \"old\", \"fraction\": 0.5}\n                ]\n            }\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Simulate\nsimulation = Simulation(model)\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/examples/#example-10-parameter-calibration","title":"Example 10: Parameter Calibration","text":"<p>Calibrate model parameters to match observed data:</p> <pre><code>from commol import (\n    ModelBuilder,\n    Simulation,\n    Calibrator,\n    CalibrationProblem,\n    CalibrationParameter,\n    ObservedDataPoint,\n    LossConfig,\n    LossFunction,\n    OptimizationConfig,\n    OptimizationAlgorithm,\n    ParticleSwarmConfig,\n)\nfrom commol.constants import ModelTypes\n\n# Build SIR model with initial parameter guesses\nmodel = (\n    ModelBuilder(name=\"SIR for Calibration\", version=\"1.0\")\n    .add_bin(id=\"S\", name=\"Susceptible\")\n    .add_bin(id=\"I\", name=\"Infected\")\n    .add_bin(id=\"R\", name=\"Recovered\")\n    .add_parameter(id=\"beta\", value=0.3)   # Initial guess\n    .add_parameter(id=\"gamma\", value=0.1)  # Initial guess\n    .add_transition(\n        id=\"infection\",\n        source=[\"S\"],\n        target=[\"I\"],\n        rate=\"beta * S * I / N\"\n    )\n    .add_transition(\n        id=\"recovery\",\n        source=[\"I\"],\n        target=[\"R\"],\n        rate=\"gamma * I\"\n    )\n    .set_initial_conditions(\n        population_size=1000,\n        bin_fractions=[\n            {\"bin\": \"S\", \"fraction\": 0.99},\n            {\"bin\": \"I\", \"fraction\": 0.01},\n            {\"bin\": \"R\", \"fraction\": 0.0}\n        ]\n    )\n    .build(typology=ModelTypes.DIFFERENCE_EQUATIONS)\n)\n\n# Define observed data (e.g., from real outbreak surveillance)\nobserved_data = [\n    ObservedDataPoint(step=0, compartment=\"I\", value=10.0),\n    ObservedDataPoint(step=10, compartment=\"I\", value=45.2),\n    ObservedDataPoint(step=20, compartment=\"I\", value=78.5),\n    ObservedDataPoint(step=30, compartment=\"I\", value=62.3),\n    ObservedDataPoint(step=40, compartment=\"I\", value=38.1),\n    ObservedDataPoint(step=50, compartment=\"I\", value=18.7),\n    ObservedDataPoint(step=60, compartment=\"I\", value=8.2),\n]\n\n# Define parameters to calibrate\nparameters = [\n    CalibrationParameter(\n        id=\"beta\",\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.3\n    ),\n    CalibrationParameter(\n        id=\"gamma\",\n        min_bound=0.0,\n        max_bound=1.0,\n        initial_guess=0.1\n    ),\n]\n\n# Configure calibration problem\nproblem = CalibrationProblem(\n    observed_data=observed_data,\n    parameters=parameters,\n    loss_config=LossConfig(function=LossFunction.SSE),\n    optimization_config=OptimizationConfig(\n        algorithm=OptimizationAlgorithm.PARTICLE_SWARM,\n        config=ParticleSwarmConfig(\n            num_particles=30,\n            max_iterations=500,\n            verbose=True\n        ),\n    ),\n)\n\n# Run calibration\nsimulation = Simulation(model)\ncalibrator = Calibrator(simulation, problem)\nresult = calibrator.run()\n\n# Display results\nprint(\"\\n=== Calibration Results ===\")\nprint(f\"Converged: {result.converged}\")\nprint(f\"Iterations: {result.iterations}\")\nprint(f\"Final loss: {result.final_loss:.6f}\")\nprint(f\"Calibrated beta: {result.best_parameters['beta']:.6f}\")\nprint(f\"Calibrated gamma: {result.best_parameters['gamma']:.6f}\")\nprint(f\"Termination reason: {result.termination_reason}\")\n</code></pre>"},{"location":"guide/examples/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Calibration Guide - Comprehensive calibration documentation</li> <li>Mathematical Expressions - Advanced formulas</li> <li>Contributing - Build your own examples</li> </ul>"},{"location":"guide/mathematical-expressions/","title":"Mathematical Expressions","text":"<p>EpiModel supports rich mathematical expressions in transition rates, enabling complex and realistic disease dynamics.</p>"},{"location":"guide/mathematical-expressions/#basic-syntax","title":"Basic Syntax","text":"<p>Transition rates are specified as string expressions that are evaluated during simulation:</p> <pre><code>.add_transition(\n    id=\"infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * S * I / N\"  # Mathematical expression as a string\n)\n</code></pre>"},{"location":"guide/mathematical-expressions/#arithmetic-operations","title":"Arithmetic Operations","text":""},{"location":"guide/mathematical-expressions/#basic-operations","title":"Basic Operations","text":"Operation Operator Example Description Addition <code>+</code> <code>\"alpha + beta\"</code> Sum of two values Subtraction <code>-</code> <code>\"alpha - beta\"</code> Difference Multiplication <code>*</code> <code>\"beta * S\"</code> Product Division <code>/</code> <code>\"I / N\"</code> Division Exponentiation <code>**</code> <code>\"beta ** 2\"</code> Power Parentheses <code>()</code> <code>\"(alpha + beta) * I\"</code> Grouping"},{"location":"guide/mathematical-expressions/#examples","title":"Examples","text":"<pre><code>rate = \"beta * S * I\"           # Multiply transmission rate by populations\nrate = \"gamma + delta\"          # Add two parameters\nrate = \"beta / N\"               # Divide by total population\nrate = \"(beta + gamma) / 2\"     # Average with parentheses\nrate = \"beta ** 2\"              # Square a value\n</code></pre>"},{"location":"guide/mathematical-expressions/#available-variables","title":"Available Variables","text":""},{"location":"guide/mathematical-expressions/#disease-state-variables","title":"Disease State Variables","text":"<p>Reference any disease state by its ID:</p> <pre><code># In a model with states S, I, R\nrate = \"beta * S * I\"    # Use S and I populations\nrate = \"gamma * I\"       # Use I population\nrate = \"0.01 * R\"        # Use R population\n</code></pre>"},{"location":"guide/mathematical-expressions/#special-variables","title":"Special Variables","text":"Variable Type Description <code>N</code> float Total population (automatic sum of all compartments) <code>N_{category}</code> float Total population for a specific stratification category (e.g., <code>N_young</code>) <code>N_{cat1_cat2}</code> float Total population for an intersection of categories (e.g., <code>N_young_urban</code>) <code>step</code> int Current simulation step (0, 1, 2, ...) <code>t</code> int Alias for <code>step</code> <p>Examples:</p> <pre><code>rate = \"beta * I / N\"              # Frequency-dependent transmission\nrate = \"beta * sin(2 * pi * t)\"    # Periodic variation\nrate = \"gamma * exp(-0.01 * step)\" # Exponential decay over time\n</code></pre>"},{"location":"guide/mathematical-expressions/#parameter-references","title":"Parameter References","text":"<p>Reference any parameter by its ID:</p> <pre><code>.add_parameter(id=\"beta\", value=0.3)\n.add_parameter(id=\"gamma\", value=0.1)\n\n.add_transition(rate=\"beta * S * I / N\")  # Uses beta parameter\n.add_transition(rate=\"gamma\")             # Uses gamma parameter\n</code></pre>"},{"location":"guide/mathematical-expressions/#mathematical-functions","title":"Mathematical Functions","text":""},{"location":"guide/mathematical-expressions/#trigonometric-functions","title":"Trigonometric Functions","text":"Function Description Example <code>sin(x)</code> Sine <code>sin(2 * pi * t / 365)</code> <code>cos(x)</code> Cosine <code>cos(t)</code> <code>tan(x)</code> Tangent <code>tan(x)</code> <code>asin(x)</code> Arc sine <code>asin(x)</code> <code>acos(x)</code> Arc cosine <code>acos(x)</code> <code>atan(x)</code> Arc tangent <code>atan(x)</code> <code>atan2(y, x)</code> Two-argument arc tangent <code>atan2(y, x)</code> <p>Example:</p> <pre><code># Seasonal variation (peaks annually)\nrate = \"beta * sin(2 * pi * step / 365)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#exponential-and-logarithmic","title":"Exponential and Logarithmic","text":"Function Description Example <code>exp(x)</code> Exponential (e^x) <code>exp(-0.01 * t)</code> <code>log(x)</code> Natural logarithm <code>log(I + 1)</code> <code>ln(x)</code> Alias for <code>log</code> <code>ln(I + 1)</code> <code>log10(x)</code> Base-10 logarithm <code>log10(I)</code> <code>log2(x)</code> Base-2 logarithm <code>log2(I)</code> <p>Example:</p> <pre><code># Exponential decay over time\nrate = \"gamma * exp(-0.01 * step)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#power-and-root","title":"Power and Root","text":"Function Description Example <code>sqrt(x)</code> Square root <code>sqrt(I)</code> <code>pow(x, y)</code> Power (x^y) <code>pow(I, 2)</code> <code>x ** y</code> Power operator <code>I ** 2</code> <p>Example:</p> <pre><code># Square root relationship\nrate = \"beta * sqrt(I)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#comparison-functions","title":"Comparison Functions","text":"Function Description Example <code>max(a, b)</code> Maximum of two values <code>max(0, beta - 0.01)</code> <code>min(a, b)</code> Minimum of two values <code>min(gamma, 0.5)</code> <code>abs(x)</code> Absolute value <code>abs(x)</code> <p>Example:</p> <pre><code># Ensure rate stays positive\nrate = \"max(0, beta - 0.001 * step)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#rounding-functions","title":"Rounding Functions","text":"Function Description Example <code>floor(x)</code> Round down <code>floor(beta * I)</code> <code>ceil(x)</code> Round up <code>ceil(gamma * I)</code> <code>round(x)</code> Round to nearest <code>round(alpha * I)</code>"},{"location":"guide/mathematical-expressions/#hyperbolic-functions","title":"Hyperbolic Functions","text":"Function Description Example <code>sinh(x)</code> Hyperbolic sine <code>sinh(x)</code> <code>cosh(x)</code> Hyperbolic cosine <code>cosh(x)</code> <code>tanh(x)</code> Hyperbolic tangent <code>tanh(x)</code>"},{"location":"guide/mathematical-expressions/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/mathematical-expressions/#time-dependent-rates","title":"Time-Dependent Rates","text":"<p>Use <code>step</code> or <code>t</code> for time-varying rates:</p> <pre><code># Linear increase\nrate = \"0.1 + 0.001 * step\"\n\n# Exponential decay\nrate = \"beta * exp(-0.01 * t)\"\n\n# Seasonal pattern (annual cycle)\nrate = \"beta * (1 + 0.3 * sin(2 * pi * step / 365))\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#population-dependent-rates","title":"Population-Dependent Rates","text":"<pre><code># Standard mass action\nrate = \"beta * S * I\"\n\n# Frequency-dependent (normalized by population)\nrate = \"beta * S * I / N\"\n\n# Saturation effect\nrate = \"beta * I / (1 + I)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#threshold-effects","title":"Threshold Effects","text":"<pre><code># Activate when condition is met\nrate = \"max(0, beta) * (I &gt; 100)\"  # Only when I &gt; 100\n\n# Reduce transmission above threshold\nrate = \"beta * min(1, 100 / I)\"    # Reduces when I &gt; 100\n</code></pre>"},{"location":"guide/mathematical-expressions/#composite-expressions","title":"Composite Expressions","text":"<p>Combine multiple effects:</p> <pre><code># Seasonal transmission with saturation\nrate = \"beta * (1 + 0.3 * sin(2 * pi * t / 365)) * S * I / (N + I)\"\n\n# Time-varying intervention\nrate = \"beta * max(0.2, 1 - 0.01 * step) * S * I / N\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#operator-precedence","title":"Operator Precedence","text":"<p>From highest to lowest priority:</p> <ol> <li>Parentheses: <code>()</code></li> <li>Exponentiation: <code>**</code></li> <li>Multiplication/Division: <code>*</code>, <code>/</code></li> <li>Addition/Subtraction: <code>+</code>, <code>-</code></li> </ol> <p>Examples:</p> <pre><code>rate = \"2 + 3 * 4\"        # = 14 (multiplication first)\nrate = \"(2 + 3) * 4\"      # = 20 (parentheses first)\nrate = \"2 ** 3 * 4\"       # = 32 (exponentiation first)\nrate = \"2 * 3 ** 4\"       # = 162 (exponentiation before multiplication)\n</code></pre>"},{"location":"guide/mathematical-expressions/#best-practices","title":"Best Practices","text":""},{"location":"guide/mathematical-expressions/#1-use-meaningful-parameters","title":"1. Use Meaningful Parameters","text":"<pre><code># Good: Clear parameter names\n.add_parameter(id=\"beta\", value=0.3)\nrate = \"beta * S * I / N\"\n\n# Avoid: Magic numbers\nrate = \"0.3 * S * I / N\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#2-prevent-division-by-zero","title":"2. Prevent Division by Zero","text":"<pre><code># Good: Add small constant\nrate = \"beta * I / (N + 1)\"\n\n# Good: Use max\nrate = \"beta * I / max(N, 1)\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#3-keep-expressions-simple","title":"3. Keep Expressions Simple","text":"<pre><code># Good: Simple and readable\nrate = \"beta * S * I / N\"\n\n# Acceptable but complex:\nrate = \"beta * (1 + 0.3 * sin(2 * pi * t / 365)) * S * I / N\"\n\n# Better: Split into parameters\n.add_parameter(id=\"seasonal_beta\", value=\"beta * (1 + 0.3 * sin(2 * pi * t / 365))\")\nrate = \"seasonal_beta * S * I / N\"\n</code></pre>"},{"location":"guide/mathematical-expressions/#4-document-complex-expressions","title":"4. Document Complex Expressions","text":"<pre><code>.add_transition(\n    id=\"seasonal_infection\",\n    source=[\"S\"],\n    target=[\"I\"],\n    rate=\"beta * (1 + 0.3 * sin(2 * pi * step / 365)) * S * I / N\",\n    description=\"Infection with 30% seasonal amplitude, annual cycle\"\n)\n</code></pre>"},{"location":"guide/mathematical-expressions/#security-features","title":"Security Features","text":"<p>EpiModel validates all expressions for security:</p>"},{"location":"guide/mathematical-expressions/#safe-operations","title":"Safe Operations","text":"<pre><code>rate = \"beta * S * I / N\"                    # Mathematical operations\nrate = \"sin(2 * pi * t)\"                     # Mathematical functions\nrate = \"max(0, gamma - 0.01 * step)\"        # Built-in functions\n</code></pre>"},{"location":"guide/mathematical-expressions/#blocked-operations","title":"Blocked Operations","text":"<pre><code>rate = \"__import__('os')\"                    # Python imports\nrate = \"eval('code')\"                        # Code evaluation\nrate = \"exec('code')\"                        # Code execution\nrate = \"open('file')\"                        # File operations\n</code></pre> <p>The parser:</p> <ul> <li>Only allows mathematical operations and approved functions</li> <li>Blocks all Python/Rust code execution</li> <li>Validates syntax before simulation</li> <li>Prevents code injection attacks</li> </ul>"},{"location":"guide/mathematical-expressions/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/mathematical-expressions/#expression-complexity","title":"Expression Complexity","text":"<ul> <li>Fast: <code>\"gamma\"</code> (parameter lookup)</li> <li>Fast: <code>\"beta * I\"</code> (simple arithmetic)</li> <li>Medium: <code>\"beta * S * I / N\"</code> (multiple operations)</li> <li>Slower: <code>\"beta * exp(-0.01 * step) * sin(2 * pi * t / 365)\"</code> (functions + operations)</li> </ul>"},{"location":"guide/mathematical-expressions/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use parameters for constants:</li> </ol> <pre><code># Slower: recalculates each step\nrate = \"0.3 * S * I / 1000\"\n\n# Faster: parameter lookup\n.add_parameter(id=\"beta\", value=0.3)\nrate = \"beta * S * I / N\"\n</code></pre> <ol> <li>Simplify when possible:</li> </ol> <pre><code># Complex\nrate = \"beta * I / N + gamma * I / N\"\n\n# Simplified\nrate = \"(beta + gamma) * I / N\"\n</code></pre> <ol> <li>Profile complex models: Use <code>time</code> module to measure performance with different expressions.</li> </ol>"},{"location":"guide/mathematical-expressions/#complete-function-reference","title":"Complete Function Reference","text":""},{"location":"guide/mathematical-expressions/#all-available-functions","title":"All Available Functions","text":"Category Functions Trigonometric <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>asin</code>, <code>acos</code>, <code>atan</code>, <code>atan2</code> Exponential/Log <code>exp</code>, <code>log</code>, <code>ln</code>, <code>log10</code>, <code>log2</code> Power/Root <code>sqrt</code>, <code>pow</code> Comparison <code>max</code>, <code>min</code>, <code>abs</code> Rounding <code>floor</code>, <code>ceil</code>, <code>round</code> Hyperbolic <code>sinh</code>, <code>cosh</code>, <code>tanh</code>"},{"location":"guide/mathematical-expressions/#all-available-variables","title":"All Available Variables","text":"Variable Type Description Disease states float Any state ID (S, I, R, etc.) Parameters float Any parameter ID <code>N</code> float Total population <code>step</code> int Current time step <code>t</code> int Alias for step <code>pi</code> float \u03c0 constant <code>e</code> float e constant"},{"location":"guide/mathematical-expressions/#all-operators","title":"All Operators","text":"Operator Description <code>+</code> Addition <code>-</code> Subtraction <code>*</code> Multiplication <code>/</code> Division <code>**</code> Exponentiation <code>()</code> Grouping"},{"location":"guide/mathematical-expressions/#next-steps","title":"Next Steps","text":"<ul> <li>Building Models - Use expressions in transitions</li> <li>Simulations - Run models with mathematical expressions</li> <li>Examples - See complex expressions in complete models</li> </ul>"},{"location":"guide/simulations/","title":"Running Simulations","text":"<p>Once you've built a model, use the <code>Simulation</code> class to run it and analyze results.</p>"},{"location":"guide/simulations/#basic-simulation","title":"Basic Simulation","text":"<pre><code>from commol import Simulation\n\n# Create simulation from model\nsimulation = Simulation(model)\n\n# Run for 100 time steps\nresults = simulation.run(num_steps=100)\n</code></pre>"},{"location":"guide/simulations/#output-formats","title":"Output Formats","text":"<p>EpiModel supports two output formats for simulation results.</p>"},{"location":"guide/simulations/#dictionary-of-lists-default","title":"Dictionary of Lists (Default)","text":"<p>Each disease state maps to a list of values over time:</p> <pre><code>results = simulation.run(num_steps=100, output_format=\"dict_of_lists\")\n\n# Access results\nsusceptible = results[\"S\"]  # [990, 985, 978, ...]\ninfected = results[\"I\"]     # [10, 15, 22, ...]\nrecovered = results[\"R\"]    # [0, 0, 0, ...]\n\n# Get final values\nfinal_S = results[\"S\"][-1]\nfinal_I = results[\"I\"][-1]\nfinal_R = results[\"R\"][-1]\n\nprint(f\"Final state: S={final_S:.0f}, I={final_I:.0f}, R={final_R:.0f}\")\n</code></pre> <p>Best for: Plotting, time series analysis, accessing specific compartments</p>"},{"location":"guide/simulations/#list-of-lists","title":"List of Lists","text":"<p>Each time step is a list of all compartment values:</p> <pre><code>results = simulation.run(num_steps=100, output_format=\"list_of_lists\")\n\n# results[time][compartment_index]\ninitial_state = results[0]     # [990, 10, 0]\nmidpoint_state = results[50]   # [450, 200, 350]\nfinal_state = results[-1]      # [340, 50, 610]\n\n# Iterate over time steps\nfor t, state in enumerate(results):\n    total = sum(state)\n    print(f\"Step {t}: Total population = {total}\")\n</code></pre> <p>Best for: Matrix operations, comparing states, exporting to CSV</p>"},{"location":"guide/simulations/#working-with-stratifications","title":"Working with Stratifications","text":"<p>Stratifications create multiple compartments by combining disease states with stratification categories. Understanding how to access and analyze stratified results is crucial for complex models.</p>"},{"location":"guide/simulations/#understanding-stratified-compartment-names","title":"Understanding Stratified Compartment Names","text":"<p>When you add stratifications, EpiModel creates compartments by combining disease state IDs with stratification category names using underscore notation:</p> <p>Pattern: <code>{disease_state}_{category1}_{category2}_...</code></p> <pre><code># Model with one stratification (age)\n.add_bin(id=\"S\", name=\"Susceptible\")\n.add_bin(id=\"I\", name=\"Infected\")\n.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n\n# Creates compartments: S_young, S_old, I_young, I_old\n</code></pre> <pre><code># Model with two stratifications (age and location)\n.add_bin(id=\"I\", name=\"Infected\")\n.add_stratification(id=\"age\", categories=[\"child\", \"adult\"])\n.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n\n# Creates compartments:\n# I_child_urban, I_child_rural, I_adult_urban, I_adult_rural\n</code></pre>"},{"location":"guide/simulations/#accessing-stratified-results","title":"Accessing Stratified Results","text":""},{"location":"guide/simulations/#1-list-all-compartments","title":"1. List All Compartments","text":"<pre><code>results = simulation.run(num_steps=100)\n\n# See all compartment names\nprint(\"All compartments:\", list(results.keys()))\n# Output: ['S_young', 'S_old', 'I_young', 'I_old', 'R_young', 'R_old']\n\n# Count compartments\nprint(f\"Total compartments: {len(results)}\")\n</code></pre>"},{"location":"guide/simulations/#2-access-specific-strata","title":"2. Access Specific Strata","text":"<pre><code># Access specific age groups\nyoung_infected = results[\"I_young\"]\nold_infected = results[\"I_old\"]\n\n# Access specific combinations (multiple stratifications)\nurban_child_infected = results[\"I_child_urban\"]\nrural_adult_infected = results[\"I_adult_rural\"]\n</code></pre>"},{"location":"guide/simulations/#3-filter-compartments-by-pattern","title":"3. Filter Compartments by Pattern","text":"<pre><code># Get all infected compartments\ninfected_keys = [key for key in results.keys() if key.startswith(\"I_\")]\nprint(\"Infected compartments:\", infected_keys)\n\n# Get all young compartments\nyoung_keys = [key for key in results.keys() if \"_young\" in key]\nprint(\"Young compartments:\", young_keys)\n\n# Get all urban compartments (multi-stratification)\nurban_keys = [key for key in results.keys() if \"_urban\" in key]\n</code></pre>"},{"location":"guide/simulations/#aggregating-stratified-results","title":"Aggregating Stratified Results","text":""},{"location":"guide/simulations/#sum-across-one-stratification","title":"Sum Across One Stratification","text":"<pre><code># Total infected across all age groups\ntotal_infected = np.array(results[\"I_young\"]) + np.array(results[\"I_old\"])\n\n# Or using list comprehension\ntotal_infected = [y + o for y, o in zip(results[\"I_young\"], results[\"I_old\"])]\n</code></pre>"},{"location":"guide/simulations/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/simulations/#1-case-sensitivity","title":"1. Case Sensitivity","text":"<pre><code># Compartment names use exact category names\n.add_stratification(id=\"age\", categories=[\"Young\", \"Old\"])  # Capital Y and O\n# Access with: results[\"I_Young\"], results[\"I_Old\"]\n</code></pre>"},{"location":"guide/simulations/#2-order-of-stratifications","title":"2. Order of Stratifications","text":"<pre><code># Categories combine in the order stratifications are added\n.add_stratification(id=\"age\", categories=[\"young\", \"old\"])\n.add_stratification(id=\"location\", categories=[\"urban\", \"rural\"])\n\n# Creates: I_young_urban, I_young_rural, I_old_urban, I_old_rural\n# NOT: I_urban_young, I_rural_young, etc.\n</code></pre>"},{"location":"guide/simulations/#3-missing-compartments","title":"3. Missing Compartments","text":"<pre><code># Always check compartments exist before accessing\nkey = \"I_young\"\nif key in results:\n    data = results[key]\nelse:\n    print(f\"Compartment {key} not found. Available: {list(results.keys())}\")\n</code></pre>"},{"location":"guide/simulations/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - Complete model examples with analysis</li> <li>API Reference - Detailed Simulation API</li> <li>Mathematical Expressions - Advanced formulas</li> </ul>"}]}